{"01":{"slug":"01","filePath":"01.md","title":"01","links":[],"tags":[],"content":"\nCet exercice a pour but de nous faire enregistrer un nombre à virgule dans un int pour en faire un nombre à virgule fixe. Il va nous permettre d’aborder les décalages de bit ainsi que la notion de surcharge de fonction et d’opérateur.\n"},"C++":{"slug":"C++","filePath":"C++.md","title":"C++","links":["programmation-orientée-objet","classe","héritage","polymorphisme","surcharge","paradigme-de-programmation","programmation-impérative","programmation-procédurale","programmation-fonctionnelle","C++98","STL","template","allocation-dynamique-de-la-mémoire","C++11","Initiation-au-C++-(à-destination-des-étudiants-de-42)"],"tags":[],"content":"\nNom anglais: C++\n\n\nLe C++ est un langage de programmation conçu pour être rapide, puissant, et flexible. Il est basé sur le C, auquel il ajoute des fonctionnalités majeures comme la programmation orientée objet (POO).\nComparaison C/C++ : Le C++ conserve toute la puissance du C, mais ajoute des concepts modernes comme les classes, l’héritage, le polymorphisme, et la surcharge.\n\n\nOrigine du C++\n\nCréé par Bjarne Stroustrup au début des années 1980.\nSon but était d’améliorer le C en y ajoutant la possibilité d’organiser des programmes complexes de façon plus sûre et plus modulaire.\nInitialement appelé “C with Classes”.\n\n\nCaractéristiques principales\n\nMulti-paradigme : permet plusieurs paradigme de programmation comme la programmation impérative, programmation procédurale, programmation orientée objet, et même programmation fonctionnelle.\nHaute performance : permet de programmer au plus proche de la machine tout en restant flexible.\nContrôle fin de la mémoire (pas de ramasse-miettes automatique par défaut).\nExtensible : on peut créer ses propres types complexes.\nCompatible avec le C pour faciliter la migration de projets.\n\n\nUtilisations du C++\nLe C++ est utilisé dans de nombreux domaines :\n\nDéveloppement de jeux vidéo,\nSystèmes embarqués,\nApplications lourdes (bases de données, navigateurs, moteurs 3D),\nLogiciels nécessitant vitesse et optimisation.\n\n\nÉvolution du langage C++\nLe langage C++ a connu plusieurs standards majeurs depuis sa première normalisation. Chaque version apporte son lot d’améliorations syntaxiques, de fonctionnalités modernes, et d’outils facilitant l’écriture de code plus sûr, lisible et performant :\n\nC++98 : Première norme officielle, formalise la STL, la programmation orientée objet, les templates et l’allocation dynamique de la mémoire. C’est le standard pour les premiers projets à l’école 42.\nC++03 : Révision mineure de C++98(corrections et clarifications, peu de nouveautés visibles).\nC++11 : Révolution moderne ! Ajoute auto, les lambdas, les smart pointers, les move semantics, la boucle range-based for, etc.\nC++14 : Affinage de C++11, améliore les lambdas, auto, make_unique, etc.\nC++17 : Introduit std::optional, if constexpr, structured bindings, améliore la STL.\nC++20 : Nouveau cap majeur avec les coroutines, concepts, ranges, modules, consteval, etc.\nC++23 : Affine encore C++20, avec de nouveaux utilitaires STL, des améliorations de performances et de lisibilité.\n\n\nExemple minimal en C++\n#include &lt;iostream&gt;\n \nint main()\n{\n    std::cout &lt;&lt; &quot;Bonjour, C++ !&quot; &lt;&lt; std::endl;\n    return 0;\n}\n\nPar où commencer?\n→ Initiation au C++ (à destination des étudiants de 42)"},"C++11":{"slug":"C++11","filePath":"C++11.md","title":"C++11","links":["C++","C++98"],"tags":[],"content":"\nNom anglais: C++11\n\n\nC++11 est une version du langage C++ publiée en 2011, qui introduit de nombreuses améliorations modernes par rapport aux versions précédentes (notamment C++98/C++03).\nIl rend le langage plus lisible, plus puissant et plus expressif.\n\n\nPrincipales nouveautés\n\nBoucle range-based for :\nfor (int x : vecteur) { ... }\nMot-clé auto : déduction automatique du type\nInitialisation avec {} (uniform initialization)\nLambdas : fonctions anonymes inline\nSmart pointers : std::unique_ptr, std::shared_ptr\nPerformances : move semantics, rvalue references\n\n\nC++11 à l’école 42\nDans le cadre des exercices de l’école 42, l’utilisation du C++11 est interdite dans les premiers modules du C++. Seul le C++98 est autorisé.\nVoir aussi\n→ C++, C++98"},"C++98":{"slug":"C++98","filePath":"C++98.md","title":"C++98","links":["C++","programmation-orientée-objet","template","STL","classe","héritage","polymorphisme","méthode-virtuelle","surcharge-d'opérateur","constructeur","destructeur","encapsulation","durée-de-vie-des-objets","allocation-dynamique-de-la-mémoire","conteneur","itérateur","bibliothèque-algorithm","foncteur","objet","C++11"],"tags":[],"content":"\nNom anglais: C++98\n\n\nC++98 est la première norme officielle du langage C++, publiée en 1998.\nElle établit les fondations du C++ moderne : programmation orientée objet, templates, et intégration de la STL (Standard Template Library).\nComparaison C/C++ : Contrairement au langage C, C++98 introduit une programmation orientée objet complète, ainsi que des outils puissants pour la programmation générique.\n\n\nFonctionnalités principales\nProgrammation orientée objet\nC++98 prend en charge tous les concepts fondamentaux de la programmation orientée objet (POO):\n\nclasse, héritage, polymorphisme, méthode virtuelle\nsurcharge d’opérateur, constructeur, destructeur\nGestion fine de l’encapsulation et de la durée de vie des objets\n\nTemplates\n\nSupport complet des fonctions et classes génériques\nUtilisation intensive dans la STL\nPermet la génération automatique de code adapté à différents types\n\nGestion mémoire manuelle\n\nallocation dynamique de la mémoire avec new et delete\nPas de smart pointers (std::unique_ptr, std::shared_ptr)\nLe programmeur est responsable de libérer la mémoire\n\n\nSTL (Standard Template Library)\nC++98 officialise la STL, composée de :\n\nconteneurs génériques : std::vector, std::list, std::map, etc.\nitérateurs standards pour naviguer dans les conteneurs\nAlgorithmes dans la bibliothèque algorithm: std::sort, std::find, std::copy, etc.\nfoncteurs (objets fonctionnels)\nIntégration fluide avec les templates\n\n\nLimitations (vs C++ modernes)\nC++98 ne propose aucune des fonctionnalités modernes :\n\nPas de auto, nullptr, lambda, for-each, range-based loop\nTypage strict, pas d’inférence\nSyntaxe longue et verbeuse\nGestion manuelle de la mémoire\nPas de move semantics, constexpr, enum class, etc.\n\n\nC++98 à l’école 42\nDans les modules d’introduction de l’école 42 :\n\nL’usage du C++98 est obligatoire\nLa STL est interdite dans les premiers projets\nIl faut coder soi-même toutes les structures de base (tableaux dynamiques, tri, structures de données, etc.)\nSeuls certains headers sont autorisés : &lt;iostream&gt;, &lt;string&gt;, etc.\n\n\nRésumé\nC++98 est une version stable, rigoureuse, et exigeante du C++.\nElle forme les bases solides nécessaires à la compréhension du langage, même si elle manque des facilités des versions modernes.\nApprendre C++98, c’est maîtriser les fondations : mémoire, objet, template, programmation orientée objet, sans l’aide des outils automatiques récents.\n\nVoir aussi\n→ C++, C++11\n→ template, programmation orientée objet, allocation dynamique de la mémoire\n→ STL, bibliothèque algorithm, itérateur"},"GNU":{"slug":"GNU","filePath":"GNU.md","title":"GNU","links":["système-d’exploitation","UNIX","compilateur"],"tags":[],"content":"Qu’est-ce que GNU?\n\nGNU est un projet lancé en 1983 par Richard Stallman pour créer un système d’exploitation libre, c’est-à-dire que tout le monde peut utiliser, modifier et partager les logiciels sans restrictions.\n\nLe nom GNU signifie “GNU’s Not Unix” (un acronyme récursif), car le projet voulait recréer UNIX, mais en version entièrement libre.\nEn résumé\n\nGNU est une collection d’outils et de programmes libres (compilateurs, éditeurs de texte, commandes système, etc.).\nLe projet GNU est à la base de beaucoup de logiciels libres modernes.\nQuand on utilises Linux, en réalité on utilise souvent GNU/Linux :\n\nLinux = noyau (kernel)\nGNU = outils autour (bash, gcc, g++, etc.)\n\n\n\nExemples de composants GNU célèbres :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComposantRôlegccCompilateur C (GNU Compiler Collection)g++Compilateur C++bashInterpréteur de commandesmakeOutil d’automatisation de compilation\nFun fact\n\nLe projet GNU est aussi à l’origine de la philosophie du logiciel libre.\nLa Free Software Foundation (FSF) a été créée pour le soutenir.\n"},"Module_00":{"slug":"Module_00","filePath":"Module_00.md","title":"Module_00","links":["classe","programmation-orientée-objet","Module_00/ex00","Module_00/ex01","Module_00/ex02"],"tags":[],"content":"\nCe module est constitué de trois exercices (de ex00 à ex01) qui ont pour but d’introduire l’étudiant aux concepts de classe et de programmation orientée objet.\n\nLes exercices\nex00\nex01\nex02"},"Module_00/ex00":{"slug":"Module_00/ex00","filePath":"Module_00/ex00.md","title":"ex00","links":["Module_00","bibliothèque-standard-C++","objet","cout","nom-pleinement-qualifié","espace-de-noms","manipulateur-de-flux","endl","surcharge-d'opérateur","string","méthode","toupper","argument","paramètre"],"tags":[],"content":"\nCe premier exercice du Module_00  a pour but de nous faire afficher du texte à l’écran et d’utiliser une première fonction de la bibliothèque standard C++\n\nAfficher du texte à l’écran\nNous allons pour cela utiliser un objet de la bibliothèque standard C++ :\n→ cout(qui permet d’envoyer des données vers la sortie standard).\nCet objet devra être utilisé en écrivant son nom complet (on dit le nom pleinement qualifié ou fully qualified name en anglais) std::coutcar pour le moment nous n’avons pas le droit d’utiliser using namespace pour les espace de noms (namespace) et cela est de toute façon déconseillé dans les projets sérieux. Nous devrons donc écrire le nom pleinement qualifié:\n→ std::cout\nAfficher un saut de ligne\nPour afficher un saut de ligne nous utiliserons un manipulateur de flux :\n→ endl (en utilisant son nom pleinement qualifié: std::endl)\nExemple simple de texte affiché à l’écran\nint ecole = 42;\nstd::string message = &quot;Welcome at &quot;\n\t\nstd::cout &lt;&lt; &quot;Hello World ! &quot; &lt;&lt; message &lt;&lt; ecole &lt;&lt; std::endl;\n\nCe code affichera à l’écran : Hello World ! Welcome at 42\nVous constaterez que le flux en question accepte des std::string et des int (grâce à la surcharge d’opérateur, mais pas besoin de vous encombrer l’esprit avec cela à ce stade).\n\nLa classe string\nLa classe string est une classe de la bibliothèque standard C++ puissante pour manipuler des chaines de caractères. Elle comprend des méthodes typiques des manipulations de chaines de caractères (comme par exemple lenght()  pour obtenir la longueur de la chaine de caractère). Pour faire appel à cet objet il faut écrire:\n→ std::string\nstd::string str = &quot;Ma chaine de caractère&quot;;\nNotre première fonction de la bibliothèque standard\nPour afficher des majuscules à l’écran lorsque le caractère initial est en minuscule, nous allons utiliser une fonction de la bibliothèque standard C++:\n→ toupper(en utilisant son nom pleinement qualifié: std::toupper)\nCette fonction prend un caractère (char) en argument et retourne sa version majuscule si c’est une lettre minuscule.\nIntégrer tout ça dans des boucles\nL’appel à cout et toupper doit être intégré dans deux boucles imbriquées afin de traiter chaque caractère de chaque argument passé en paramètre à notre programme (via int argc /  char ** argv)."},"Module_00/ex01":{"slug":"Module_00/ex01","filePath":"Module_00/ex01.md","title":"ex01","links":["Module_00","C++","programmation-orientée-objet","classe","forme-canonique-de-Coplien","paradigme-de-programmation","attribut","méthode","objet","privé","publique","UpperCamelCase","accesseur","mutateur","forme-canonique","lowerCamelCase","getline","Getline","bibliothèque-standard-C++","opérateur","surchargé"],"tags":[],"content":"\nCe second exercice du Module_00 fait appel à une notion fondamentale du C++et de la programmation orientée objet: les classes.\n\nVos premières classes\nCet exercice va vous permettre d’aborder le concept de classe. Pour le moment, la forme canonique de Coplien n’est pas obligatoire pour le moment, donc inutile de vous encombrer avec des méthodes inutiles pour l’instant.\nNotions fondamentales\nAvant d’attaquer l’exercice, familiarisez vous avec les concepts suivants (il n’est pas nécessaire de trop approfondir pour le moment) :\n\nLa programmation orientée objet : un paradigme de programmation qui repose sur la modélisation du programme en objet.\nLes classes : des structures améliorées qui regroupent des données (attributs) et des fonctions (méthodes)\nLes attributs : les variables membres contenues dans une classe\nLes méthodes : les fonctions membres définies dans une classe\nLes objets : les instances concrètes d’une classe\nPartie privée : section d’une classe contenant les attributs et les méthodes inaccessibles de l’extérieur de la classe\nPartie publique : section d’une classe contenant les attributs et méthodes accessibles depuis l’extérieur** de la classe\n\nUne classe comme attribut d’une autre classe\nDe la même façon qu’un structure peut elle-même avoir une variable de type structure, une classe peut parfaitement avoir un attribut qui est lui-même une classe.\nCela permet de composer des objets complexes à partir d’objets plus simples.\n\n→ Vous devrez ainsi d’abord créer une classe Contact avec plusieurs attributs (first name, last name, etc), puis une classe PhoneBookqui contiendra un attribut qui sera en fait un tableau de Contact.\n\nÊtre attentifs à la forme\nBien qu’il n’y ait plus de norme au sens strict (nombres de lignes par fonction, etc),  lisez bien le préambule du sujet, car plusieurs conventions sont imposées par 42 au niveau de la forme, comme par exemple :\n\nle nommage des classes en UpperCamelCase\nla structure de fichiers de classes avec pour chaque classe :\n\nun .hpp contenant le prototype de la classe\nun .cpp contenant l’implémentation de la classe\nles attributs sont généralement en privé, ce qui implique généralement d’avoir des méthodes en publique si on a besoin de manipuler ces valeurs depuis l’extérieur, comme par exemple:\n\ndes accesseurs (getters) : méthodes qui permettent de renvoyer un attribut afin d’y accéder depuis l’extérieur\ndes mutateurs (setters) : méthodes qui permettent de fixer la valeur d’un attribut depuis l’extérieur\n\n\nl’utilisation de la forme canonique (à partir du Module02 seulement)\n\n\n\nVous voudrez aussi peut-être respecter d’autres conventions facultatives comme :\n\nle nommage des attributs en lowerCamelCase commençant par un underscore (exemple : _maVariable)\n\nRécupérer la saisie de l’utilisateur\nPlusieurs méthodes sont possibles pour récupérer le texte saisi par l’utilisateur, mais dans cette exercice je vous conseille d’opter pour la fonction getline (permet de récupérer la saisie sans s’arrêter au premier espace).\nGetline faisant parti de la bibliothèque standard C++, vous devrez y faire appel avec son nom pleinement qualifié:\n→ std::getline\nComparaison de std::string\nEn C++, il est tout à fait possible de comparer directement une std::string avec une chaîne de caractères (const char*) ou une autre std::string grâce à la surcharge de l’opérateur ==.\nExemple\nstd::string myString = &quot;SEARCH&quot;;\n \nif (myString == &quot;SEARCH&quot;) {\n    // cette condition est vraie\n}\n\nIci, &quot;SEARCH&quot; est un const char*, mais la comparaison fonctionne car l’opérateur == est surchargé dans la classe std::string pour accepter aussi bien des std::string que des chaînes C (const char*).\n\nAutres comparaisons possibles\nOn peut également utiliser :\n\n!= (différent)\n&lt;, &gt;, &lt;=, &gt;= (ordre lexicographique)\n\nif (myString != &quot;ADD&quot;) { ... }\nif (myString &lt; &quot;ZEBRA&quot;) { ... }"},"Module_00/ex02":{"slug":"Module_00/ex02","filePath":"Module_00/ex02.md","title":"ex02","links":["Module_00","attribut-statique","objet","constructeur","destructeur","new","accesseur","méthode","time","gmtime","strftime"],"tags":[],"content":"\nCe dernier exercice du Module_00 va vous amener à faire une sorte de reverse-engineering à partir d’un code incomplet existant.\n\nCode incomplet\nVous allez devoir coder l’implémentation d’une classe (son .cpp) à partir de son .hpp, de la fonction main du programme, et d’un fichier de log (qui est en fait la sortie attendue du programme).\nAttribut de classe\nVous allez découvrir la notion d’attribut statique : un attribut dont la valeur est commune à toutes les instances de la classe (les objets).\n→ L’attribut de classe est déclaré précédé du mot clé static.\nMéthodes à implémenter\nVous allez devoir implémenter plusieurs méthodes :\n\nun constructeur : la méthode qui crée une instance de la classe (un objet) et notamment qui va initialiser ses attributs si nécessaire\nun destructeur : la méthode qui est appelé automatiquement pour détruire l’objet quand on quitte le programme. La destruction de l’objet est automatique (si il n’a pas été alloué dynamiquement avec new) mais vous pouvez exécuter du code au moment de la destruction de l’objet.\ndes accesseurs : des méthodes pour accéder aux attributs depuis l’extérieur de la classe\nune méthode pour afficher le timestamp\nautres méthodes\n\nTimestamp\nPour implémenter le timestamp, j’ai pour ma part utilisé les fonctions suivantes :\n\ntime (`std::time)\ngmtime (std::gmtime)\nstrftime (std::strftime)\n"},"Module_01":{"slug":"Module_01","filePath":"Module_01.md","title":"Module_01","links":["classe","programmation-orientée-objet","ex00","ex01","ex02","ex03","ex04"],"tags":[],"content":"\nCe module est constitué de six exercices (de ex00 à ex01) qui vont vous permettre d’approfondir les notions de classe et de programmation orientée objet.\n\nLes exercices\nex00\nex01\nex02\nex03\nex04"},"Module_02":{"slug":"Module_02","filePath":"Module_02.md","title":"Module_02","links":["00","01"],"tags":[],"content":"\nCe module\n\nLes exercices\n00\n01\n/02\n/03"},"POSIX":{"slug":"POSIX","filePath":"POSIX.md","title":"POSIX","links":[],"tags":[],"content":"Qu’est-ce que?"},"STL":{"slug":"STL","filePath":"STL.md","title":"STL","links":[],"tags":[],"content":"\nNom anglais: Standard Template Library (STL)\n\n\nLa STL est une partie de la bibliothèque standard C++ qui fournit des outils génériques et efficaces pour gérer des données : conteneurs, algorithmes, itérateurs, etc.\nElle repose sur les templates, ce qui permet de l’utiliser avec n’importe quel type.\n\nComposants principaux de la STL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCatégorieExemplesRôleConteneursstd::vector, std::map, std::set, std::stackStocker des donnéesAlgorithmesstd::sort, std::find, std::countManipuler les donnéesItérateursbegin(), end(), std::next()Parcourir les conteneursFoncteursstd::less, std::greaterObjets-fonctions pour comparer\nExemples simples\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n \nstd::vector&lt;int&gt; v = {3, 1, 4};\nstd::sort(v.begin(), v.end()); // trie le vecteur\nRésumé\n\n📌 La STL est une bibliothèque puissante et générique basée sur les templates.\nElle permet de gérer et manipuler des collections de données de façon rapide et modulaire.\n"},"UNIX":{"slug":"UNIX","filePath":"UNIX.md","title":"UNIX","links":["système-d’exploitation","POSIX"],"tags":[],"content":"Qu’est-ce que UNIX?\n\nUNIX est un système d’exploitation créé dans les années 1970 au sein des laboratoires Bell (AT&amp;T).\nC’est un système rapide, puissant et modulaire, conçu pour être simple, stable et multi-utilisateur.\nBeaucoup de systèmes modernes (Linux, macOS, BSD) sont directement inspirés d’UNIX ou en sont des variantes.\n\nEn résumé\n\nUNIX = système d’exploitation multi-tâches et multi-utilisateur.\nBasé sur des concepts simples : tout est fichier, chaque tâche est un petit programme.\nFavorise la philosophie de la simplicité : faire une chose, mais la faire bien.\nTrès utilisé dans les serveurs, infrastructures réseau, et systèmes critiques.\n\nExemples de descendants ou inspirés d’UNIX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystèmeDétailLinuxUNIX-like libre et open sourcemacOSDirectement basé sur UNIX BSDFreeBSDVariante libre de UNIXSolarisUNIX développé par Sun Microsystems\nÀ retenir :\n\nUNIX n’est pas un seul système, c’est une famille de systèmes qui partagent une philosophie.\nLa norme POSIX (standard pour compatibilité UNIX) est issue de cette culture.\n"},"UpperCamelCase":{"slug":"UpperCamelCase","filePath":"UpperCamelCase.md","title":"UpperCamelCase","links":["convention-de-nommage","classe","structure","énumération","C++"],"tags":[],"content":"\nNom anglais: UpperCamelCase / PascalCase (peu utilisé)\n\n\nLe UpperCamelCase est une convention de nommage utilisée notamment pour nommer les classes.\nChaque mot commence par une majuscule, y compris le premier, et les mots sont collés sans séparateurs.\n\n\nExemples\nclass PhoneBook {};\nclass ContactInfo {};\nstruct UserData {};\n\nUsage en C++\nLa convention de nommageUpperCamelCase est généralement utilisée pour :\n\nclasse class\nstructure struct\nénumération enum\ntype personnalisé\n\n\nComparaison avec d’autres styles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyleExempleUsage typiqueUpperCamelCaseMaClasseClasses, typeslowerCamelCasemaVariableFonctions, variablessnake_casema_variableVariables (C), fichiersSCREAMING_SNAKE_CASETAILLE_MAXConstantes, macros\nRésumé\n\nLe UpperCamelCase est un style d’écriture utilisé pour nommer les types en C++ où chaque mot commence par une majuscule.\nIl améliore la lisibilité et permet de distinguer facilement les types des variables.\n"},"accesseur":{"slug":"accesseur","filePath":"accesseur.md","title":"accesseur","links":["méthode","classe","attribut","privé","membre","structure","C++","encapsulation","objet","publique","valeur","référence"],"tags":[],"content":"\nNom anglais: getter / accessor\n\n\nUn accesseur (getter) est une méthode d’une classe utilisée pour lire la valeur d’un attribut privé sans permettre de la modifier.\nComparaison C/C++ : En C, on accède directement aux membres d’une structure. En C++, on privilégie les accesseurs pour respecter l’encapsulation des données et renforcer la sécurité.\n\n\nPourquoi utiliser un accesseur\nLes attributs sont généralement déclarés en privé pour éviter une modification directe depuis l’extérieur. Un accesseur fournit un moyen contrôlé et sûr d’y accéder, permettant :\n\nde protéger l’état interne de l’objet,\nde changer l’implémentation interne sans modifier l’interface publique,\nde déboguer ou journaliser les accès si nécessaire.\n\n\nEn règle générale, un accesseur est une méthode publique, car son rôle est de permettre la lecture d’un attribut privé depuis l’extérieur de la classe, tout en respectant les principes d’encapsulation.\n\n\nDéfinir un accesseur simple\nUn accesseur est une méthode publique qui retourne la valeur d’un attribut privé :\nclass Voiture {\nprivate:\n    int vitesse;\n \npublic:\n    int getVitesse() const {\n        return vitesse;\n    }\n};\n\nBonne pratique : un accesseur ne modifiant pas l’objet doit être marqué const.\n\n\nUtilisation\nVoiture v;\nint vitesse = v.getVitesse();\nCela récupère la valeur de vitesse sans modifier l’objet v.\n\nRetour par référence constante\nQuand l’attribut est un type complexe (comme std::string, std::vector, ou tout objet non trivial), il est préférable de retourner une référence constante, pour éviter une copie coûteuse :\nclass Voiture {\nprivate:\n    std::string marque;\n \npublic:\n    const std::string&amp; getMarque() const {\n        return marque;\n    }\n};\n\n✅ Avantages :\n\nÉvite une copie inutile\nEmpêche la modification de l’attribut retourné\nMaintient la performance et la sécurité\n\n\nNe pas retourner une référence non-const si on ne veut pas que l’utilisateur modifie l’attribut :\n&gt; std::string&amp; getMarque(); // dangereux si l&#039;utilisateur modifie marque !\n&gt; ```\n \n---\n### Bonnes pratiques\n \n- Préférer `const T&amp;` pour les types complexes (ex: `std::string`, `std::vector`)\n- Préférer `T` pour les types simples (ex: `int`, `bool`, `float`)\n- Toujours marquer l&#039;accesseur `const`\n- Ne jamais exposer une référence non-const à un attribut privé sauf nécessité absolue\n \n---\n### Convention de nommage\n \nLes accesseurs suivent en général la forme `getNomDeLAttribut`. Par exemple :\n \n- `getCouleur()`\n- `getVitesse()`\n- `getMarque()`"},"allocateur":{"slug":"allocateur","filePath":"allocateur.md","title":"allocateur","links":["STL","conteneur","C++","objet","C++98","paramètre","allocation-dynamique-de-la-mémoire"],"tags":[],"content":"\nNom anglais: allocator\nNom pleinement qualifié: std::allocator\n\n\nUn allocateur allocator est une abstraction de la STL qui permet aux conteneurs C++ de gérer la mémoire sans dépendre d’une implémentation spécifique.\nIl définit les mécanismes permettant d’allouer, construire, détruire et désallouer dynamiquement les objets utilisés par un conteneur comme std::vector, std::list, std::map, etc.\n\n\nRôle principal\nUn allocator est utilisé par défaut dans tous les conteneurs de la STL pour :\n\nréserver un espace mémoire (allocate)\nconstruire un objet (construct)\ndétruire un objet (destroy)\nlibérer la mémoire (deallocate)\n\nIl permet ainsi de découpler la gestion mémoire de la logique métier du conteneur.\n\nImplémentation par défaut\nEn C++98, le type d’allocateur par défaut est :\nstd::allocator&lt;T&gt;\n\nC’est l’allocateur standard qui utilise operator new et operator delete pour la gestion mémoire.\n\nTous les conteneurs STL acceptent un paramètre template optionnel pour spécifier un autre allocateur :\nstd::vector&lt;int, std::allocator&lt;int&gt; &gt; myVec;\n\nMéthodes typiques d’un allocateur (C++98)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionallocate(n)Alloue un bloc brut pour n objets de type Tconstruct(p, val)Construit un objet de type T à l’adresse pdestroy(p)Appelle explicitement le destructeur de l’objet à pdeallocate(p, n)Libère le bloc mémoire précédemment alloué\n\nCes fonctions peuvent être utilisées directement dans une implémentation de conteneur personnalisé.\n\n\nExemple d’utilisation par un conteneur\nLors d’un push_back() dans un std::vector :\n\nLe conteneur appelle allocate() si la capacité est dépassée\nIl appelle construct() pour construire l’objet dans la mémoire allouée\nSi un élément est supprimé, il appelle destroy(), puis deallocate()\n\n\nPersonnalisation\nIl est possible de créer un allocator personnalisé pour :\n\ntracer les allocations/désallocations\nutiliser une mémoire fixe ou partagée\nlimiter dynamiquement la quantité de mémoire utilisée\nsimuler des politiques mémoire spécifiques à un système embarqué ou temps réel\n\n\nExemples d’usage avancé\ntemplate&lt;typename T&gt;\nclass MyAlloc : public std::allocator&lt;T&gt; {\npublic:\n\tvoid* allocate(std::size_t n) {\n\t\tstd::cout &lt;&lt; &quot;Allocating &quot; &lt;&lt; n &lt;&lt; &quot; elements\\n&quot;;\n\t\treturn std::allocator&lt;T&gt;::allocate(n);\n\t}\n};\nstd::vector&lt;int, MyAlloc&lt;int&gt; &gt; trackedVec;\n\nVoir aussi\n→ STL, conteneur, allocation dynamique de la mémoire"},"allocation-dynamique-de-la-mémoire":{"slug":"allocation-dynamique-de-la-mémoire","filePath":"allocation dynamique de la mémoire.md","title":"allocation dynamique de la mémoire","links":["C++","tas","pile","opérateur","compilation","objet","bloc","destructeur","durée-de-vie-des-objets","conteneur","structure","fonction","pointeur","C++11,","constructeur"],"tags":[],"content":"\nNom anglais: dynamic memory allocation\n\n\nEn C++, l’allocation dynamique de mémoire permet de réserver manuellement de l’espace sur le tas (heap) pendant l’exécution - à la différence de la pile (stack).\nComparaison C/C++ : On utilise pour cela les opérateurs new, new[], delete et delete[], qui remplacent malloc() et free() de C (même si ces derniers existent toujours en C++).\n\n\nPourquoi allouer dynamiquement ?\n\nQuand la taille des données n’est pas connue à la compilation\nPour créer des objets qui doivent persister au-delà du bloc courant ({})\nPour gérer manuellement la durée de vie, l’accès ou la structure des données (ex: arbres, listes…)\n\n\nDurée de vie des objets en C++\nEn C++, un objet déclaré sans new est dit automatique : il est créé sur la pile au moment où il entre en portée, puis détruit automatiquement à la fin du bloc ({}) où il a été déclaré.\nLe destructeur est alors appelé sans intervention explicite.\nÀ l’inverse, si l’objet est créé avec new, il est alloué sur le tas (heap) et doit être détruit manuellement avec delete.\n→ Voir la fiche dédiée : durée de vie des objets\n\nQuand utiliser new ?\nOn utilise new quand on veut que l’objet continue d’exister après la fin du bloc, c’est-à-dire :\n\nstocké ailleurs (dans un conteneur ou une structure persistante)\npartagé entre plusieurs fonctions\nrenvoyé par une fonction (sans faire de copie)\ncontrôlé manuellement (ex: destruction différée, patterns avancés…)\n\n\nExemple avec new\nMyClass* create_object() {\n    MyClass* ptr = new MyClass(); // alloué sur le tas (heap)\n    return ptr;                   // l&#039;objet vit en dehors de la fonction\n}\nL’objet reste valide même après le retour de la fonction, tant qu’il n’est pas supprimé avec delete.\n\nOpérateurs d’allocation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOpérateurUsageDescriptionnewint *p = new int;Alloue un entier, retourne un pointeurnew[]int *t = new int[10];Alloue un tableau d’entiersdeletedelete p;Libère la mémoire allouée avec newdelete[]delete[] t;Libère la mémoire allouée avec new[]\n\nExemple simple\nint* a = new int(42);      // alloue un int initialisé à 42\nint* t = new int[3];       // alloue un tableau de 3 int\n \nt[0] = 1;\nt[1] = 2;\nt[2] = 3;\n \ndelete a;                  // libère l&#039;entier\ndelete[] t;                // libère le tableau\n\nBonnes pratiques\n\nNe jamais mélanger new avec free() ou malloc() avec delete\nToujours utiliser delete / delete[] une seule fois par allocation\nNe pas oublier de libérer la mémoire → sinon : fuites mémoire\nÀ partir de C++11, il est recommandé d’utiliser des smart pointers (std::unique_ptr, std::shared_ptr) qui libèrent la mémoire automatiquement\n\n\nVoir aussi\n→ tas, pile,\n→ pointeur, fonction, bloc, objet, constructeur, destructeur"},"ami":{"slug":"ami","filePath":"ami.md","title":"ami","links":["C++","fonction","classe","membre","privé","protégé","encapsulation","méthode","surcharge-d'opérateur","attribut","this","objet","accesseur","publique","classe-dérivée"],"tags":[],"content":"\nNom anglais: friend (friend function / friend class)\n\n\nEn C++, le mot-clé friend permet de déclarer une fonction ou une classe amie d’une autre classe. Cela signifie qu’elle a un accès exceptionnel à ses membres privés ou protégés,  sans en faire partie.\nUne fonction amie est une fonction externe à la classe, mais déclarée avec friend à l’intérieur de celle-ci.\nUne classe amie est une classe autorisée à accéder aux membres internes d’une autre classe.\nComparaison C/C++ : En C, il n’existe pas de protection entre les composants. En C++, le mot-clé friend permet d’accorder un accès limité à un tiers, tout en maintenant une encapsulation rigoureuse ailleurs.\n\n\nUtilité du mot-clé friend\nLe mot-clé friend permet :\n\nd’autoriser explicitement l’accès à des membre privés à une fonction ou une classe spécifique,\nd’implémenter des fonctions globales fortement couplées à une classe sans en faire des méthodes,\nde gérer la surcharge d’opérateurs non membres (comme operator&lt;&lt; pour std::ostream par exemple),\nde donner un accès privilégié à une classe de support ou à un outil interne.\n\n\nFonction amie\nDéclaration (prototype)\nUne fonction amie est déclarée avec le mot clé friend à l’intérieur de la classe, mais définie à l’extérieur. Elle aura alors accès aux méthodes et attributs privés et protégés de cette classe.\nclass Boite\n{\nprivate:\n    int _valeur;\n \npublic:\n    Boite(int v);\n    friend void afficher(const Boite&amp; b);\n};\n \nvoid afficher(const Boite&amp; b) {\n    std::cout &lt;&lt; b._valeur &lt;&lt; std::endl; // ✅ autorisé grâce à friend\n}\nUtilisation\nLa fonction amie n’est pas une méthode de la classe : elle n’a pas de this et s’appelle sans opérateur . :\nBoite b(42);\nafficher(b);   // pas b.afficher()\n\nClasse amie\nOn peut aussi déclarer une classe amie. Cela donne à toutes ses méthodes l’accès aux membres privés de la classe déclarant le friend.\nclass A;\n \nclass B {\n    friend class A; // A a accès aux membres privés de B\n};\nIl est également possible de rendre amie une méthode précise d’une autre classe :\nclass A {\n    void speciale();\n};\n \nclass B {\n    friend void A::speciale(); // A::speciale() est autorisée à accéder à B\n};\n\nAccès\nUne fonction ou classe amie peut accéder directement aux membres privés et protégés, mais elle ne devient pas membre de la classe et n’est pas appelée via un objet :\nvoid afficher(const Boite&amp; b) {\n    std::cout &lt;&lt; b._valeur; // autorisé\n}\n\nBonnes pratiques\n\nL’usage de friend doit rester exceptionnel : il contourne l’encapsulation.\nPréférer les accesseurs ou méthodes dans la majorité des cas.\nUtiliser friend uniquement si le besoin d’accès est justifié et ciblé (par exemple pour operator&lt;&lt;, classes de test, outils internes…).\n\nSon usage est justifié principalement lorsqu’une fonction ou une classe a un rôle étroitement lié à l’implémentation interne sans en faire logiquement partie.\n\nVoir aussi\n→ encapsulation, publique, privé, protégé\n→ méthode, classe dérivée, surcharge d’opérateur, accesseur"},"argument":{"slug":"argument","filePath":"argument.md","title":"argument","links":["fonction","paramètre","C++","référence","Paramètre","variable","valeur","Littéral","Variable"],"tags":[],"content":"\nNom anglais: argument\n\n\nUn argument est une valeur réelle transmise à une fonction lors de son appel.\nCette valeur est affectée à un paramètre déclaré dans la fonction.\nComparaison C/C++ : En C comme en C++, les arguments peuvent être des valeurs, des adresses (pointeurs), et en C++uniquement, des références.\n\n\nExemple\nvoid saluer(std::string nom) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\n \nsaluer(&quot;Alice&quot;);  // &quot;Alice&quot; est un argument\nIci, &quot;Alice&quot; est l’argument passé à la fonction saluer.\n\nArgument vs paramètre\nNe pas confondre ces notions proches :\n\nParamètre : variable déclarée dans la fonction (ex : std::string nom)\nArgument : valeur réellement transmise (ex : &quot;Alice&quot;)\n\n→ Voir la fiche dédiée : paramètre\n\nTypes d’arguments\n\nLittéral : &quot;Salut&quot;, 42, 3.14\nVariable : nom, x, valeur\nExpression : a + b, fonction(), tab[i]\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint addition(int a, int b) {\n    return a + b;\n}\n \nint main() {\n    // Littéraux\n    std::string message = &quot;Salut&quot;; // &quot;Salut&quot; est un littéral de type const char*\n    int x = 42;                    // 42 est un littéral entier\n    double pi = 3.14;              // 3.14 est un littéral flottant\n \n    // Variables\n    int a = 10;\n    int b = 5;\n    std::string nom = &quot;Alice&quot;;\n \n    // Expressions\n    int somme = a + b;               // a + b est une expression\n    int resultat = addition(a, b);   // addition(a, b) est une expression\n    char c = nom[0];                 // nom[0] est une expression (accès à un élément)\n \n    // Affichage\n    std::cout &lt;&lt; message &lt;&lt; &quot;, &quot; &lt;&lt; nom &lt;&lt; &quot; !&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; est &quot; &lt;&lt; somme &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;La première lettre de ton nom est : &quot; &lt;&lt; c &lt;&lt; std::endl;\n \n    return 0;\n}\n\nVoir aussi\n→ fonction, paramètre, référence"},"attribut-statique":{"slug":"attribut-statique","filePath":"attribut statique.md","title":"attribut statique","links":["membre-statique"],"tags":[],"content":"→ Voir la fiche : membre statique"},"attribut":{"slug":"attribut","filePath":"attribut.md","title":"attribut","links":["objet","classe","variable","membre","structure","C++","encapsulation","accesseur","attribut","valeur","constructeur","liste-d'initialisation","bibliothèque-standard-C++","privé","publique","protégé","méthode","référence","mutateur","convention-de-nommage","lowerCamelCase","paramètre","constructeur-par-défaut","pointeur","C++11","C++98","membre-statique"],"tags":[],"content":"\nNom anglais: attribute / data members\n\n\nLes attributs représentent les données que chaque objet créé à partir d’une classe va posséder.\nCe sont les variables membres qui définissent l’état interne d’un objet.\nComparaison C/C++ : Les attributs sont comparables aux champs (les variables) d’une structurestruct en langage C, mais en C++, ils sont encapsulés (voir encapsulation) et souvent protégés via des accesseurs.\n\n\nAttributs, classes et objets\nChaque objet possède ses propres copies des attributs définis dans la classe.\nIls décrivent l’état courant de l’objet (valeurs, propriétés internes…).\nExemple :\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nclass Voiture {\nprivate:\n    std::string _couleur;\n};\n \nVoiture voiture1;    // voiture1 est un objet de type Voiture\nVoiture voiture2;    // voiture2 est un objet de type Voiture\n\nLa classe Voiture possède un attribut _couleur privé.\nLe constructeur prend une chaîne de caractères pour initialiser _couleur via une liste d’initialisation.\nChaque objet (voiture1, voiture2) a sa propre valeur de couleur, indépendante de l’autre.\n\n\nAttributs et types\nLes attributs peuvent être de tout type :\n\ntypes fondamentaux (int, float, bool, etc.)\ntypes de la bibliothèque standard C++ (std::string, std::vector, etc.)\nou bien d’autres classes définies par l’utilisateur.\n\n\nDéclaration d’un attribut\nLes attributs sont généralement déclarés dans la section privée (private) d’une classe, afin d’empêcher tout accès ou modification non contrôlée (comme dans l’exemple ci-dessus). Cela fait partie de l’encapsulation.\nLes attributs peuvent être initialisés lors de la construction de l’objet par le constructeur, généralement à l’aide d’une liste d’initialisation.\n→ Voir les fiches dédiées : privé, publique, protégé\n\nInteragir avec un attribut\nPour accéder ou modifier un attribut privé, on utilise généralement:\n\ndes accesseurs (getX()) : des méthodes qui retournent la valeur d’un attribut, souvent sous forme de référence constante\ndes mutateurs (setX(valeur)), des méthodes qui servent à modifier un attribut de manière encadrée\n\n**→ Voir les fiches dédiées : accesseur, mutateur\n\nConventions de nommage\nEn C++, on suit souvent ces convention de nommages pour nommer les attributs :\n\npréfixe _ (underscore) : exemple int _x;\nnom en lowerCamelCase : exemple int vitesseMax;\njamais de noms ambigus ou trop courts (a, b, c) sauf en contexte local\n\nExemple :\n_color\n_registrationDate\n_maxSpeed_\n\nCes conventions permettent de distinguer rapidement les attributs dans la classe et d’éviter les conflits avec les paramètres ou variables locales.\n\n\nExemple\nclass A {\nprivate:\n    int x;              // non initialisé → indéfini\n    std::string nom;    // bien initialisé → &quot;&quot;\n};\nSans action dans le constructeur, x contient une valeur indéfinie, tandis que nom est une chaîne vide (&quot;&quot;), car std::string appelle son constructeur par défaut.\n\nAttributs non initialisés\nSi un attribut n’est pas initialisé explicitement lors de la construction de l’objet par le constructeur, sa valeur dépend de son type :\n\nLes types fondamentaux (int, float, bool, etc.) auront une valeur indéterminée (contenu mémoire brut).\nLes attributs qui sont des objets seront initialisés par leur constructeur par défaut (à condition que celui-ci soit implémenté pour les initialiser). Par exemple un attribut de type std::string sera initialisé par le constructeur de std::string avec une chaîne vide (&quot;&quot;).\nLes pointeurs (int*, etc.) auront eux aussi une valeur indéterminée, sauf s’ils sont explicitement initialisés à nullptr.\n\nCela signifie que le constructeur de la classe doit initialiser explicitement tous les attributs, soit :\n\ndans une liste d’initialisation,\nsoit via une initialisation directe (à partir de C++11),\nmais jamais en les laissant non initialisés.\n\n\nEn C++98, on ne peut pas initialiser directement un attribut dans sa déclaration. Il faut utiliser la liste d’initialisation du constructeur.\n\n\nAttributs statiques\nUn attribut statique (ou attribut de classe) est un membre statique partagé par toutes les instances d’une même classe.\nContrairement aux attributs ordinaires, il n’appartient pas à un objet particulier, mais à la classe elle-même.\nCela signifie que :\n\nil n’existe qu’en un seul exemplaire, peu importe le nombre d’objets créés,\nil peut être accédé directement via le nom de la classe : MaClasse::monAttributStatique.\n\nLes attributs statiques sont utiles pour partager des valeurs globales, des compteurs, ou des constantes communes à tous les objets.\n→ Voir la fiche dédiée : membre statique\n\nVoir aussi\n→ classe, objet, accesseur, mutateur , privé, publique, protégé, convention de nommage, lowerCamelCase, membre statique"},"bibliothèque-algorithm":{"slug":"bibliothèque-algorithm","filePath":"bibliothèque algorithm.md","title":"bibliothèque algorithm","links":["bibliothèque","STL","C++","fonction","membre","vecteur","liste","itérateur","espace-de-noms","nom-pleinement-qualifié","conteneur","foncteur","C++11","paramètre","bibliothèque-standard","bibliothèque-numeric","conteneur-associatif","prédicat","objet","être","opérateur"],"tags":[],"content":"\nBibliothèque standard: &lt;algorithm&gt;\n\n\nLa bibliothèque &lt;algorithm&gt; fait partie de la STL en C++.\nElle fournit un ensemble riche de fonctions génériques (sous forme de fonction libres, non membres) pour le traitement de collections des la STL, telles que vecteur vector, liste list,  etc.\nCes fonctions couvrent des opérations courantes : parcours, tri, recherche, manipulation, fusion, et plus encore. Elles sont toutes basées sur des itérateurs, ce qui les rend très générales.\n\n\nInclusion\nPour utiliser la bibliothèque &lt;algorithm&gt; :\n#include &lt;algorithm&gt;\n\nNom pleinement qualifié\nLes fonctions de &lt;algorithm&gt; sont définies dans l’espace de noms std.  Elles doivent donc être appelées avec leur nom pleinement qualifié:\n→ std::sort, std::find, std::max, etc.\nOu bien écrire:\n→ using namespace std\nCependant, cela peut entraîner des conflits de nom si on inclut d’autres bibliothèques.\nIl est donc recommandé de préfixer explicitement les appels aux fonctions de &lt;algorithm&gt; avec std::\n\nFonctionnement\nLes fonctions de algorithm&gt; sont conçues pour travailler sur deux itérateurs : un début et une fin. Elles ne manipulent pas directement les conteneurs, mais les intervalles que ceux-ci exposent via begin() et end().\nstd::sort(vec.begin(), vec.end());\n\nBeaucoup de ces fonctions utilisent des foncteurs ou des fonctions lambda (à partir de C++11) comme paramètres personnalisés.\n\n\nPrincipales catégories de fonctions\nRecherche &amp; test\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionfindCherche un élément égal à une valeurfind_ifCherche selon un prédicatcountCompte le nombre d’occurrencescount_ifCompte selon un prédicatany_of / all_of / none_ofVérifie une condition sur un intervalle (C++11)equalCompare deux séquencesmismatchCompare deux séquences jusqu’à divergencesearchRecherche une sous-séquence\nManipulation d’éléments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptioncopyCopie une séquencecopy_ifCopie selon un prédicat (C++11)moveDéplace des éléments (C++11)fill / fill_nRemplit avec une valeurreplace / replace_ifRemplace des valeursremove / remove_ifSupprime (logiquement) les élémentstransformApplique une fonction à chaque élémentswap_rangesÉchange deux intervalles\nTri &amp; ordre\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionsortTrie l’intervallestable_sortTrie en conservant l’ordre relatifpartial_sortTrie partiellement le débutnth_elementPositionne le n-ième élément comme s’il était triéis_sortedVérifie si c’est triéis_sorted_untilDonne l’endroit où le tri s’arrête\nMinimum, maximum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionmin, maxRenvoie le plus petit / grand de deux élémentsmin_element / max_elementCherche le min / max dans un intervalle\nRéorganisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionreverseInverse l’ordrerotateDéplace une section du tableaushuffle / random_shuffleMélange les éléments (déprécié en C++14/17)partition / stable_partitionSépare selon un prédicatuniqueSupprime les doublons consécutifs\nFusion &amp; ensembles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionmergeFusionne deux séquences triéesinplace_mergeFusionne deux parties contiguës d’un conteneurincludesVérifie si un ensemble est inclus dans l’autreset_union / set_intersection / set_difference / set_symmetric_differenceOpérations ensemblistes\n→ Pour une description plus détaillée, voir en fin de page\nOpérations numériques\nCertaines fonctions numériques associées aux séquences sont définies non pas dans algorithm, mais dans une bibliothèque standard séparée : la bibliothèque numeric.\nElles permettent de faire des sommations, produits, différences et sommes cumulées sur des intervalles d’itérateurs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstd::accumulateCalcule une somme ou accumulation personnalisée.std::inner_productProduit scalaire entre deux séquences.std::partial_sumCalcule les sommes cumulées d’une séquence.std::adjacent_differenceCalcule les différences successives entre éléments.\n→ Voir la fiche dédiée bibliothèque numeric.\nRemarques importantes\n\nLes fonctions de &lt;algorithm&gt; sont génériques et dépendent uniquement du type d’itérateur\nElles ne modifient pas la taille du conteneur sauf si combinées à des opérations comme erase\nBeaucoup d’entre elles ont une version avec prédicat personnalisé (find_if, sort(pred), etc.)\nPour les conteneur associatifs (map, set), certaines fonctions ne sont pas applicables car ces conteneurs gèrent leur propre ordre.\n\n\nExemple simple\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::vector&lt;int&gt; v = {4, 2, 1, 3};\n    std::sort(v.begin(), v.end());\n    for (int n : v)\n        std::cout &lt;&lt; n &lt;&lt; &#039; &#039;; // 1 2 3 4\n}\n\nDescription détaillée des fonctions (avec valeurs de retour et paramètres)\nRecherche &amp; test\nfind\ntemplate &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; val);\nDescription : La fonction find recherche le premier élément dans l’intervalle [first, last) qui est égal à val. Elle retourne un itérateur pointant sur cet élément s’il est trouvé, sinon elle retourne last.\nType de retour : InputIterator\nCas d’erreurs/Remarques : Si l’élément n’est pas trouvé, l’itérateur retourné sera égal à last. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nfind_if\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription : La fonction find_if recherche le premier élément dans l’intervalle [first, last) pour lequel le prédicat p retourne true. Elle retourne un itérateur pointant sur cet élément s’il est trouvé, sinon elle retourne last.\nType de retour : InputIterator\nCas d’erreurs/Remarques : Si aucun élément ne satisfait le prédicat, l’itérateur retourné sera égal à last. Le prédicat doit être une fonction ou un objet fonction qui accepte un argument du type pointé par InputIterator.\ncount\ntemplate &lt;class InputIterator, class T&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count(InputIterator first, InputIterator last, const T&amp; val);\nDescription : La fonction count compte le nombre d’éléments dans l’intervalle [first, last) qui sont égaux à val.\nType de retour : typename iterator_traits&lt;InputIterator&gt;::difference_type\nCas d’erreurs/Remarques : Retourne 0 si aucun élément n’est trouvé. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\ncount_if\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count_if(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription : La fonction count_if compte le nombre d’éléments dans l’intervalle [first, last) pour lesquels le prédicat p retourne true.\nType de retour : typename iterator_traits&lt;InputIterator&gt;::difference_type\nCas d’erreurs/Remarques : Retourne 0 si aucun élément ne satisfait le prédicat. Le prédicat doit être une fonction ou un objet fonction qui accepte un argument du type pointé par InputIterator.\nany_of / all_of / none_of\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool any_of(InputIterator first, InputIterator last, UnaryPredicate p);\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool all_of(InputIterator first, InputIterator last, UnaryPredicate p);\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool none_of(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription :\n\nany_of : Retourne true si au moins un élément dans l’intervalle [first, last) satisfait le prédicat p.\nall_of : Retourne true si tous les éléments dans l’intervalle [first, last) satisfont le prédicat p.\nnone_of : Retourne true si aucun élément dans l’intervalle [first, last) ne satisfait le prédicat p.\n\nType de retour : bool\nCas d’erreurs/Remarques : Ces fonctions nécessitent que le prédicat soit une fonction ou un objet fonction qui accepte un argument du type pointé par InputIterator.\nequal\ntemplate &lt;class InputIterator1, class InputIterator2&gt; bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\nDescription : La fonction equal compare deux séquences. Elle retourne true si tous les éléments de l’intervalle [first1, last1) sont égaux aux éléments de la séquence commençant à first2.\nType de retour : bool\nCas d’erreurs/Remarques : Les deux séquences doivent avoir au moins last1 - first1 éléments. Sinon, le comportement est indéfini.\nmismatch\ntemplate &lt;class InputIterator1, class InputIterator2&gt; pair&lt;InputIterator1, InputIterator2&gt; mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\nDescription : La fonction mismatch compare deux séquences et retourne une paire d’itérateurs pointant sur le premier élément où les deux séquences diffèrent.\nType de retour : pair&lt;InputIterator1, InputIterator2&gt;\nCas d’erreurs/Remarques : Si les séquences sont identiques jusqu’à last1, la paire retournée sera (last1, first2 + (last1 - first1)).\nsearch\ntemplate &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);\nDescription : La fonction search recherche la première occurrence de la sous-séquence [first2, last2) dans la séquence [first1, last1).\nType de retour : ForwardIterator1\nCas d’erreurs/Remarques : Si la sous-séquence n’est pas trouvée, l’itérateur retourné sera égal à last1. Assurez-vous que les itérateurs sont valides et que les intervalles sont correctement définis.\nManipulation d’éléments\nstd::copy\ntemplate &lt;class InputIterator, class OutputIterator&gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator dest);\nDescription : La fonction std::copy copie les éléments de l’intervalle [first, last) vers la destination commençant à dest. Elle retourne un itérateur pointant sur la fin de la destination.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments copiés.\nstd::copy_if\ntemplate &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt; OutputIterator copy_if(InputIterator first, InputIterator last, OutputIterator dest, UnaryPredicate pred);\nDescription : La fonction std::copy_if copie les éléments de l’intervalle [first, last) pour lesquels le prédicat pred retourne true vers la destination commençant à dest.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments copiés. Le prédicat doit être une fonction ou un objet fonction qui accepte un argument du type pointé par InputIterator.\nstd::move\ntemplate &lt;class InputIterator, class OutputIterator&gt; OutputIterator move(InputIterator first, InputIterator last, OutputIterator dest);\nDescription : La fonction std::move déplace les éléments de l’intervalle [first, last) vers la destination commençant à dest. Elle retourne un itérateur pointant sur la fin de la destination.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments déplacés. Après le déplacement, les éléments source sont laissés dans un état valide mais non spécifié.\nstd::fill\ntemplate &lt;class ForwardIterator, class T&gt; void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);\nDescription : La fonction std::fill remplit l’intervalle [first, last) avec la valeur value.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que l’intervalle est valide et que les itérateurs sont correctement définis.\nstd::fill_n\ntemplate &lt;class OutputIterator, class Size, class T&gt; OutputIterator fill_n(OutputIterator first, Size count, const T&amp; value);\nDescription : La fonction std::fill_n remplit count éléments avec la valeur value, à partir de first.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments remplis.\nstd::replace\ntemplate &lt;class ForwardIterator, class T&gt; void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);\nDescription : La fonction std::replace remplace tous les éléments égaux à old_value par new_value dans l’intervalle [first, last).\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que l’intervalle est valide et que les itérateurs sont correctement définis.\nstd::replace_if\ntemplate &lt;class ForwardIterator, class UnaryPredicate, class T&gt; void replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value);\nDescription : La fonction std::replace_if remplace les éléments satisfaisant le prédicat pred par new_value dans l’intervalle [first, last).\nType de retour : void\nCas d’erreurs/Remarques : Le prédicat doit être une fonction ou un objet fonction qui accepte un argument du type pointé par ForwardIterator.\nstd::remove\ntemplate &lt;class ForwardIterator, class T&gt; ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);\nDescription : La fonction std::remove réarrange les éléments dans l’intervalle [first, last) pour supprimer tous les éléments égaux à value. Elle retourne un itérateur pointant sur la nouvelle fin de l’intervalle.\nType de retour : ForwardIterator\nCas d’erreurs/Remarques : La taille de l’intervalle n’est pas modifiée. Les éléments après la nouvelle fin sont laissés dans un état valide mais non spécifié.\nstd::remove_if\ntemplate &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\nDescription : La fonction std::remove_if réarrange les éléments dans l’intervalle [first, last) pour supprimer tous les éléments satisfaisant le prédicat pred. Elle retourne un itérateur pointant sur la nouvelle fin de l’intervalle.\nType de retour : ForwardIterator\nCas d’erreurs/Remarques : La taille de l’intervalle n’est pas modifiée. Les éléments après la nouvelle fin sont laissés dans un état valide mais non spécifié.\nstd::transform\ntemplate &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt; OutputIterator transform(InputIterator first, InputIterator last, OutputIterator dest, UnaryOperation op);\nDescription : La fonction std::transform applique l’opération unaire op à chaque élément de l’intervalle [first, last) et stocke le résultat dans la destination commençant à dest.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments transformés.\nstd::transform (binaire)\ntemplate &lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt; OutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator dest, BinaryOperation op);\nDescription : La fonction std::transform applique l’opération binaire op à deux séquences en parallèle et stocke le résultat dans la destination commençant à dest.\nType de retour : OutputIterator\nCas d’erreurs/Remarques : Assurez-vous que la destination a suffisamment d’espace pour contenir tous les éléments transformés. Les deux séquences doivent avoir au moins last1 - first1 éléments.\nstd::swap_ranges\ntemplate &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\nDescription : La fonction std::swap_ranges échange les éléments des deux séquences [first1, last1) et [first2, first2 + (last1 - first1)) élément par élément.\nType de retour : ForwardIterator2\nCas d’erreurs/Remarques : Les deux séquences doivent avoir au moins last1 - first1 éléments. Sinon, le comportement est indéfini.\nTri &amp; ordre\nstd::sort\ntemplate &lt;class RandomIt&gt; void sort(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void sort(RandomIt first, RandomIt last, Compare comp);\nDescription : La fonction std::sort trie les éléments dans l’intervalle [first, last) en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini. Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type pointé par RandomIt.\nstd::stable_sort\ntemplate &lt;class RandomIt&gt; void stable_sort(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void stable_sort(RandomIt first, RandomIt last, Compare comp);\nDescription : La fonction std::stable_sort trie les éléments dans l’intervalle [first, last) tout en conservant l’ordre relatif des éléments égaux. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini. Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type pointé par RandomIt.\nstd::partial_sort\ntemplate &lt;class RandomIt&gt; void partial_sort(RandomIt first, RandomIt middle, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp);\nDescription : La fonction std::partial_sort trie les middle - first plus petits éléments dans l’intervalle [first, last) en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini. Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type pointé par RandomIt.\nstd::nth_element\ntemplate &lt;class RandomIt&gt; void nth_element(RandomIt first, RandomIt nth, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);\nDescription : La fonction std::nth_element réorganise les éléments dans l’intervalle [first, last) de sorte que l’élément pointé par nth soit celui qui serait à cette position dans un tri complet. Les éléments avant nth sont inférieurs ou égaux à ceux après nth.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini. Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type pointé par RandomIt.\nstd::is_sorted\ntemplate &lt;class ForwardIt&gt; bool is_sorted(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class Compare&gt; bool is_sorted(ForwardIt first, ForwardIt last, Compare comp);\nDescription : La fonction std::is_sorted vérifie si les éléments dans l’intervalle [first, last) sont triés en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : bool\nCas d’erreurs/Remarques : Retourne true si les éléments sont triés, sinon false. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::is_sorted_until\ntemplate &lt;class ForwardIt&gt; ForwardIt is_sorted_until(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class Compare&gt; ForwardIt is_sorted_until(ForwardIt first, ForwardIt last, Compare comp);\nDescription : La fonction std::is_sorted_until retourne un itérateur pointant sur le premier élément non trié dans l’intervalle [first, last) en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : ForwardIt\nCas d’erreurs/Remarques : Si tous les éléments sont triés, retourne last. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nMinimum, maximum\nVoici les descriptions des fonctions C++ avec la présentation demandée :\nstd::min\ntemplate &lt;class T&gt; const T&amp; min(const T&amp; a, const T&amp; b);\ntemplate &lt;class T, class Compare&gt; const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);\nDescription : La fonction std::min renvoie le plus petit des deux éléments a et b en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : const T&amp;\nCas d’erreurs/Remarques : Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type T.\nstd::max\ntemplate &lt;class T&gt; const T&amp; max(const T&amp; a, const T&amp; b);\ntemplate &lt;class T, class Compare&gt; const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);\nDescription : La fonction std::max renvoie le plus grand des deux éléments a et b en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : const T&amp;\nCas d’erreurs/Remarques : Le comparateur doit être une fonction ou un objet fonction qui accepte deux arguments du type T.\nstd::min_element\ntemplate &lt;class ForwardIterator&gt; ForwardIterator min_element(ForwardIterator first, ForwardIterator last);\ntemplate &lt;class ForwardIterator, class Compare&gt; ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare comp);\nDescription : La fonction std::min_element renvoie un itérateur pointant sur le plus petit élément dans l’intervalle [first, last) en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : ForwardIterator\nCas d’erreurs/Remarques : Si l’intervalle est vide, retourne last. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::max_element\ntemplate &lt;class ForwardIterator&gt; ForwardIterator max_element(ForwardIterator first, ForwardIterator last);\ntemplate &lt;class ForwardIterator, class Compare&gt; ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp);\nDescription : La fonction std::max_element renvoie un itérateur pointant sur le plus grand élément dans l’intervalle [first, last) en utilisant soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : ForwardIterator\nCas d’erreurs/Remarques : Si l’intervalle est vide, retourne last. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nRéorganisation\nstd::reverse\ntemplate &lt;class BidirectionalIterator&gt; void reverse(BidirectionalIterator first, BidirectionalIterator last);\nDescription : La fonction std::reverse inverse l’ordre des éléments dans l’intervalle [first, last).\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::rotate\ntemplate &lt;class ForwardIterator&gt; ForwardIterator rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\nDescription : La fonction std::rotate déplace les éléments de l’intervalle [first, middle) après l’intervalle [middle, last).\nType de retour : ForwardIterator\nCas d’erreurs/Remarques : Retourne un itérateur pointant sur le premier élément de l’intervalle transformé. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::random_shuffle (C++98)\ntemplate &lt;class RandomIt&gt; void random_shuffle(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class RandomFunc&gt; void random_shuffle(RandomIt first, RandomIt last, RandomFunc&amp;&amp; r);\nDescription : La fonction std::random_shuffle mélange les éléments dans l’intervalle [first, last) en utilisant une fonction de génération aléatoire r.\nType de retour : void\nCas d’erreurs/Remarques : Cette fonction est obsolète depuis C++14 et supprimée en C++17. Utilisez std::shuffle à la place.\nstd::shuffle (C++11)\ntemplate &lt;class RandomIt, class URNG&gt; void shuffle(RandomIt first, RandomIt last, URNG&amp;&amp; g);\nDescription : La fonction std::shuffle mélange les éléments dans l’intervalle [first, last) en utilisant un générateur de nombres aléatoires uniforme g.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini. Le générateur de nombres aléatoires doit être conforme aux exigences d’un générateur de nombres aléatoires uniforme.\nstd::partition\ntemplate &lt;class ForwardIt, class UnaryPredicate&gt; ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate pred);\nDescription : La fonction std::partition regroupe les éléments pour lesquels le prédicat pred est vrai en tête de la séquence [first, last).\nType de retour : ForwardIt\nCas d’erreurs/Remarques : Retourne un itérateur pointant sur le premier élément pour lequel le prédicat est faux. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::stable_partition\ntemplate &lt;class ForwardIt, class UnaryPredicate&gt; ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate pred);\nDescription : La fonction std::stable_partition regroupe les éléments pour lesquels le prédicat pred est vrai en tête de la séquence [first, last) tout en conservant l’ordre relatif des éléments.\nType de retour : ForwardIt\nCas d’erreurs/Remarques : Retourne un itérateur pointant sur le premier élément pour lequel le prédicat est faux. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nstd::unique\ntemplate &lt;class ForwardIt&gt; ForwardIt unique(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class BinaryPredicate&gt; ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate eq);\nDescription : La fonction std::unique supprime les doublons consécutifs dans l’intervalle [first, last) en utilisant soit l’opérateur == par défaut, soit un prédicat binaire eq.\nType de retour : ForwardIt\nCas d’erreurs/Remarques : Retourne un itérateur pointant sur la nouvelle fin logique de l’intervalle. Assurez-vous que les itérateurs sont valides et que l’intervalle est correctement défini.\nFusion &amp; ensembles\nstd::merge\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::merge fusionne deux séquences triées [first1, last1) et [first2, last2) en une seule séquence triée, stockée à partir de dest. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d’erreurs/Remarques : Assurez-vous que les séquences d’entrée sont triées et que la destination a suffisamment d’espace pour contenir tous les éléments fusionnés.\nstd::inplace_merge\ntemplate &lt;class BidirectionalIt&gt; void inplace_merge(BidirectionalIt first, BidirectionalIt middle, BidirectionalIt last);\ntemplate &lt;class BidirectionalIt, class Compare&gt; void inplace_merge(BidirectionalIt first, BidirectionalIt middle, BidirectionalIt last, Compare comp);\nDescription : La fonction std::inplace_merge fusionne in-place deux sous-séquences contiguës triées [first, middle) et [middle, last) en une seule séquence triée. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : void\nCas d’erreurs/Remarques : Assurez-vous que les sous-séquences sont triées et que les itérateurs sont valides.\nstd::includes\ntemplate &lt;class InputIt1, class InputIt2&gt; bool includes(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2);\ntemplate &lt;class InputIt1, class InputIt2, class Compare&gt; bool includes(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp);\nDescription : La fonction std::includes vérifie si tous les éléments de la deuxième séquence triée [first2, last2) sont présents dans la première séquence triée [first1, last1). Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : bool\nCas d’erreurs/Remarques : Retourne true si la deuxième séquence est un sous-ensemble de la première, sinon false. Assurez-vous que les séquences sont triées.\nstd::set_union\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_union calcule l’union de deux ensembles triés [first1, last1) et [first2, last2) et stocke le résultat à partir de dest. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d’erreurs/Remarques : Assurez-vous que les séquences d’entrée sont triées et que la destination a suffisamment d’espace pour contenir tous les éléments de l’union.\nstd::set_intersection\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_intersection calcule l’intersection de deux ensembles triés [first1, last1) et [first2, last2) et stocke le résultat à partir de dest. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d’erreurs/Remarques : Assurez-vous que les séquences d’entrée sont triées et que la destination a suffisamment d’espace pour contenir tous les éléments de l’intersection.\nstd::set_difference\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_difference calcule la différence entre deux ensembles triés [first1, last1) et [first2, last2) (éléments présents dans le premier mais pas dans le second) et stocke le résultat à partir de dest. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d’erreurs/Remarques : Assurez-vous que les séquences d’entrée sont triées et que la destination a suffisamment d’espace pour contenir tous les éléments de la différence.\nstd::set_symmetric_difference\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_symmetric_difference calcule la différence symétrique entre deux ensembles triés [first1, last1) et [first2, last2) (éléments présents dans l’un ou l’autre ensemble, mais pas dans les deux) et stocke le résultat à partir de dest. Elle utilise soit l’opérateur &lt; par défaut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d’erreurs/Remarques : Assurez-vous que les séquences d’entrée sont triées et que la destination a suffisamment d’espace pour contenir tous les éléments de la différence symétrique."},"bibliothèque-fstream":{"slug":"bibliothèque-fstream","filePath":"bibliothèque fstream.md","title":"bibliothèque fstream","links":["bibliothèque","bibliothèque-standard-C++","flux","objet","méthode","STL","espace-de-noms","classe","classe-dérivée","bibliothèque-iostream","classe-de-base","opérateur","valeur","surchargé","fonction","bloc","destructeur","manipulateur-de-flux"],"tags":[],"content":"\nBibliothèque standard: &lt;fstream&gt;\n\n\nLa bibliothèque &lt;fstream&gt; fait partie de la bibliothèque standard C++.\nElle permet de manipuler des flux associés à des fichiers : lecture, écriture ou les deux, selon le type d’objet utilisé (std::ifstream, std::ofstream, std::fstream).\n\n\nInclusion\nPour utiliser les flux de fichiers :\n#include &lt;fstream&gt;\nCela rend accessibles les objets et [[classs]s] suivantes :\n\nstd::ifstream : lecture depuis un fichier\nstd::ofstream : écriture dans un fichier\nstd::fstream : lecture et écriture\n\nainsi que les méthodes associées comme open(), close(), is_open(), etc.\n\nEspace de nom\nComme toutes les bibliothèques de la STL, fstream appartient à l’espace de nom std.\nIl faut donc écrire :\n→ std::ifstream, std::ofstream, std::fstream\nOu importer l’espace de noms :\n→ using namespace std\n\n⚠️ L’import de using namespace std; reste déconseillé dans les fichiers d’en-tête.\n\n\nPrincipaux flux de fichier\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::ifstreamstd::istreamLecture depuis un fichier texte ou binairestd::ofstreamstd::ostreamÉcriture dans un fichier (écrase ou crée)std::fstreamstd::iostreamLecture et écriture dans un même fichier\n\nLes classes std::ifstream, std::ofstream, std::fstream sont des classe dérivées respectivement des flux de la bibliothèque iostream std::istream, std::ostream, std::iostream. Ces classes étendent les fonctionnalités de leurs classe de base respectives pour permettre la manipulation de fichiers.\nPour autant, il n’est pas nécessaire d’inclure &lt;iostream&gt; si on veut se servir exclusivement des flux de fichiers.\n\n\nModes d’ouverture\nLes flux de fstream acceptent plusieurs modificateurs de mode :\n\nstd::ios::in : lecture\nstd::ios::out : écriture\nstd::ios::app : ajout à la fin (append)\nstd::ios::trunc : tronque le fichier (supprime le contenu)\nstd::ios::binary : mode binaire (par défaut : texte)\n\n\nOn peut combiner plusieurs modes avec | , par exemple :\n\nstd::fstream f(&quot;data.txt&quot;, std::ios::in | std::ios::out);\n\nUtilisation des opérateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une chaîne (comme std::cout)\n&gt;&gt; pour extraction depuis une chaîne (comme std::cin)\n\n\nTrès utile pour formater des chaînes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL’opérateur &lt;&lt; insère une représentation textuelle d’une valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n’ajoute aucun espace ni retour à la ligne automatique : c’est au programmeur de les insérer si nécessaire.\nL’insertion est séquentielle et continue : tout ce qui est envoyé est écrit tel quel dans le flux.\n\nCet opérateur est surchargé pour les types standards (int, std::string, etc.), et peut l’être pour des classes personnalisées.\n\nLecture depuis un flux (&gt;&gt;)\nL’opérateur &gt;&gt; extrait des données d’un flux d’entrée (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caractères blancs (whitespace) en début de flux, puis lit jusqu’au prochain caractère blanc (espace, tabulation, saut de ligne).\nLa lecture s’interrompt dès qu’un séparateur est rencontré.\n\nPour lire une ligne complète, il faut utiliser std::getline(), car &gt;&gt; ne lit qu’un mot à la fois.\n\n\nExemple simple\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::ofstream fichier(&quot;donnees.txt&quot;);\n    fichier &lt;&lt; &quot;Nom: Alice\\n&quot;;\n    fichier.close();\n \n    std::ifstream lecture(&quot;donnees.txt&quot;);\n    std::string ligne;\n    while (std::getline(lecture, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n}\n\nPositionnement du curseur\nLes objets std::ifstream, std::ofstream et std::fstream permettent de manipuler le curseur de lecture ou d’écriture dans un fichier, grâce aux méthodes suivantes :\n\nseekg(pos) : déplace le curseur de lecture (g pour get) à la position pos\nseekp(pos) : déplace le curseur d’écriture (p pour put) à la position pos\ntellg() : retourne la position actuelle du curseur de lecture\ntellp() : retourne la position actuelle du curseur d’écriture\n\nOn peut aussi utiliser des déplacements relatifs :\nflux.seekg(offset, std::ios::beg);  // depuis le début\nflux.seekg(offset, std::ios::cur);  // depuis la position actuelle\nflux.seekg(offset, std::ios::end);  // depuis la fin du fichier\n\nCes fonctions sont utiles pour obtenir la taille d’un fichier, revenir au début, sauter des blocs de données, etc.\n\nÀ propos de offset et des points d’ancrage\nLes méthodes seekg() et seekp() acceptent un décalage (offset) exprimé en caractères (ou octets), ainsi qu’un point de départ (appelé ancrage) :\n\noffset : entier indiquant le nombre de caractères à déplacer\nstd::ios::beg : depuis le début du fichier\nstd::ios::cur : depuis la position actuelle\nstd::ios::end : depuis la fin du fichier\n\nExemples :\nfichier.seekg(0, std::ios::beg);    // aller au début\nfichier.seekg(5, std::ios::cur);    // avancer de 5 caractères\nfichier.seekg(-10, std::ios::end);  // reculer de 10 caractères depuis la fin\n\nCes manipulations sont utiles pour sauter des données, relire une section, ou calculer la taille totale du fichier.\n\nÀ propos de std::ios::beg, cur, end\nLes constantes std::ios::beg, std::ios::cur et std::ios::end sont des valeurs d’énumération appartenant à std::ios_base::seekdir.\nElles indiquent le point d’origine (ancrage) à partir duquel appliquer un décalage (offset) lors d’un repositionnement de curseur avec seekg() ou seekp() :\n\nstd::ios::beg → depuis le début du fichier\nstd::ios::cur → depuis la position actuelle\nstd::ios::end → depuis la fin du fichier\n\n\nCes constantes sont définies dans la bibliothèque &lt;ios&gt; (incluses automatiquement avec &lt;fstream&gt; ou &lt;iostream&gt;).\n\n\nPrécautions à prendre avec les flux de fichier\n1. Toujours vérifier que le fichier a bien été ouvert\nAvant toute lecture ou écriture, il est essentiel de s’assurer que l’ouverture a réussi :\nstd::ifstream fichier(&quot;data.txt&quot;);\nif (!fichier.is_open()) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d’ouvrir le fichier.&quot; &lt;&lt; std::endl;\n\treturn 1;\n}\n \n// ou bien\n \nstd::ifstream fichier(&quot;data.txt&quot;);\nif (!fichier)) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d’ouvrir le fichier.&quot; &lt;&lt; std::endl;\n\treturn 1;\n}\n \n\nMême chose avec std::ofstream ou std::fstream.\n\n2. Vérifier que le fichier n’est pas un dossier\nfstream ne permet pas directement de vérifier si le chemin est un répertoire.\nPour ce faire, il faut utiliser la bibliothèque &lt;sys/stat.h&gt; (POSIX) ou &lt;filesystem&gt; (C++17) :\nEn C++98/POSIX :\n#include &lt;sys/stat.h&gt;\n \nstruct stat s;\nif (stat(&quot;nom&quot;, &amp;s) == 0 &amp;&amp; S_ISDIR(s.st_mode)) {\n\tstd::cerr &lt;&lt; &quot;Erreur : c’est un dossier, pas un fichier.&quot; &lt;&lt; std::endl;\n}\n3. Prendre en compte les permissions du fichier\nSi le fichier est en lecture seule, un std::ofstream échouera à l’ouverture.\nstd::ofstream out(&quot;protected.txt&quot;);\nif (!out) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d’écrire dans le fichier (permissions ?)&quot; &lt;&lt; std::endl;\n}\n4. Penser à fermer explicitement (close())\nMême si le destructeur le fait automatiquement à la fin du bloc, il est bon usage de fermer manuellement si :\n\non rouvre le fichier ensuite\non veux s’assurer que les données sont bien écrites immédiatement\n\nfichier.close();\n5. Toujours tester l’état du flux après lecture\nSi une lecture échoue (fichier corrompu, fin de fichier…), il faut le détecter, avec la méthode fail() :\nint x;\nfichier &gt;&gt; x;\nif (fichier.fail()) {\n\tstd::cerr &lt;&lt; &quot;Erreur de lecture (mauvais type, fin prématurée...)&quot; &lt;&lt; std::endl;\n}\n\nRemarques\n\nIl est possible de tester si un fichier est ouvert avec is_open().\nToujours appeler close() à la fin pour libérer les ressources (ou laisser le destructeur le faire).\nPar défaut, les fichiers sont traités en mode texte (les fins de ligne peuvent être interprétées selon le système d’exploitation).\nfstream est compatible avec les manipulateur de flux comme std::setw, std::setprecision, etc.\n"},"bibliothèque-iostream":{"slug":"bibliothèque-iostream","filePath":"bibliothèque iostream.md","title":"bibliothèque iostream","links":["bibliothèque-standard-C++","flux","espace-de-noms","surchargé","classe","surcharge-d'opérateur","objet"],"tags":[],"content":"\nBibliothèque standard: `\n\n\nLa bibliothèque iostream est une composante fondamentale de la bibliothèque standard C++ .\nElle fournit les flux standards d’entrée et de sortie (std::cin, std::cout, etc.), permettant d’interagir avec l’utilisateur ou le système via des opérations de lecture/écriture textuelle.\n\n\nInclusion nécessaire\nPour accéder aux flux standards :\n#include &lt;iostream&gt;\nCela rend accessibles les objets suivants : std::cin, std::cout, std::cerr, std::clog, ainsi que les classes std::istream, std::ostream et les opérateurs &lt;&lt; et &gt;&gt;.\n\nEspace de nom\nLes flux cin, cout, etc., sont définis dans l’espace de nom std.\nIl faut les utiliser en les préfixant :\n→ std::cout, std::cin, etc\nOu importer l’espace de noms:\n→ using namespace std\n⚠️ L’import de using namespace std; est déconseillé dans les headers et les grands projets à cause des risques de conflits.\n\nPrincipaux flux fournis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::cinstd::istreamEntrée standard (lecture depuis le clavier)std::coutstd::ostreamSortie standard (affichage à l’écran)std::cerrstd::ostreamSortie d’erreur non tamponnée (affichage immédiat)std::clogstd::ostreamSortie d’erreur tamponnée (utilisée pour les logs)\n\nUtilisation des opérateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une chaîne (comme std::cout)\n&gt;&gt; pour extraction depuis une chaîne (comme std::cin)\n\n\nTrès utile pour formater des chaînes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL’opérateur &lt;&lt; insère une représentation textuelle d’une valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n’ajoute aucun espace ni retour à la ligne automatique : c’est au programmeur de les insérer si nécessaire.\nL’insertion est séquentielle et continue : tout ce qui est envoyé est écrit tel quel dans le flux.\n\nCet opérateur est surchargé pour les types standards (int, std::string, etc.), et peut l’être pour des classes personnalisées.\n\nLecture depuis un flux (&gt;&gt;)\nL’opérateur &gt;&gt; extrait des données d’un flux d’entrée (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caractères blancs (whitespace) en début de flux, puis lit jusqu’au prochain caractère blanc (espace, tabulation, saut de ligne).\nLa lecture s’interrompt dès qu’un séparateur est rencontré.\n\nPour lire une ligne complète, il faut utiliser std::getline(), car &gt;&gt; ne lit qu’un mot à la fois.\n\n\nExemple simple\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::string nom;\n    int age;\n \n    std::cout &lt;&lt; &quot;Nom : &quot;;\n    std::cin &gt;&gt; nom;\n \n    std::cout &lt;&lt; &quot;Âge : &quot;;\n    std::cin &gt;&gt; age;\n \n    std::clog &lt;&lt; &quot;Utilisateur connecté\\n&quot;;\n    std::cerr &lt;&lt; &quot;Aucune erreur détectée\\n&quot;;\n}\n\nRemarques\n\nLes flux de iostream sont tamponnés (sauf std::cerr), ce qui améliore les performances mais peut retarder l’affichage.\nIls sont automatiquement ouverts à l’exécution du programme.\niostream est extensible : vous pouvez faire de la surcharge d’opérateur&lt;&lt; et &gt;&gt; pour vos propres objets.\n"},"bibliothèque-numeric":{"slug":"bibliothèque-numeric","filePath":"bibliothèque numeric.md","title":"bibliothèque numeric","links":["bibliothèque","STL","C++","vecteur","liste","conteneur","itérateur","bibliothèque-algorithm","foncteur"],"tags":[],"content":"\nBibliothèque standard: &lt;numeric&gt;\n\n\nLa bibliothèque &lt;numeric&gt; fait partie de la STL en C++.\nElle fournit des algorithmes numériques génériques, principalement destinés à travailler sur des séquences de type vecteur vector, liste list, ou tout conteneur d’éléments numériques via des itérateurs.\nElle complète la bibliothèque algorithm]], mais n’en fait pas partie : &lt;numeric&gt; est un en-tête distinct, centré sur les accumulations, produits, sommes partielles, etc.\n\n\nInclude\nPour utiliser &lt;numeric&gt; :\n#include &lt;numeric&gt;\n\nFonctionnement\nLes fonctions de &lt;numeric&gt; sont génériques et travaillent uniquement sur des intervalles d’itérateurs.\nElles permettent d’appliquer rapidement des opérations mathématiques de type accumulation, somme partielle ou transformation.\n\nElles sont souvent utilisées en combinaison avec des foncteurs ou des fonctions personnalisées.\n\n\nPrincipales fonctions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionaccumulateFait une somme ou accumulationinner_productProduit scalaireadjacent_differenceDifférences successivespartial_sumSomme cumulative\n→ Pour plus de détail voir le bas de la page\n\nExemples\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::vector&lt;int&gt; v = {1, 2, 3, 4};\n \n    int sum = std::accumulate(v.begin(), v.end(), 0); // 10\n \n    int product = std::inner_product(v.begin(), v.end(), v.begin(), 0); // 1² + 2² + 3² + 4² = 30\n \n    std::vector&lt;int&gt; partial(v.size());\n    std::partial_sum(v.begin(), v.end(), partial.begin()); // {1, 3, 6, 10}\n \n    std::vector&lt;int&gt; diffs(v.size());\n    std::adjacent_difference(v.begin(), v.end(), diffs.begin()); // {1, 1, 1, 1}\n \n    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; &quot;, Product: &quot; &lt;&lt; product &lt;&lt; std::endl;\n}\n\nRemarques importantes\n\n&lt;numeric&gt; est distinct de &lt;algorithm&gt;, bien qu’ils partagent une logique basée sur les itérateurs.\nToutes les fonctions de &lt;numeric&gt; sont non destructrices : elles produisent leurs résultats sans modifier la séquence source.\nstd::accumulate est souvent utilisé pour des sommations ou produits simples, mais devient extrêmement puissant avec une fonction personnalisée (comme une concaténation, une combinaison logique, etc.).\nCes fonctions sont particulièrement utiles dans les cas de traitement de données numériques, calculs statistiques, ou algorithmes personnalisés.\n\n\nFonctions avec retour et paramètres\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionRetourParamètres principauxDescriptionstd::accumulateT(InputIt first, InputIt last, T init) (..., BinaryOp op)Calcule une somme ou une accumulation personnalisée sur une séquence.std::inner_productT(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init) (..., BinaryOp1, BinaryOp2)Calcule le produit scalaire ou une accumulation croisée personnalisée.std::partial_sumOutputIt(InputIt first, InputIt last, OutputIt dest) (..., BinaryOp op)Écrit les sommes cumulées successives dans dest.std::adjacent_differenceOutputIt(InputIt first, InputIt last, OutputIt dest) (..., BinaryOp op)Écrit dans dest les différences entre éléments consécutifs."},"bibliothèque-sstream":{"slug":"bibliothèque-sstream","filePath":"bibliothèque sstream.md","title":"bibliothèque sstream","links":["bibliothèque","bibliothèque-standard-C++","flux","objet","classe","méthode","espace-de-noms","bibliothèque-iostream","surchargé","manipulateur-de-flux"],"tags":[],"content":"\nBibliothèque standard: &lt;sstream&gt;\n\n\nLa bibliothèque sstream fait partie de la bibliothèque standard C++.\nElle permet de manipuler des flux en mémoire, grâce à des chaînes de caractères. Cela permet d’utiliser les opérateurs &lt;&lt; et &gt;&gt; comme avec cin et cout, mais en lisant ou écrivant dans une std::string.\n\n\nInclusion nécessaire\nPour utiliser les flux de chaînes :\n#include &lt;sstream&gt;\nCela rend accessibles les objets et classes suivantes :\n\nstd::stringstream : flux bidirectionnel (lecture/écriture)\nstd::istringstream : flux en lecture uniquement\nstd::ostringstream : flux en écriture uniquement\n\nainsi que les méthodes associées comme str(), clear(), seekg(), etc.\n\nEspace de nom\nComme les autres bibliothèques de la bibliothèque standard C++, sstream appartient à l’espace de nom std.\nIl faut donc écrire :\n→ std::stringstream, std::ostringstream, etc.\nOu importer l’espace de noms :\n→ using namespace std\n\n⚠️ L’import de using namespace std; reste déconseillé dans les fichiers d’en-tête.\n\n\nPrincipaux flux de chaînes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::istringstreamstd::istreamLecture depuis une chaînestd::ostringstreamstd::ostreamÉcriture vers une chaînestd::stringstreamstd::iostreamLecture et écriture dans une même chaîne de texte\n\nCes classes héritent des classes de la bibliothèque iostream et peuvent être utilisées de la même manière que cin ou cout.\n\n\nUtilisation des opérateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une chaîne (comme std::cout)\n&gt;&gt; pour extraction depuis une chaîne (comme std::cin)\n\n\nTrès utile pour formater des chaînes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL’opérateur &lt;&lt; insère une représentation textuelle d’une valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n’ajoute aucun espace ni retour à la ligne automatique : c’est au programmeur de les insérer si nécessaire.\nL’insertion est séquentielle et continue : tout ce qui est envoyé est écrit tel quel dans le flux.\n\nCet opérateur est surchargé pour les types standards (int, std::string, etc.), et peut l’être pour des classes personnalisées.\n\nLecture depuis un flux (&gt;&gt;)\nL’opérateur &gt;&gt; extrait des données d’un flux d’entrée (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caractères blancs (whitespace) en début de flux, puis lit jusqu’au prochain caractère blanc (espace, tabulation, saut de ligne).\nLa lecture s’interrompt dès qu’un séparateur est rencontré.\n\nPour lire une ligne complète, il faut utiliser std::getline(), car &gt;&gt; ne lit qu’un mot à la fois.\n\n\nExemple simple\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::stringstream ss;\n    ss &lt;&lt; &quot;42 3.14 Hello&quot;;\n \n    int a;\n    float b;\n    std::string c;\n \n    ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::cout &lt;&lt; &quot;int = &quot; &lt;&lt; a &lt;&lt; &quot;, float = &quot; &lt;&lt; b &lt;&lt; &quot;, string = &quot; &lt;&lt; c &lt;&lt; std::endl;\n}\n\nPrécautions à prendre\n\nToujours vérifier l’état du flux (fail(), eof()) après extraction.\nUtiliser clear() si on réutilise un même stringstream pour une autre opération.\nUtiliser str() pour récupérer ou définir le contenu de la chaîne associée.\n\nstd::ostringstream out;\nout &lt;&lt; 123;\nstd::string result = out.str(); // récupère la chaîne &quot;123&quot;\n\nRemarques\n\nTrès utile pour formater des chaînes sans utiliser sprintf.\nUtile aussi pour convertir une string en int ou float de manière sûre :\n\nstd::istringstream(&quot;42&quot;) &gt;&gt; myInt;\n\nCompatible avec les manipulateur de flux (std::setw, std::fixed, etc.)\n"},"bibliothèque-standard-C++":{"slug":"bibliothèque-standard-C++","filePath":"bibliothèque standard C++.md","title":"bibliothèque standard C++","links":["fonction","classe","type","C++","flux","espace-de-noms","STL","string"],"tags":[],"content":"\nNom anglais: C++ Standard Library\n\n\nLa bibliothèque standard C++ est un ensemble d’outils fournis avec le langage C++, regroupant des fonctions, des classes, des types et des structures utiles pour le développement.\nComparaison C/C++ : Le C a une bibliothèque standard plus limitée. En C++ la bibliothèque standard est plus riche, orientée objet, et largement template-based (basé sur des modèles génériques).\n\nContenu de la bibliothèque standard\nElle contient notamment :\n\nLes flux d’entrée/sortie : std::cout, std::cin, std::cerr (&lt;iostream&gt;)\nLes chaînes de caractères : std::string (&lt;string&gt;)\nLes conteneurs génériques : std::vector, std::map, std::set, etc. (&lt;vector&gt;, &lt;map&gt;, etc.)\nLes algorithmes : std::sort, std::find, std::count… (&lt;algorithm&gt;)\nLes outils mathématiques : std::pow, std::sqrt, etc. (&lt;cmath&gt;)\nLes types utilitaires : std::pair, std::tuple, std::optional…\nLes fonctions de gestion de caractères : std::toupper, std::tolower, etc. (&lt;cctype&gt;)\nLes fonctions de temps / date : std::chrono, std::time\n\nNamespace de la bibliothèque standard\n\nEn C++, tous les éléments de la bibliothèque standard sont définis dans l’espace de noms std (abréviation de standard). C’est une règle systématique.\n\nTous les composants standards comme :\n\ncout, cin, cerr\nstring, vector, map, set, pair\nsort, find, sqrt, toupper, endl\netc.\n\n… sont dans l’espace de noms std.\nIl faut donc les appeler comme ceci :\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\nstd::vector&lt;int&gt; liste;\nstd::sort(...);\nOu bien utiliser :\nusing namespace std;\nUtilisation\nPour utiliser un composant de la bibliothèque standard :\n\nInclure l’en-tête correspondant (ex. #include &lt;vector&gt;)\nPour l’espace de noms utiliser l’élément avec le préfixe std::, ou bien écrire using namespace std;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom = &quot;Alice&quot;;\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n    return 0;\n}\nSTL (Standard Template Library)\nLa STL est une partie spécifique de la bibliothèque standard, regroupant :\n\ndes conteneurs génériques (ex : std::vector)\ndes itérateurs\ndes algorithmes (ex : std::sort)\ndes foncteurs / lambdas\n\nElle repose fortement sur les templates, pour permettre une réutilisabilité maximale du code.\nFiches associees\n\nstring\n\n\nRésumé\n\n📌 La bibliothèque standard C++ fournit des outils essentiels prêts à l’emploi, couvrant les besoins courants (affichage, traitement de texte, calculs, conteneurs, algorithmes…).\nElle est organisée par modules, accessibles via les #include et l’espace de noms (namespace) std.\n"},"bibliothèque-standard":{"slug":"bibliothèque-standard","filePath":"bibliothèque standard.md","title":"bibliothèque standard","links":["C++","compilateur"],"tags":[],"content":"Qu’est-ce qu’une bibliothèque standard?\n\nUne bibliothèque standard en C++ est l’ensemble officiel de fonctionnalités (fonctions, classes, algorithmes, structures de données) fourni directement avec le langage.\nElle est normée, universelle, disponible par défaut avec tout compilateur C++, et permet de réaliser plein de tâches courantes sans devoir réinventer la roue.\n\nEn résumé\n\nC’est inclus automatiquement avec C++.\nOn y trouve tout ce qui est de base : affichage, calculs, structures de données, algorithmes, gestion de fichiers, etc.\nElle est gérée par le standard du C++ (ISO C++ Standard).\n\nExemples de composants de la bibliothèque standard\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModuleFonctionnalité principaleiostreamEntrées/sorties (std::cout, std::cin)vectorTableaux dynamiquesstringGestion des chaînes de caractèresmapTableaux associatifs (clé/valeur)algorithmFonctions prêtes à l’emploi (tri, recherche, etc.)memoryGestion fine de la mémoire dynamiquechronoGestion du temps et des durées\n🔎 Pourquoi utiliser la bibliothèque standard ?\n\nGain de temps énorme : pas besoin de recoder les fonctions basiques.\nSécurité : elle est largement testée et fiable.\nPortabilité : ton code fonctionne de la même manière sur tous les systèmes.\n\nImportant\n\nPour utiliser une fonctionnalité, il faut généralement :\n\nInclure le header correspondant (ex: #include &lt;vector&gt;)\nUtiliser l’espace de noms std:: (ex: std::vector&lt;int&gt;).\n\n\n\nRésumé ultra rapide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCe que c’estPourquoi c’est utileEnsemble d’outils de base du C++Tu n’as pas besoin de tout réécrireLivré avec ton compilateurAccessible immédiatementNorméMême comportement partout"},"bibliothèque":{"slug":"bibliothèque","filePath":"bibliothèque.md","title":"bibliothèque","links":["fonction","classe","C++","bibliothèque-standard-C++","bibliothèque-sstream","bibliothèque-fstream","bibliothèque-numeric","bibliothèque-algorithm"],"tags":[],"content":"\nNom anglais: library\n\n\nUne bibliothèque est un ensemble de fonctions, de classes ou d’outils regroupés dans un fichier séparé, que l’on peut réutiliser dans plusieurs programmes.\nElle permet d’organiser et de partager du code sans le réécrire à chaque fois.\nComparaison C/C++ : En C et en C++, les bibliothèques sont très utilisées, via les fichiers d’en-tête (.h, .hpp) et les fichiers compilés (.a, .so, .lib, .dll, etc.).\n\n\nTypes de bibliothèques\n\nBibliothèque standard : livrée avec le langage (ex : std::cout, std::string, std::vector, etc.) - voir bibliothèque standard C++\nBibliothèque externe : créée par des tiers (ex : SFML, Boost, Qt…)\nBibliothèque personnelle : écrite par le développeur pour organiser son propre projet\n\n→ Voir la fiche dédiée : bibliothèque standard C++\n\nUtilisation\nPour utiliser une bibliothèque :\n\nOn inclut un fichier d’en-tête (ex: #include &lt;iostream&gt;)\nOn compile en liant le fichier binaire correspondant (automatique pour la bibliothèque standard)\n\n\nExemple\n#include &lt;cmath&gt; // bibliothèque standard mathématique\n \ndouble racine = std::sqrt(9.0);\n\nVoir aussi\n→ bibliothèque standard C++, bibliothèque sstream\n→ bibliothèque fstream, bibliothèque numeric, bibliothèque algorithm"},"bloc":{"slug":"bloc","filePath":"bloc.md","title":"bloc","links":["variable","objet","fonction","durée-de-vie-des-objets"],"tags":[],"content":"\nNom anglais: block\n\n\nUn bloc est une portion de code délimitée par des accolades {}, qui définit une portée locale (scope).  Les variables et objets déclarées à l’intérieur du bloc n’existent que pendant son exécution.\nComparaison C/C++ : cette notion est identique dans les deux langages.\n\n\nExemple\nLe code situé entre les accolades constitue un bloc.\n{\n    int x = 42;\n}\n\nUtilisations courantes\n\nCorps de fonction\nBoucles (for, while)\nConditions (if, else)\nDélimitation volontaire de portée temporaire\n\n\nDurée de vie dans un bloc\nUn bloc {} crée une portée locale, dans laquelle on peut déclarer des variables qui seront automatiquement détruites à sa fermeture.\n→ Voir la fiche dédiée : durée de vie des objets\n\nVoir aussi\n→ variable, objet, durée de vie des objets"},"cache":{"slug":"cache","filePath":"cache.md","title":"cache","links":["C++","vecteur","liste"],"tags":[],"content":"\nNom anglais: cache (CPU cache)\n\n\nLe cache est une mémoire rapide située à l’intérieur ou au plus proche du processeur (CPU).\nSon rôle est de stocker temporairement les données et instructions les plus récemment utilisées ou les plus souvent demandées, afin d’accélérer leur accès.\n\n\nOrganisation hiérarchique\nLe cache est généralement organisé en plusieurs niveaux, chacun étant plus grand mais plus lent que le précédent :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNiveauNomTaille typiqueVitesseLocalisationL1Cache L116 à 128 KoTrès rapidedans chaque cœurL2Cache L2256 Ko à 1 MoRapidedans chaque cœurL3Cache L32 à 64 MoMoins rapidepartagé entre cœursRAMMémoire principalePlusieurs GoBeaucoup plus lenthors CPU (sur la carte mère)\n\nFonctionnement\nLorsqu’un programme accède à une donnée :\n\nLe CPU cherche d’abord dans le cache (L1 → L2 → L3).\nSi la donnée est présente (cache hit), elle est utilisée immédiatement.\nSinon (cache miss), elle est chargée depuis la RAM (beaucoup plus lent).\n\nLe cache fonctionne souvent par blocs contigus (appelés lignes de cache), ce qui favorise les accès séquentiels.\n\nImportance en C++\nLe comportement d’un programme C++peut être grandement influencé par le cache :\n\nles vecteurs std::vector utilise de la mémoire contiguë, ce qui favorise les accès séquentiels efficaces (cache-friendly).\nles listes std::list utilise des pointeurs dispersés en mémoire, ce qui entraîne de nombreux cache misses (moins performant).\nUn parcours linéaire sur un tableau est souvent beaucoup plus rapide qu’un accès aléatoire sur une liste, même si la complexité algorithmique est équivalente.\n\n\nExemple\nint arr[100000];\nfor (int i = 0; i &lt; 100000; ++i)\n    arr[i] += 1;\nCe code bénéficie du cache car les éléments sont lus de manière contiguë. Le CPU charge plusieurs éléments à la fois grâce aux lignes de cache.\nEn revanche, avec des accès aléatoires ou des listes chaînées, le cache est beaucoup moins efficace."},"cast":{"slug":"cast","filePath":"cast.md","title":"cast","links":["C++98","C++","compilation","pointeur","classe","RTTI","polymorphisme","compilateur","référence","classe-dérivée","exception","méthode","classe-de-base","objet","méthode-virtuelle","héritage","encapsulation"],"tags":[],"content":"\nNom anglais : type casting\n\n\nEn C++98, le cast permet de convertir une expression d’un type vers un autre.\nLe langage hérite de la syntaxe (Type) du C, mais introduit quatre opérateurs spécifiques :\nstatic_cast, dynamic_cast, reinterpret_cast, const_cast\nIls sont plus sécurisés, lisibles et adaptés aux intentions.\nComparaison C/C++ : En C, tous les casts passent par une conversion brute non vérifiée (Type), ce qui peut masquer des erreurs. En C++, les casts sont explicites, typés, et souvent vérifiés à la compilation ou à l’exécution selon le type de cast.\n\n\nPourquoi caster en C++\n\nPour convertir une valeur d’un type vers un autre\nPour interpréter ou manipuler un pointeur dans une hiérarchie de classes\nPour supprimer un const de manière contrôlée\nPour faire une conversion polymorphe sécurisée grâce au RTTI (voir polymorphisme)\n\n\nLe cast en style C\nfloat f = 3.14f;\nint i = (int)f;\n\nSimple et rapide, mais :\nDangereux, car il bypasse toutes les vérifications\nAmbigu : le compilateur ne peut pas distinguer l’intention réelle du programmeur.\n\nC’est pourquoi le C++ introduit 4 formes de cast spécialisées.\n\nstatic_cast\n\nConversion explicite, vérifiée à la compilation.\n\nSert à effectuer des conversions sûres : entre types numériques compatibles, entre types d’une même hiérarchie sans RTTI, ou entre pointeurs vers types compatibles.\nint i = static_cast&lt;int&gt;(3.14);           // OK\nBase* b = static_cast&lt;Base*&gt;(derivedPtr); // OK si dérivée de Base\n\nVérifications à la compilation\nPas de vérification à l’exécution → attention aux conversions incorrectes\n\n\nUtilisation : préférée pour la majorité des conversions non polymorphes (valeurs simples, héritage connu).\n\n\nreinterpret_cast\n\nConversion bas niveau, non vérifiée.\n\nPermet d’interpréter les bits d’un pointeur ou d’un type comme un autre type totalement incompatible.\nint* p = reinterpret_cast&lt;int*&gt;(0xDEADBEEF); // cast d’adresse brut\n\nPuissant\nTrès risqué → peut casser le programme ou provoquer un comportement indéfini\n\n\nUtilisation : réservé à des cas très particuliers (interopérabilité bas niveau, I/O mémoire brute, etc.)\n\n\nconst_cast\n\nAjoute ou retire un const ou volatile.\n\nPermet de supprimer le const pour appeler une fonction non-const ou modifier temporairement une valeur\nconst int* p = &amp;x;\nint* q = const_cast&lt;int*&gt;(p);\n\nUtilisé pour rétablir la mutabilité\nNe jamais l’utiliser sur un objet qui a été déclaré const, sous peine de comportement indéfini\n\n\nUtilisation : manipulation contrôlée, souvent en interne (appel d’API non const, etc.)\n\n\ndynamic_cast\n\nConversion descendante (downcast) sécurisée grâce au RTTI.\n\nPermet de convertir un pointeur ou une référence vers une classe dérivée dans une hiérarchie polymorphe.\nBase* b = new Derived();\nDerived* d = dynamic_cast&lt;Derived*&gt;(b);\n \nif (d) d-&gt;fonctionSpecifique(); // OK si le cast a réussi\n\nVérifie dynamiquement si le cast est valide\nRetourne nullptr (ou lève une exception  std::bad_cast en cas de référence) si la conversion échoue\n\n\nUtilisation : nécessaire uniquement avec le polymorphisme (au moins une méthode virtual dans la classe de base).\n\n\nQu’est-ce que le RTTI ?\n\nRTTI : Run-Time Type Information (informations de type à l’exécution)\n\nRTTI est un mécanisme du C++ qui permet de connaître le type réel d’un objet à l’exécution.\nIl est nécessaire pour dynamic_cast et typeid. Il s’appuie sur la table virtuelle (vtable) générée pour les classes contenant au moins une méthode virtuelle.\n\nSi le RTTI est désactivé (-fno-rtti), dynamic_cast et typeid ne sont plus disponibles.\n\n\nComparaison\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCastUsage principalVérificationDanger principalstatic_castConversion simple entre types compatiblesCompilationerreurs silencieusesreinterpret_castConversion brute (pointeurs, données)AucuneUB, non portableconst_castAjout/retrait de constCompilationmodifier un vrai objet constdynamic_castCast polymorphe (héritage)Exécutionnécessite RTTI, sinon nullptr\n\nVoir aussi\n→ pointeur, référence\n→ classe, héritage, méthode virtuelle, encapsulation"},"cin":{"slug":"cin","filePath":"cin.md","title":"cin","links":["Nom-pleinement-qualifié","bibliothèque-standard-C++","bibliothèque-iostream","espace-de-noms","flux","C++","objet","opérateur","surchargé"],"tags":[],"content":"\nNom pleinement qualifié: std::cin\n\n\nstd::cin est un objet de la bibliothèque standard C++ qui permet de lire des données depuis l’entrée standard (généralement le clavier).\nIl fait partie de la bibliothèque iostream et appartient à l’espace de noms std.\nOn l’utilise avec l’opérateur &gt;&gt; (appelé opérateur d’extraction) pour extraire des valeurs tapées par l’utilisateur dans le flux d’entrée standard.\nComparaison C/C++ : En C, on utilise scanf() ou fgets(). En C++, on utilise std::cin, un objet de type std::istream, avec l’opérateur &gt;&gt;.\n\nFonctionnement de base\nstd::cin &gt;&gt; nom;\n\nCela attend une saisie clavier et stocke la valeur dans la variable nom.\nL’opérateur &gt;&gt; signifie ici “extrait depuis le flux d’entrée”.\n\nLire plusieurs éléments\nOn peut enchaîner plusieurs lectures sur une même ligne :\nstd::cin &gt;&gt; nom &gt;&gt; age;\n\nL’utilisateur doit saisir deux valeurs, séparées par des espaces.\nChaque &gt;&gt; extrait une valeur dans une variable, dans l’ordre.\n\nTypes acceptés\nstd::cin fonctionne avec les types de base :\n\nint, float, double\nchar, std::string\net d’autres types pour lesquels l’opérateur &gt;&gt; est surchargé\n\n\nAttention : std::cin s’arrête à l’espace lorsqu’on lit une std::string. Pour lire une ligne complète, on utilise std::getline().\n\nExemple complet\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom;\n    int age;\n \n    std::cout &lt;&lt; &quot;Entrez votre nom : &quot;;\n    std::cin &gt;&gt; nom;\n \n    std::cout &lt;&lt; &quot;Entrez votre âge : &quot;;\n    std::cin &gt;&gt; age;\n \n    std::cout &lt;&lt; &quot;Bonjour &quot; &lt;&lt; nom &lt;&lt; &quot;, vous avez &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl;\n    return 0;\n}\nRésumé\n\nstd::cin permet de lire des valeurs depuis l’entrée standard, enchaînées avec l’opérateur &gt;&gt;.\nChaque &gt;&gt; extrait une valeur depuis le flux dans une variable. C’est un mécanisme simple, direct, et parfaitement intégré à la syntaxe C++.\n"},"classe-de-base":{"slug":"classe-de-base","filePath":"classe de base.md","title":"classe de base","links":["classe","attribut","méthode","héritage","classe-dérivée","objet"],"tags":[],"content":"\nNom anglais: parent class / base class\n\n\nUne classe parente (ou classe de base) est une classe dont les caractéristiques (ses attributs et ses méthodes) peuvent être héritées (on appelle ça l’héritage) par d’autres classes appelées classe dérivées.\nComparaison avec le C: En C, il n’existe pas d’héritage natif. En C++, une classe parente permet de créer une base commune pour plusieurs objets.\n\nRôle de la classe parente\nLa classe parente permet :\n\nde regrouper des comportements communs à plusieurs classes,\nde réduire la duplication de code,\nde organiser le programme sous forme d’une hiérarchie logique.\n\nElle sert de fondation pour ses classe dérivées.\nDéfinir une classe parente\nToute classe normale peut devenir une classe parente si une autre classe hérite d’elle :\nclass Vehicule\n{\npublic:\n    void demarrer();\n};\nIci, Vehicule peut devenir une classe parente.\nExemple\nAvec l’héritage :\nclass Voiture : public Vehicule\n{\n    // Voiture hérite de Vehicule\n};\nVehicule est la classe parente de Voiture."},"classe-dérivée":{"slug":"classe-dérivée","filePath":"classe dérivée.md","title":"classe dérivée","links":["classe","classe-de-base","héritage","attribut","méthode","C++","surcharge","publique","protégé","privé"],"tags":[],"content":"\nNom anglais: derived class / child class\n\n\nUne classe dérivée (ou classe enfant) est une classe qui hérite d’une classe de base (ou classe parent) : on parle d’héritage. Elle reprend les attributs et méthodes de la classe de base et peut ajouter ses propres éléments ou modifier ceux qu’elle hérite.\nComparaison avec le C: Le C ne propose pas d’héritage. En C++, une classe dérivée permet de spécialiser une classe de base existante.\n\n\nRôle de la classe dérivée\nLa classe enfant :\n\nréutilise le code de la classe de base,\npeut ajouter de nouveaux comportements,\npeut redéfinir (on parle de surcharge ou override) certaines méthodes si nécessaire.\n\nDéfinir une classe dérivée\nOn utilise l’opérateur : et un niveau d’accès (publique, protégé, ou privé) :\nclass Voiture : public Vehicule\n{\npublic:\n    void ouvrirCoffre();\n};\nVoiture hérite de tout ce qui est publique ou protégé dans Vehicule.\nExemple\nVoiture v;\nv.demarrer();    // hérité de Vehicule\nv.ouvrirCoffre(); // spécifique à Voiture\nVoiture est une classe dérivée (ou classe enfant) de Vehicule."},"classe-imbriquée":{"slug":"classe-imbriquée","filePath":"classe imbriquée.md","title":"classe imbriquée","links":["classe","type-interne","C++","déclaration-anticipée"],"tags":[],"content":"\nNom anglais: nested class\n\n\nUne classe imbriquée est une classe définie à l’intérieur d’une autre classe. C’est un type interne particulier, utilisé pour structurer le code en hiérarchisant les éléments étroitement liés.\nComparaison C/C++ : Le C ne permet pas d’imbriquer des struct ou des typedef aussi librement. En C++, une classe imbriquée est un outil puissant pour l’organisation interne.\n\nPourquoi utiliser une classe imbriquée\nLes classes imbriquées permettent :\n\nde grouper ensemble des concepts fortement liés,\nde cacher certains détails d’implémentation,\nde limiter la portée d’une classe auxiliaire au sein d’une seule classe.\n\nDéfinir une classe imbriquée\nOn définit une classe à l’intérieur d’une autre :\nclass Voiture\n{\npublic:\n    class Moteur // classe imbriquée\n    {\n    public:\n        void demarrer();\n    };\n \nprivate:\n    Moteur moteur;\n};\nIci, Moteur est une classe imbriquée dans Voiture.\n\nNote : Parfois, pour utiliser une classe imbriquée proprement, on utilise une déclaration anticipée.\n\nAccéder à une classe imbriquée\nVoiture::Moteur m;\nm.demarrer();\nOn utilise la syntaxe NomDeLaClasseParent::NomClasseImbriquée.\n\nVeux-tu aussi une mini-fiche après sur forward declaration (parce que parfois, pour utiliser des classes imbriquées proprement, on utilise aussi des déclarations anticipées) ? 🚀📚\n(Si tu veux un Obsidian vraiment complet !)"},"classe":{"slug":"classe","filePath":"classe.md","title":"classe","links":["objet","attribut","méthode","structure","fonction","membre","C++","classe","publique","privé","protégé","polymorphisme","héritage","convention-de-nommage","UpperCamelCase","STL","lowerCamelCase","bibliothèque","organisation-des-fichiers-d'une-classe","forme-canonique","constructeur-par-défaut","constructeur-par-copie","opérateur-d’affectation-par-copie","destructeur","classe-dérivée","classe-de-base","virtuel","C++11","membre-statique","fonction-statique","attribut-statique","exception","bloc"],"tags":[],"content":"\nNom anglais: class\n\n\nUne classe est un modèle ou un plan qui définit la structure et le comportement d’objets. Elle regroupe des attributs (données) et des méthodes (fonctions) qui décrivent ce que les objets de cette classe savent et savent faire.\nUne classe est donc un un type défini par le programmeur, structurant des données (attribut) et des comportements (méthode).\nComparaison C/C++: Une classe ressemble à une structure (struct) en C, mais avec en plus la possibilité de contenir des fonctions et de contrôler l’accès aux membres avec private, public, protected.\n\n\nClasses et objets\nLa classe sert de plan pour créer des objets. Tous les objets créés à partir d’une même classe partageront la même structure, mais chacun aura ses propres données (ses propres attributs). L’objet est donc une itération particulière d’une classe.\n\nComparaison C/C++ : En C, on utilise une structure struct pour définir un nouveau type, puis on déclare des variables de ce type.\nEn C++, une classe joue un rôle équivalent : elle définit un type structuré, et un objet est une variable (ou instance) de ce type.\n\nPar exemple, en C, on peut définir une structure Voiture, en faire un type avec typedef, puis déclarer une variable ma_voiture de ce type.\nDe manière équivalente, en C++, on peut définir une classe Voiture, puis déclarer un objet Voiture maVoiture qui est une instance de cette classe.\n\nClasses et membres\nUne classe contient :\n\ndes attributs (des variables) : ils représentent l’état des objets\ndes méthodes (des fonctions) : ils définissent le comportement des objets\n\n\nParties publique, privée et protégée\nUne classe peut contrôler l’accès à ses membres en les regroupant sous trois sections : publique (public), privée (private), et protégée (protected).\n\nLes membres public sont accessibles depuis l’extérieur de la classe.\nLes membres private ne sont accessibles que depuis l’intérieur de la classe.\nLes membres protected sont comme private, mais accessibles également aux classes dérivées (voir polymorphisme et héritage).\n\nUne classe n’a pas nécessairement besoin d’avoir les trois parties, elle peut n’avoir par exemple qu’une partie publique, ou seulement une publique et une privée, en fonction de ses besoins.\n\nSi aucune partie public, protectedou private n’est déclarée, par défaut tous les membres de la classe seront privés.\n\n→ Voir les fiches dédiées : publique, privé, protégé\n\nDéfinition d’une classe\nLa déclaration d’une classe utilise le mot-clé class, puis son nom, puis les accolades {} entre lesquelles seront définis les attributs et les méthodes :\nclass NomDeLaClasse\n{\n\tprivate:\n\t    // attributs privés\n\t    // méthodes privées\n\tprotected:\n\t\t// attributs protégés\n\t\t// méthodes protégées\n\tpublic:\n\t\t// attributs publics\n\t\t// méthodes publiques\n};\n\nConvention de nommage\nLes classes utilisent généralement la convention de nommage UpperCamelCase : les mots composants le nom de la classe sont collés, commencent par une majuscule, y compris le premier mot. Exemples :\n\nMaClasse\nCharacter\nTwoHandedAxe\n\n\nRemarque : dans la STL, les types comme std::vector, std::string, etc., sont en lowerCamelCase, car ce sont des modèles de classe dans une bibliothèque très ancienne, avant la généralisation d’UpperCamelCase pour les types définis par l’utilisateur.\n\n\nOrganisation des fichiers\nEn C++, chaque classe doit être répartie dans deux fichiers distincts :\n\nun fichier d’en-tête (.hpp) contenant la déclaration de la classe (attributs et prototypes des méthodes, sans leur code),\nun fichier d’implémentation (.cpp) contenant la définition des méthodes (c’est-à-dire leur corps).\n\nCette séparation favorise la clarté, la compilation efficace et la réutilisabilité.\nÀ 42, cette organisation est obligatoire, et doit inclure les quatre éléments de la forme canonique :  le constructeur par défaut, le constructeur par copie, l’opérateur d’affectation, et le destructeur.\n→ Voir la fiche dédiée: organisation des fichiers d’une classe\n\nUtiliser une classe\nUne fois la classe définie, on peut créer des objets (instances) de cette classe :\nMaClasse objet1;\nMaClasse objet2;\nChaque objet aura ses propres attributs, mais pourra utiliser les mêmes méthodes.\n\nExemple\nVoici une définition simple de classe :\nclass Voiture\n{\nprivate:\n    string couleur;\n    string marque;\n    int vitesse;\n \npublic:\n    void accelerer();\n    void freiner();\n};\nLa classe Voiture contient :\n\ndes attributs (couleur, marque, vitesse)\ndes méthodes (accelerer, freiner)\n\nOn pourra ensuite créer plusieurs objets de type Voiture, chacun ayant ses propres caractéristiques.\n\nForme canonique\nEn C++, la forme canonique (ou canonical form) est une convention de conception qui consiste à fournir les quatre méthodes fondamentales d’une classe.\nElle est particulièrement recommandée lorsqu’une classe gère des ressources, ou lorsqu’on souhaite maîtriser explicitement les opérations de copie, d’affectation et de destruction.\nCes quatre méthodes sont :\n\nle constructeur par défaut\nle constructeur par copie\nl’opérateur d’affectation par copie\nle destructeur\n\n\nÀ 42, la forme canonique est souvent exigée pour garantir un comportement prévisible et propre des objets, même si certains de ces membres ne sont pas strictement nécessaires à chaque fois.\n\n→ Voir la fiche dédiée : forme canonique\n\nPolymorphisme\nLe polymorphisme permet de manipuler plusieurs types d’objets différents comme s’ils étaient du même type, en s’appuyant sur une classe parente commune.\nConcrètement, on peut appeler la même méthode sur des objets appartenant à des classe dérivées différentes, du moment qu’ils héritent tous d’une même classe de base.\nCe mécanisme repose sur :\n\nl’héritage entre classes (une classe dérivée hérite d’une classe de base)\nl’utilisation de méthodes virtuelles (virtual), éventuellement redéfinies avec override (à partir du C++11 uniquement).\n\nCela permet, par exemple, d’écrire des fonctions qui traitent n’importe quel type dérivé d’une même classe de base.\n→ Voir la fiche dédiée : polymorphisme\n\nFonctions et attributs statiques\nUne classe peut posséder des membre statiques : des fonctions ou des attributs qui sont partagés par toutes les instances de la classe.\n\nUne fonction statique peut être appelée sans créer d’objet.\nUn attribut statique est commun à tous les objets (valeur partagée).\n\n→ Voir la fiche dédiée : membre statique\n\nExceptions\nLes classes peuvent être utilisées pour lancer ou attraper des exceptions en C++, via les blocs try, throw, catch.\nIl est fréquent de créer des classes d’exception personnalisées pour décrire des erreurs spécifiques à un contexte.\n→ Voir la fiche dédiée : exception"},"code-source":{"slug":"code-source","filePath":"code source.md","title":"code source","links":["C++","syntaxe","langage-compilé","langage-interprété","compilateur","interpréteur"],"tags":[],"content":"Qu’est-ce que le code source?\n\nLe code source est le texte écrit par un programmeur dans un langage de programmation (comme C++, Python, Java).\nCe texte suit une certaine syntaxe et décrit ce que doit faire un programme. Avant d’être exécutable, le code source doit souvent être compilé (on parle alors d’un langage compilé) ou interprété (on part d’un langage interprété).\n\nEn résumé\n\nC’est le “plan” d’un programme.\nC’est lisible et modifiable par un humain.\nIl est écrit dans des fichiers .cpp, .py, .java, etc.\nLe compilateur ou l’interpréteur transforme ce code pour l’ordinateur.\n\nExemples de code source\n#include &lt;iostream&gt;\n \nint main() {\n    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;\n    return 0;\n}\nÀ retenir\n\nLe code source est indispensable : sans lui, pas de programme.\nIl doit respecter les règles du langage choisi (syntaxe).\nC’est ce que tu écris, modifies, améliores pendant le développement.\n"},"compilateur":{"slug":"compilateur","filePath":"compilateur.md","title":"compilateur","links":["code-source","C++","fichier-binaire","compilation","GNU"],"tags":[],"content":"Qu’est-ce qu’un compilateur?\n\nUn compilateur est un programme qui traduit un code sourceécrit dans un langage de programmation (comme C++) en un fichier exécutable (le fichier binaire) que l’ordinateur peut directement comprendre et exécuter (on appelle ça la compilation).\nLe compilateur analyse tout le code, vérifie les erreurs, et produit un fichier binaire optimisé pour être rapide à l’exécution.\n\nEn résumé\n\nEntrée : fichier .cpp (le code source).\nTraitement : analyse, optimisation, traduction vers du langage machine.\nSortie : fichier exécutable (le fichier binaire).\n\nExemple de compilateurs C++\n\ng++ → Compilateur C++ (GNU)\nclang++ → Compilateur C++ basé sur LLVM\nMSVC → Compilateur C++ de Microsoft\n"},"compilation":{"slug":"compilation","filePath":"compilation.md","title":"compilation","links":["code-source","C++","fichier-binaire","compilateur","syntaxe","GNU","terminal"],"tags":[],"content":"Qu’est-ce que la compilation?\n\nLa compilation est le processus de traduction d’un code sourceécrit dans un langage de programmation (comme C++) en un fichier binaireque l’ordinateur peut exécuter directement.\n\nCe travail est effectué par un compilateur, qui transforme tout le programme d’un seul coup, en vérifiant aussi s’il contient des erreurs de syntaxe.\nCompiler du C++\nPour compiler du C++, il faut utiliser un compilateur comme g++ (GNU Compiler Collection pour C++): On lui donne un fichier source .cpp, et il crée un exécutable (le fichier binaire).\nCommande de base\nPour compiler\nCommande à saisir dans un terminal:\ng++ mon_programme.cpp -o mon_programme\n\ng++ : lance le compilateur C++.\nmon_programme.cpp : le fichier source.\n-o mon_programme : option pour nommer l’exécutable (le fichier binaire, par exemple: mon_programme).\n\nPour exécuter\nCommande à saisir dans un terminal:\n./mon_programme\nAvec plusieurs fichiers\nS’il y a plusieurs fichiers, il faut les compiler ensemble avec cette commande à saisir dans un terminal:\ng++ src/main.cpp src/utils.cpp -Iinclude -o build/mon_programme\n\n-Iinclude : indique où trouver tes fichiers d’en-tête .hpp (appelés  headers).\n"},"constructeur-par-copie":{"slug":"constructeur-par-copie","filePath":"constructeur par copie.md","title":"constructeur par copie","links":["méthode","objet","forme-canonique","fonction","référence","classe","attribut","prototype"],"tags":[],"content":"\nNom anglais: copy constructor\n\n\nLe constructeur par copie est une méthode spéciale qui permet de créer un nouvel objet en copiant un autre objet existant.\nIl est appelé automatiquement dans certaines situations, et fait partie de la forme canonique exigée à 42.\n\nQuand est-il utilisé ?\n\n\nLorsqu’on crée un objet à partir d’un autre :\nmaClasse a;    // appelle le constructeur par défaut\nmaClasse b(a); // appelle le constructeur par copie\n\n\nLorsqu’on passe un objet par valeur à une fonction :\nvoid f(maClasse x); // x est une copie de l’objet passé\n\n\nSyntaxe\nLe constructeur par copie est une méthode spéciale qui prend en paramètre une référence constante à un objet de la même classe.\nLa fonction contient :\n\nle nomDeLaFonction (obligatoirement le même nom que la classe)\ndes parenthèses () contenant un seul argument :\n\nune référence (&amp;) à un objet de même type\nprécédée du mot-clé const pour garantir qu’il ne sera pas modifié (référence constante)\n\n\ndeux points : pour introduire la liste d’initialisation\nune liste d’initialisation avec pour chaque attribut à copier :\n\nl’attribut\ndes parenthèses () contenant l’attribut de l’objet source à copier (souvent nommé other)\nune virgule , pour séparer chaque attribut initialisé\n\n\ndes accolades {} contenant le corps de la fonction (qui peut être vide ou contenir une logique de copie plus complexe)\n\nComme pour toute méthode d’une classe, le .hpp doit contenir le prototype, et le .cpp doit contenir l’implémentation en elle-même.\nExemple\nExemple de constructeur par copie pour une classe nommée maClasse et pour laquelle je vais copier deux attributs :\nDans le .hpp :\n→ On écrit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(const maClasse&amp; other);\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n→ On écrit l’implémentation :\nmaClasse::maClasse(const maClasse&amp; other)\n\t: _attribut1(other._attribut1)\n\t, _attribut2(other._attribut2)\n{\n\t// corps de la fonction éventuellement vide\n}\nOn peut aussi copier les valeurs dans le corps de la fonction (mais c’est moins optimal) :\nmaClasse::maClasse(const maClasse&amp; other)\n{\n\t_attribut1 = other._attribut1;\n\t_attribut2 = other._attribut2;\n}\nPourquoi l’écrire soi-même ?\nLe compilateur génère automatiquement un constructeur par copie par défaut.\nMais il effectue une copie membre à membre (shallow copy) qui peut poser problème si :\n\nla classe gère de la mémoire dynamique\nelle contient des pointeurs\nelle utilise des ressources système (fichiers, sockets…)\n\nIl faut alors écrire un constructeur par copie personnalisé pour éviter les fuites, les partages non souhaités ou les doubles libérations.\nDe plus, le constructeur par copie est obligatoire dans la forme canonique.\nRésumé\n\nLe constructeur par copie permet de créer un objet en copiant un autre.\nIl est appelé automatiquement dans de nombreuses situations et doit être défini manuellement si la classe gère des ressources sensibles.\nIl est obligatoire dans la forme canonique à 42.\n"},"constructeur-par-défaut":{"slug":"constructeur-par-défaut","filePath":"constructeur par défaut.md","title":"constructeur par défaut","links":["méthode","classe","objet","forme-canonique","attribut","fonction","prototype","constructeur","compilateur"],"tags":[],"content":"\nNom anglais: default constructor\n\n\nLe constructeur par défaut est une méthode spéciale d’une classe qui est appelée automatiquement lors de la création d’un objet sans argument.\nIl fait partie de la forme canonique exigée à 42.\n\nQuand est-il utilisé ?\n\n\nLorsqu’on déclare un objet sans fournir de paramètre :\nmaClasse a; // appelle le constructeur par défaut\n\n\nLorsqu’on crée un tableau d’objets ou un objet membre dans une autre classe sans initialisation explicite.\n\n\nSyntaxe\nLe constructeur par défaut est une méthode sans paramètre, qui peut initialiser les attributs de l’objet.\nLa fonction contient :\n\nle nomDeLaFonction (obligatoirement le même nom que la classe)\ndes parenthèses vides (), car il ne prend aucun argument\ndeux points : pour introduire la liste d’initialisation (facultative mais recommandée)\nune liste d’initialisation avec pour chaque attribut à initialiser :\n\nl’attribut\ndes parenthèses () contenant une valeur initiale\nune virgule , pour séparer chaque attribut initialisé\n\n\ndes accolades {} contenant le corps de la fonction (qui peut être vide ou contenir une logique par défaut)\n\nComme pour toute méthode d’une classe, le .hpp doit contenir le prototype, et le .cpp doit contenir l’implémentation en elle-même.\nExemple\nExemple de constructeur par défaut pour une classe nommée maClasse et pour laquelle je vais initialiser deux attributs :\nDans le .hpp :\n→ On écrit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse();\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n→ On écrit l’implémentation :\nmaClasse::maClasse()\n\t: _attribut1(0)\n\t, _attribut2(&#039;A&#039;)\n{\n\t// corps de la fonction éventuellement vide\n}\nOn peut aussi initialiser les valeurs dans le corps de la fonction (mais c’est moins optimal) :\nmaClasse::maClasse()\n{\n\t_attribut1 = 0;\n\t_attribut2 = &#039;A&#039;;\n}\nIl est également possible de laisser le constructeur par défaut vide, sans initialisation explicite, mais cela a des conséquences :\n\nles attributs primitifs (int, char, etc) contiendront alors des valeurs indéterminées\nles attributs de type objet (comme par exemple std::string) seront initialisés par le constructeur par défaut de l’objet en question\n\nmaClasse::maClasse()\n{\n}\nPourquoi l’écrire soi-même ?\n\nSi aucun constructeur n’est défini, le compilateur en crée un automatiquement (appelé constructeur implicite).\nMais dès qu’un autre constructeur est défini (ex. avec paramètres), le constructeur par défaut n’est plus généré.\nIl est donc nécessaire de l’écrire manuellement si l’on veut continuer à pouvoir créer des objets sans argument.\nDe plus, il est obligatoire dans la forme canonique.\n\nRésumé\n\nLe constructeur par défaut permet de créer un objet sans argument. Il est appelé automatiquement dans de nombreuses situations et doit être défini manuellement si un autre constructeur existe.\nIl est obligatoire dans la forme canonique à 42.\n"},"constructeur":{"slug":"constructeur","filePath":"constructeur.md","title":"constructeur","links":["méthode","classe","objet","attribut","fonction","publique","liste-d'initialisation","C++11","forme-canonique","constructeur-par-défaut","constructeur-par-copie","forme-canonique-de-Coplien"],"tags":[],"content":"\nNom anglais: constructor\n\n\nUn constructeur est une méthode spéciale d’une classe qui est appelée automatiquement lors de la création d’un objet.\nIl sert à initialiser les attributs de cet objet (ses variables).\n\n\nDe quoi est composé un constructeur\n\nC’est une fonction sans type de retour (pas même void)\nde même nom que la classe\ngénéralement dans la partie publique de la classe\nelle contient généralement une liste d’initialisation (qui va initialiser les attributs) située entre le prototype et le corps de la fonction\n\n\nSyntaxe\nLe constructeur contient:\n\nle NomDeLaFonction (obligatoirement le même nom que la classe)\ndes parenthèses ()contenant les arguments attendus\ndeux points : pour introduire la liste d’initialisation\nla liste d’initialisation avec pour chaque attribut à initialiser:\n\nl’attribut\ndes parenthèses () contenant la valeur à affecter à l’attribut\nune virgule ,pour séparer chaque attribut initialisé\n\n\ndes accolades {}contenant le corps de la fonction (qui peut être vide)\n\nComme pour tout méthode d’une classe, le .hpp doit contenir le prototype et le .cpp doit contenir l’implémentation.\n\nExemple\nExemple de constructeur pour une classe nommée maClasse et pour laquelle je vais initialiser deux attributs :\nTu as eu raison de te poser la question — et en effet, il y a une légère confusion dans ta fiche concernant la séparation entre .hpp et .cpp.\nDans le .hpp :\n→ On écrit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(int variable1, char variable2);\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n→ On écrit l’implémentation :\nmaClasse::maClasse(int variable1, char variable2)\n\t: _attribut1(variable1)\n\t, _attribut2(variable2)\n{\n\t// corps de la fonction éventuellement vide\n}\nOn peut aussi initialiser dans le corps de la fonction mais c’est moins optimal :\nmaClasse::maClasse(int variable1, char variable2)\n{\n\t_attribut1 = variable1;\n\t_attribut2 = variable2;\n}\n\nEn C++11\nLa liste d’initialisation peut utiliser des accolades {} mais pour rappel le C++11 est interdit dans les premiers modules 42 :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(int variable1, char variable2)\n\t\t\t: _attribut1 { variable1 }\n\t\t\t, _attribut2 { variable2 }\n\t\t{\n\t\t\t// corps de la fonction\n\t\t\t// qui peut rester vide si elle ne fait rien d&#039;autre qu&#039;initialiser)\n\t\t}\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nCela permet d’éviter les ambiguïtés comme par exemple :\nMyClass obj1(1);   // Appelle le constructeur\nMyClass obj2();    // Ce n’est pas un objet : déclaration d’une fonction !\nMyClass obj3{1};   // Appelle le constructeur sans ambiguïté\n\nDans quels cas implémenter le corps du constructeur\nLe corps de la fonction peut contenir du code si besoin, comme par exemple :\n\ninitialisation des attributs dans le corps de la fonction - possible mais pas optimal (voir au-dessus)\nfaire un traitement après initilaisation (comme par exemple afficher un message)\nappeler une méthode interne\nfaire des calculs à partir des paramètres (par exemple variable3 = variable1 + variable2)\ninitialiser un attribut dans constructeur par défaut (si cet attribut est un objet complexe et qu’il n’a pas de constructeur accessible)\n\n\nConstructeurs et forme canonique\nLa forme canonique (obligatoire dans la plupart des projets 42) exige de définir, entre autres, deux constructeurs particuliers :\n\nle constructeur par défaut\nle constructeur par copie\n\n→ Voir la fiche dédiée : forme canonique de Coplien"},"conteneur-adaptateur":{"slug":"conteneur-adaptateur","filePath":"conteneur adaptateur.md","title":"conteneur adaptateur","links":["conteneur-standard-de-la-STL","conteneur","file-double","vecteur","pile","file-FIFO","file-de-priorité"],"tags":[],"content":"\nNom anglais: container adaptor\n\n\nUn conteneur adaptateur est un conteneur standard de la STL qui ne stocke pas directement les éléments, mais fournit une interface restreinte sur un conteneur sous-jacent (généralement une file double dequeou un vecteur vector).\nLes adaptateurs permettent d’utiliser des structures classiques comme des piles ou des files, sans exposer toute l’interface du conteneur de base.\n\n\nFonctionnement\nUn adaptateur encapsule un conteneur standard (deque, vector, etc.) et restreint son interface à un mode d’accès spécifique :\n\nLIFO (Last In First Out) pour stack\nFIFO (First In First Out) pour queue\nmax-priority pour priority_queue\n\nIl ne permet ni accès par index, ni parcours complet, mais fournit une interface simple et adaptée à un comportement algorithmique particulier.\n\nCaractéristiques\n\nInterface limitée à quelques fonctions essentielles (push, pop, top, etc.)\nUtilise en interne un conteneur séquentiel (deque, vector, etc.)\nNe fournit pas d’itérateur\nNe permet pas le parcours ou l’insertion arbitraire\n\n\nTypes principaux\nLes principaux conteneurs adaptateurs sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionConteneur sous-jacent (par défaut)std::stackpile LIFO (accès par le haut)deque (file double)std::queuefile FIFO (ajout fin, retrait début)deque (file double)std::priority_queuefile de priorité (triée par max)vector (vecteur)\n→ Voir les fiches dédiées : pile, file FIFO, file de priorité\n\nComparaison avec les autres conteneurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectAdaptateursSéquentiels / AssociatifsInterface restreinte✅ oui❌ non (interface complète)Itérateurs❌ non✅ oui (begin(), end(), etc.)Parcours possible❌ non✅ ouiAccès par index❌ non✅ pour certains (vector, deque)Usage algorithmique✅ spécialisé (FIFO, LIFO)⚠️ plus généraliste\n\nUsage typique\n\nImplémentation d’une pile de traitement (stack)\nTraitement en file d’attente (exécution différée, gestion d’événements) via queue\nTri dynamique par priorité dans les algorithmes gloutons (priority_queue)\n"},"conteneur-associatif":{"slug":"conteneur-associatif","filePath":"conteneur associatif.md","title":"conteneur associatif","links":["conteneur-standard-de-la-STL","C++98","itérateur","ensemble","dictionnaire"],"tags":[],"content":"\nNom anglais: associative container\n\n\nUn conteneur associatif est un conteneur standard de la STL conçu pour stocker des éléments accessibles via une clé, plutôt que par une position ou un index.\nIl repose sur une structure de données permettant une recherche rapide des éléments par leur clé.\n\n\nFonctionnement\nLes conteneurs associatifs C++98 utilisent en interne un arbre binaire de recherche équilibré (généralement un arbre rouge-noir), ce qui garantit des opérations en temps O(log n) pour :\n\nl’insertion (insert)\nla recherche (find)\nla suppression (erase)\n\n\nCaractéristiques\n\nLes éléments sont triés automatiquement selon operator&lt; sur la clé\nL’accès se fait via des itérateurs (parcours trié possible)\nChaque élément est soit une clé (set), soit une paire clé/valeur (map)\n\n\nTypes principaux\nLes principaux conteneurs associatifs sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionstd::setEnsemble trié de valeurs uniquesstd::multisetEnsemble trié avec doublons autorisésstd::mapTable triée de paires clé/valeur uniquesstd::multimapTable triée avec plusieurs valeurs par clé\n→ Voir les fiches dédiées: ensemble, dictionnaire\n\nComparaison avec les conteneurs séquentiels\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectAssociatifSéquentiel (vector, list, …)Accès par clé✅ oui❌ nonTri automatique✅ oui❌ nonAccès par index❌ non✅ oui (vector, deque)Performance accèsO(log n)O(1) à O(n) selon structure\n\nUsage typique\n\nTables de correspondance, dictionnaires\nIndexation par identifiant\nComptage de fréquences\nStructure d’accès rapide par nom, catégorie ou clé\n"},"conteneur-standard-de-la-STL":{"slug":"conteneur-standard-de-la-STL","filePath":"conteneur standard de la STL.md","title":"conteneur standard de la STL","links":["conteneur","STL","C++","vecteur","liste","file-double","ensemble","dictionnaire","conteneur-associatif","dictionnaire-à-clé-multiples","ensemble-avec-doublons","pile-algorithmique-LIFO","conteneur-adaptateur","file-FIFO","file-de-priorité","programmation-orientée-objet"],"tags":[],"content":"\nNom anglais: STL containers / standard containers\n\n\nLes conteneurs std sont des structures fournies par la STL (Standard Template Library) en C++.\nIls permettent de stocker, organiser et manipuler des collections de données de manière sûre, souple et efficace.\nChaque conteneur est optimisé pour un usage particulier : accès rapide, ajout en fin, insertion au milieu, recherche, etc.\n\n\nListe des conteneurs principaux\nLes vecteurs : std::vector – Tableau dynamique\nLe vecteur std::vector est le conteneur le plus utilisé. Il agit comme un tableau dynamique : il permet d’ajouter, supprimer ou accéder aux éléments en temps constant (accès par indice). Contrairement aux tableaux en C, un vector peut grandir ou rétrécir automatiquement selon les besoins. Il stocke ses éléments de manière contiguë en mémoire, ce qui le rend rapide pour les accès successifs. Il convient parfaitement quand on connaît approximativement la taille à l’avance ou quand les éléments sont principalement ajoutés à la fin.\n→ Voir la fiche dédiée vecteur\nLes listes : std::list – Liste doublement chaînée\nLa liste std::list est une liste doublement chaînée. Elle permet une insertion ou suppression rapide n’importe où dans la liste (en O(1) si on a un pointeur). Contrairement à vector, les éléments ne sont pas contigus en mémoire. Cela la rend moins performante pour les accès par position, mais idéale si on doit insérer ou retirer souvent des éléments au milieu. Elle ne permet pas d’accès par indice direct (list[i] est invalide). Elle est plus lourde en mémoire, mais plus souple pour certaines opérations.\n→ Voir la fiche dédiée liste\nLes files : std::deque – Double-ended queue\nLa file double std::deque (double-ended queue) est une structure intermédiaire entre vector et list. Elle permet des ajouts et suppressions rapides aux deux extrémités (début et fin) tout en offrant un accès par indice. Elle est utile pour manipuler des données dans un contexte de file d’attente ou de pile double. Contrairement à vector, ses données ne sont pas garanties comme contiguës en mémoire, mais elle reste très rapide dans les cas d’usage adaptés.\n→ Voir la fiche dédiée file double\nLes ensembles : std::set – Ensemble ordonné\nL’ensemble std::set stocke des valeurs uniques dans un ordre trié automatiquement. Il utilise en général une arborescence équilibrée (comme un red-black tree) pour garantir des temps d’insertion, de recherche et de suppression en O(log n). Il est parfait pour représenter des ensembles mathématiques, des listes sans doublons, ou faire des recherches rapides sans re-trier. Il ne permet pas de stocker plusieurs fois la même valeur, ni de modifier directement les éléments (car cela briserait l’ordre).\n→ Voir la fiche dédiée ensemble\nLes maps : std::map – Dictionnaire clé-valeur ordonné\nLe dictionnaire std::map est un conteneur associatif qui relie une clé unique à une valeur. Il agit comme un dictionnaire : tu peux y accéder avec map[&quot;clé&quot;]. Les clés sont automatiquement triées, et chaque insertion, recherche ou suppression est en O(log n). Il est parfait pour organiser des données indexées de manière claire (comme une table de symboles, des configs, etc). Il ne peut pas contenir deux fois la même clé.\n→ Voir la fiche dédiée dictionnaire\nstd::unordered_map – Dictionnaire non trié (haché)\nLe dictionnaire à clé multiples std::unordered_map est similaire à map, mais les clés ne sont pas triées. Il utilise une table de hachage pour stocker les paires clé/valeur, ce qui rend les opérations plus rapides (en moyenne O(1)) mais non ordonnées. C’est idéal si l’ordre des clés n’a aucune importance, et que tu veux une performance maximale en recherche.\n→ Voir la fiche dédiée dictionnaire à clé multiples\nstd::unordered_set – Ensemble non trié\nComme unordered_map, l’ensemble avec doublons est basé sur un hachage, mais ne stocke que des valeurs uniques (sans paires clé-valeur). Il est très utile pour tester rapidement l’appartenance à un ensemble ou éliminer les doublons sans tri.\n→ Voir la fiche dédiée ensemble avec doublons\nstd::stack – Pile LIFO (Last In First Out)\nLa pile algorithmique LIFO std::stack est un conteneur adaptateur basé par défaut sur std::deque. Elle offre une interface simplifiée pour gérer une pile d’éléments : on ajoute avec push() et on retire avec pop(), toujours par le haut. On accède au sommet avec top(). Elle est idéale pour modéliser des structures récursives, des appels empilés, ou des algorithmes comme le parcours profond (DFS). Elle n’expose pas d’itérateur, ni de parcours possible.\n→ Voir la fiche dédiée pile algorithmique LIFO\nstd::queue – File FIFO (First In First Out)\nLa file FIFO std::queue est une file d’attente classique : les éléments sont ajoutés à la fin (push) et retirés au début (pop). Elle est parfaite pour traiter des événements ou des tâches dans l’ordre d’arrivée. Comme stack, elle repose généralement sur deque et n’expose aucun itérateur. Elle permet de modéliser des pipelines, buffers ou boucles de traitement.\n→ Voir la fiche dédiée file FIFO\nstd::priority_queue – File de priorité (tas binaire)\nLa file de priorité std::priority_queue est une file spéciale où l’élément ayant la plus haute priorité est toujours en tête. Par défaut, il s’agit d’un max-heap : l’élément le plus grand (selon operator&lt;) est en haut. Elle s’appuie sur un std::vector et les algorithmes make_heap / push_heap. Elle est très utilisée dans les algorithmes gloutons (Dijkstra, A*, Huffman), les planificateurs ou systèmes à priorité dynamique.\n→ Voir la fiche dédiée file de priorité\n\nRésumé\n\nLes conteneurs std sont des outils puissants pour organiser et gérer des collections de données.\nLe choix du conteneur dépend de l’ordre, de la recherche, de la fréquence d’ajout/retrait, et des performances souhaitées.\nC’est l’un des fondements de la STL et de la programmation orientée objet moderne en C++.\n"},"conteneur-séquentiel":{"slug":"conteneur-séquentiel","filePath":"conteneur séquentiel.md","title":"conteneur séquentiel","links":["conteneur-standard-de-la-STL","conteneur-associatif","vecteur","file-double","itérateur","liste"],"tags":[],"content":"\nNom anglais: sequential container\n\n\nUn conteneur séquentiel est un conteneur standard de la STL destiné à stocker des éléments dans un ordre linéaire, correspondant à leur ordre d’insertion ou de position logique.\nContrairement aux conteneur associatifs, l’accès aux éléments se fait par position (index ou itérateur), et non par clé.\n\n\nFonctionnement\nLes conteneurs séquentiels offrent une organisation ordonnée des éléments.\nIls sont adaptés à une gestion de séquences, à des accès par index, ou à des traitements linéaires (parcours, filtres, tris manuels).\nLeur comportement varie selon leur structure interne : tableau contigu, tableau segmenté, ou liste chaînée.\n\nCaractéristiques\n\nLes éléments sont ordonnés selon leur position dans la séquence\nIls sont accessibles via index (vecteur vector, file double deque) ou itérateurs`\nAucune structure de tri automatique\nLes performances dépendent fortement de la structure mémoire (contiguë ou non)\n\n\nTypes principaux\nLes principaux conteneurs séquentiels sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionstd::vector (vecteur)Tableau dynamique à mémoire contiguë (accès rapide)std::deque (file double)Tableau segmenté à double extrémitéstd::list (liste)Liste doublement chaînée\n→ Voir les fiches dédiées : vecteur, file double, liste\n\nComparaison avec les conteneurs associatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectSéquentielAssociatif (map, set, …)Accès par index✅ oui (vector, deque)❌ nonAccès par clé❌ non✅ ouiOrdre d’insertion✅ conservé❌ tri automatique par cléParcours mémoire✅ très rapide (vector)⚠️ plus coûteux (arbre)Tri automatique❌ non✅ oui (operator&lt;)\n\nUsage typique\n\nReprésentation de séquences, tableaux dynamiques\nParcours ordonné et manipulation d’éléments\nStructures FIFO, piles, buffers\nStockage d’objets dans l’ordre logique du traitement\n"},"conteneur":{"slug":"conteneur","filePath":"conteneur.md","title":"conteneur","links":["C++","STL","objet","itérateur","algorithmes-STL","conteneur-standard-de-la-STL","conteneur-séquentiel","vecteur","file-double","liste","conteneur-associatif","ensemble","dictionnaire","ensemble-avec-doublons","dictionnaire-à-clé-multiples","conteneur-adaptateur","pile-algorithmique-LIFO","file-FIFO","file-de-priorité"],"tags":[],"content":"\nNom anglais: container\n\n\nEn C++, un conteneur est une structure de données, généralement fournie par la STL (Standard Template Library), qui permet de stocker et gérer des collections d’objets.\nChaque conteneur propose une interface standardisée avec des itérateurs, des opérations d’insertion, de suppression, et d’accès aux éléments.\n\n\nObjectif des conteneurs\n\nCentraliser la gestion de la mémoire et des structures de données\nFournir une interface générique pour les algorithmes STL\nGarantir des performances adaptées selon l’usage : séquentiel, associatif, adaptatif\n\n\nCatégories principales\nLes conteneur standard de la STL se divisent en plusieurs catégories selon leur structure et leur mode d’accès :\nConteneurs séquentiels\nLes conteneur séquentiels stockent les éléments dans l’ordre d’insertion, accessibles par position :\n\nvecteur std::vector\nfile double std::deque\nliste std::list\n\nConteneurs associatifs\nLes conteneur associatifs stockent les éléments selon une clé unique ou non, et les trie automatiquement :\n\nensemble std::set\ndictionnaire std::map\nensemble avec doublons std::multiset\ndictionnaire à clé multiplesstd::multimap\n\nConteneurs adaptateurs\nLes conteneur adaptateurs fournissent une interface restreinte sur un autre conteneur (souvent une file double deque) :\n\npile algorithmique LIFO std::stack\nfile FIFO std::queue\nfile de priorité std::priority_queue\n\n\nVoir aussi\n\nconteneur standard de la STL → récapitulatif de tous les conteneurs STL C++98\nconteneur associatif → fonctionnement, structure interne, usages\nconteneur séquentiel → comparaison vector / deque / list\nconteneur associatif → fonctionnement par paire clé/valeur\n"},"contrôles-d'accès":{"slug":"contrôles-d'accès","filePath":"contrôles d'accès.md","title":"contrôles d'accès","links":["C++","attribut","méthode","classe","publique","protégé","classe-dérivée","privé","encapsulation"],"tags":[],"content":"\nNom anglais: access control / access specifiers\n\n\nLes contrôles d’accès en C++permettent de définir qui peut accéder aux attributs et méthodes d’une classe. Ils assurent la protection et l’organisation des données.\nComparaison C/C++ : En C, il n’y a pas de contrôle d’accès dans les struct. En C++, les classes peuvent restreindre ou exposer ce qu’elles contiennent.\n\nLes trois niveaux d’accès\n\npublique : accessible partout (par n’importe qui).\nprotégé : accessible dans la classe et ses classe dérivées (mais pas de l’extérieur).\nprivé : accessible seulement à l’intérieur de la classe.\n\nUtiliser les contrôles d’accès\nOn les utilise dans la déclaration d’une classe :\nclass Voiture\n{\nprivate:\n    int vitesse;\n \npublic:\n    void demarrer();\n};\n\n\nvitesse est privée : on ne peut pas y accéder directement de l’extérieur.\n\n\ndemarrer() est publique : on peut l’appeler librement.\n\n\nRésumé\nLes contrôles d’accès permettent de :\n\n\nProtéger les données sensibles,\n\n\nEncadrer l’utilisation des objets,\n\n\nRespecter l’encapsulation.\n\n\n\nVeux-tu que je te prépare aussi une mini-fiche dédiée sur protected (partie protégée) pour finir le trio public / protected / private proprement dans ton Obsidian ? 🔒📚"},"convention-de-nommage":{"slug":"convention-de-nommage","filePath":"convention de nommage.md","title":"convention de nommage","links":["classe","fonction","variable","attribut","espace-de-noms","C++","méthode","Classe","Struct","UpperCamelCase","Fonction","Méthode","lowerCamelCase","Variable-locale","Attribut","privé","Constante","Macro","Fichier","Namespace"],"tags":[],"content":"\nNom anglais : Naming convention\n\n\nUne convention de nommage est un ensemble de règles adoptées dans un projet ou une communauté pour nommer de manière cohérente et lisible les différents éléments du code source : classe, fonction, variable, attribut, espace de noms, etc.\nComparaison C / C++ : En langage C, les conventions varient fortement selon les projets, et les noms utilisent souvent le style snake_case avec des majuscules pour les constantes. En C++, bien que plusieurs styles existent, une structuration claire du nommage est souvent adoptée pour distinguer visuellement les responsabilités (types, méthodes, constantes, etc.). Cela permet d’améliorer la lisibilité, la maintenabilité et l’uniformité du code.\n\n\nObjectifs\nUne convention de nommage vise à :\n\ndifférencier clairement les types d’éléments (classe, fonction, etc.)\naméliorer la lisibilité du code\néviter les erreurs ou confusions\nfaciliter le travail collaboratif\nréduire le besoin de commentaires\n\n\nStyles courants\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉlémentStyle utiliséExempleClasse, StructUpperCamelCaseGestionnaireFichierFonction, MéthodelowerCamelCaselireLigne()Variable localelowerCamelCasecompteurAttribut privélowerCamelCaseposition_Constante, MacroSCREAMING_SNAKE_CASETAILLE_MAXFichiersnake_casemon_module.cppNamespacesnake_case ou minusculeutilitaires\n\nRemarques\n\nIl n’existe pas de norme unique en C++, mais plusieurs conventions populaires (Google, LLVM, Qt, etc.).\nL’important est de choisir une convention cohérente et de s’y tenir dans tout le projet.\nLes noms doivent rester significatifs et explicites, même si cela implique d’être un peu plus longs.\n"},"cout":{"slug":"cout","filePath":"cout.md","title":"cout","links":["Nom-pleinement-qualifié","bibliothèque-standard-C++","bibliothèque-iostream","espace-de-noms","flux","C++","objet","opérateur","string","surchargé"],"tags":[],"content":"\nNom pleinement qualifié: std::cout\n\n\nstd::cout est un objet de la bibliothèque standard C++ qui permet d’afficher des données sur la sortie standard (généralement l’écran). Il fait partie de la bibliothèque iostreamet appartient à l’espace de nomsstd.\nOn l’utilise avec l’opérateur &lt;&lt; (appelé opérateur d’insertion) pour envoyer une ou plusieurs valeurs dans le flux de sortie standard.\nComparaison C/C++ : En C, on utilise la fonction printf() pour afficher. En C++, on utilise std::cout, qui est un objet de type std::ostream, utilisé avec l’opérateur &lt;&lt;.\n\nFonctionnement de base\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\n\nCela affiche &quot;Bonjour&quot; sur la console.\nL’opérateur &lt;&lt; signifie ici “envoie dans le flux”.\n\nAfficher plusieurs éléments\nOn peut enchaîner autant d’éléments que l’on souhaite, chacun séparé par &lt;&lt; :\nstd::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, âge : &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot;;\nChaque morceau est envoyé dans le flux l’un après l’autre, dans l’ordre.\n\nIl ne s’agit pas d’une liste d’arguments, mais d’une suite d’opérations &lt;&lt; exécutées successivement.\n\nTypes acceptés\nstd::cout accepte automatiquement :\n\ndes valeurs textuelles : &quot;texte&quot;, &#039;c&#039;, des chaînes de caractère de type string (les std::string)\ndes valeurs numériques : int, float, double\ndes booléens, des pointeurs, etc.\n\nC’est possible car l’opérateur &lt;&lt; est surchargé  pour tous ces types.\n\nEn C++, une fonction ou un opérateur est surchargé lorsqu’il existe plusieurs versions d’un même nom, qui se comportent différemment selon les types des arguments qu’on lui donne (int, string, etc).\nComparaison C/C++: Cela signifie qu’en C++ on peut par exemple afficher un int via std::cout sans avoir besoin de faire appel à une fonction comme itoa.\n\nExemple complet\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom = &quot;Alice&quot;;\n    int age = 30;\n \n    std::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, âge : &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl;\n    return 0;\n}\nAffiche :\nNom : Alice, âge : 30 ans. suivi d’un saut de ligne.\nRésumé\n\nstd::cout permet d’afficher plusieurs valeurs, enchaînées avec l’opérateur &lt;&lt;.\nChaque &lt;&lt; ajoute une valeur dans le flux de sortie. C’est souple, lisible et puissant pour construire dynamiquement une ligne d’affichage.\n"},"destructeur":{"slug":"destructeur","filePath":"destructeur.md","title":"destructeur","links":[],"tags":[],"content":""},"dictionnaire-à-clé-multiples":{"slug":"dictionnaire-à-clé-multiples","filePath":"dictionnaire à clé multiples.md","title":"dictionnaire à clé multiples","links":["conteneur-associatif","STL","C++","dictionnaire","bibliothèque-standard-C++","nom-pleinement-qualifié","Itérateur","itérateur"],"tags":[],"content":"\nNom anglais: multimap\nNom pleinement qualifié: std::multimap\n\n\nUn multimap est un conteneur associatif fourni par la STL en C++. Il permet de stocker des paires clé/valeur, avec la particularité d’autoriser plusieurs valeurs pour une même clé, tout en maintenant un ordre trié sur les clés.\nComme le dictionnaire, multimap repose sur un arbre binaire de recherche équilibré (typiquement un red-black tree), ce qui garantit des opérations en temps logarithmique (O(log n)).\nComparaison C/C++ : Un multimap est un dictionnaire trié avec doublons autorisés sur les clés, adapté aux cas où une relation 1→N (1 clé → plusieurs valeurs) est nécessaire.\n\n\nInclude\nPour utiliser std::multimap il faut l’inclusion suivante :\n#include &lt;map&gt;\n\nEspace de nom\nLes multimaps font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::multimap\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::multimap&lt;Clé, Valeur&gt; maMultiMap;\n \n// exemple pour une multimap int → string :\nstd::multimap&lt;int, std::string&gt; idToNames;\nInitialisation\n→ En C++98\nstd::multimap&lt;int, std::string&gt; m;\nm.insert(std::pair&lt;int, std::string&gt;(1, &quot;un&quot;));\nm.insert(std::pair&lt;int, std::string&gt;(1, &quot;eins&quot;));\nm.insert(std::pair&lt;int, std::string&gt;(2, &quot;deux&quot;));\n→ En C++11 et plus\nstd::multimap&lt;int, std::string&gt; m = {\n    {1, &quot;un&quot;}, {1, &quot;eins&quot;}, {2, &quot;deux&quot;}\n};\n\n⚠️ L’initialisation avec {} n’est pas disponible en C++98 car elle utilise std::initializer_list.\n\n\nImplémentation interne\nUne multimap&lt;K, V&gt; encapsule :\n\nun arbre rouge-noir\ndes nœuds contenant des paires &lt;clé, valeur&gt;\nun tri automatique des clés selon operator&lt;\n\n\nContrairement à un dictionnaire, plusieurs nœuds peuvent avoir la même clé dans un dictionnaire à clé multiples.\n\n\nMultimap et mémoire\nComme les dictionnaires map, les multimap utilisent des nœuds alloués dynamiquement. Chaque insertion entraîne une allocation mémoire.\nLes paires sont triées par clé, mais les doublons sont conservés dans l’ordre d’insertion relative.\nCela rend les performances de recherche et d’insertion très bonnes (O(log n)), mais les accès par clé doivent gérer plusieurs résultats.\n\nQuand et pourquoi utiliser une multimap\nUne multimap est idéale quand une même clé peut correspondre à plusieurs valeurs. Elle est utile pour :\n\nreprésenter une relation 1→N\ngérer des groupements par catégorie\nindexer des objets non-uniques (ex : un nom qui renvoie à plusieurs personnes)\n\nElle conserve les éléments triés par clé et permet d’en extraire toutes les occurrences avec equal_range() ou en itérant depuis lower_bound().\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Nombre total de paires stockéesempty()Vérifie si la multimap est videcount(clé)Nombre d’occurrences de la cléfind(clé)Itérateur vers la première occurrence de la cléequal_range(clé)Renvoie une paire d’itérateurs (début, fin) pour toutes les occurrences\n\nIl n’existe pas de operator[] sur multimap, car il ne peut pas représenter une unique valeur par clé.\n\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptioninsert(pair)Ajoute une paire clé/valeur même si la clé existe déjàerase(it)Supprime l’élément pointé par l’itérateurerase(clé)Supprime toutes les paires ayant cette cléclear()Vide complètement la multimap\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs du début à la fin (par clé croissante)rbegin() / rend()Itérateurs inversés\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte une autre multimapswap()Échange deux multimaps\n\nRemarques importantes\n\nUn dictionnaire à clé multiple std::multimap permet des clés dupliquées, contrairement à un dictionnaire std::map\nIl est triée automatiquement par clé\nPas d’operator[] car la valeur associée à une clé n’est pas unique\nOn accède aux multiples valeurs d’une clé via equal_range(), lower_bound() et upper_bound()\nLes performances sont proches du dictionnaire, mais les usages sont différents : relation 1→N\n"},"dictionnaire":{"slug":"dictionnaire","filePath":"dictionnaire.md","title":"dictionnaire","links":["conteneur","STL","C++","bibliothèque-standard-C++","nom-pleinement-qualifié","cache","itérateur","Itérateur","dictionnaire-à-clé-multiples"],"tags":[],"content":"\nNom anglais: map\nNom pleinement qualifié: std::map\n\n\nUne map est un conteneur associatif fourni par la STL en C++. Elle permet de stocker des paires clé/valeur, où chaque clé est unique et automatiquement triée.\nLes éléments sont organisés selon un arbre binaire de recherche équilibré (généralement un red-black tree), ce qui garantit un accès, une insertion et une suppression en temps logarithmique (O(log n)).\nComparaison C/C++ : Une map est l’équivalent C++ d’un dictionnaire, d’une table de hachage ordonnée, ou d’une structure associant des clés à des valeurs, avec gestion automatique du tri et des collisions.\n\n\nInclude\nPour utiliser std::map il faut l’inclusion suivante :\n#include &lt;map&gt;\n\nEspace de nom\nLes maps font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::map\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nPour déclarer une map il faut utiliser la syntaxe suivante :\nstd::map&lt;Clé, Valeur&gt; maMap;\n \n// exemple pour une map int → string :\nstd::map&lt;int, std::string&gt; idToName;\n \n// exemple pour une map string → float :\nstd::map&lt;std::string, float&gt; produitPrix;\n \n// exemple avec type complexe :\nstd::map&lt;std::string, std::vector&lt;int&gt; &gt; index;\nInitialisation\n→ En C++98\nstd::map&lt;int, std::string&gt; m;\nm[1] = &quot;un&quot;;\nm[2] = &quot;deux&quot;;\nm.insert(std::pair&lt;int, std::string&gt;(3, &quot;trois&quot;));\n→ En C++11 et plus\nstd::map&lt;int, std::string&gt; m = {\n    {1, &quot;un&quot;},\n    {2, &quot;deux&quot;},\n    {3, &quot;trois&quot;}\n};\n\n⚠️ L’initialisation avec des accolades ({}) n’est pas disponible en C++98, car elle repose sur std::initializer_list.\n\n\nImplémentation interne\nUne map&lt;K, V&gt; encapsule :\n\nun arbre binaire équilibré (typiquement un red-black tree)\ndes nœuds contenant des paires &lt;clé, valeur&gt;\nun mécanisme de tri automatique des clés selon l’opérateur &lt;\n\n\nL’ordre d’insertion n’est pas conservé : les éléments sont toujours stockés dans l’ordre croissant des clés.\n\n\nMap et mémoire\nLes std::map utilisent une structure en nœuds dynamiques reliés par pointeurs, ce qui implique :\n\nles éléments sont dispersés en mémoire\nchaque insertion/suppression implique une allocation/désallocation\nles performances sont moins bonnes en parcours séquentiel, car le cache est peu utilisé\n\nCependant, les opérations de recherche, insertion et suppression sont efficaces (O(log n)) grâce à la structure de l’arbre.\n\nQuand et pourquoi utiliser une map\nUne map (std::map) est idéale lorsqu’il faut associer des clés à des valeurs tout en conservant les éléments triés automatiquement selon l’ordre des clés. Elle garantit des opérations de recherche, insertion et suppression en O(log n), grâce à son implémentation en arbre rouge-noir. On l’utilise dès que l’accès rapide aux données via une clé unique est nécessaire, comme par exemple pour :\n\ndes tables de configuration\ndes index\ndes caches\ndes comptages par catégorie.\n\nElle offre également un parcours ordonné naturel via ses itérateurs.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Retourne le nombre d’élémentsempty()Vérifie si la map est videoperator[](clé)Accès ou insertion (valeur par défaut si absente)at(clé)Accès sécurisé (C++11 uniquement)count(clé)Renvoie 1 si la clé existe, 0 sinonfind(clé)Renvoie un itérateur vers la clé si trouvée\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptioninsert(pair)Ajoute une paire clé/valeur (si la clé n’existe pas déjà)erase(it)Supprime l’élément pointé par l’itérateurerase(clé)Supprime l’élément avec la clé donnéeclear()Supprime tous les éléments\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs du début à la fin de la map (par clé croissante)rbegin() / rend()Itérateurs inversés\n\nLes itérateurs permettent un parcours trié selon les clés, utile pour des affichages ou comparaisons ordonnées.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte une autre mapswap()Échange deux maps\n\nRemarques importantes\n\nstd::map tri automatiquement les clés à l’aide de operator&lt;\nIl n’y a qu’une seule valeur par clé : insertion avec une clé existante ne modifie pas la valeur\noperator[] insère une nouvelle paire avec une valeur par défaut si la clé n’existe pas\nLes performances sont bonnes pour les accès par clé, mais moins bonnes pour les scans séquentiels\nLes éléments ne sont pas stockés contiguës → std::map n’est pas cache-friendly\n\n\nVariante : `std::multimap\nLa dictionnaire à clé multiples est une variante de map qui permet de stocker plusieurs paires ayant la même clé.\nElle partage la même structure (arbre rouge-noir) et les mêmes performances (O(log n)), mais :\n\nelle accepte les doublons de clé\nelle ne fournit pas operator[], car il n’y a pas de valeur unique par clé\n\nOn l’utilise dans les cas où une clé peut être associée à plusieurs valeurs distinctes, comme pour représenter une relation 1→N.\n→ Voir la fiche dédiée dictionnaire à clé multiples"},"directive-de-préprocesseur":{"slug":"directive-de-préprocesseur","filePath":"directive de préprocesseur.md","title":"directive de préprocesseur","links":["compilation","C++","inclusion-de-fichiers"],"tags":[],"content":"Qu’est-ce qu’une directive de préprocesseur?\n\nUne directive de préprocesseur est une instruction spéciale qui est traitée avant la compilation du code C++.\nCes directives disent au préprocesseur (un outil qui passe avant le compilateur) de modifier, inclure ou conditionner des parties du code avant que la compilation proprement dite commence.\n\nEn résumé\n\nElles commencent toujours par # (exemple : #include, #define).\nElles ne sont pas du code C++à proprement parler.\nElles préparent le code pour la compilation.\nElles sont invisibles dans le programme final : elles servent à le construire correctement avant de le compiler.\n\nLes différents types de directives\n\ninclusion de fichiers\ndéfinition et suppression de macros\ndirective conditionnelle\ngestion des erreurs et avertissements\n\n2. Définition et suppression de macros\n→ But : créer ou supprimer des constantes/mots-clés automatiques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#define#define NOM valeurDéfinit une macro ou une constante symbolique. Remplace NOM par valeur dans tout le code.#undef#undef NOMSupprime une macro définie auparavant.\n\n🔀 3. Directives conditionnelles\n→ But : inclure ou exclure du code selon certaines conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#ifdef#ifdef NOMCompile le bloc suivant seulement si NOM a été défini par #define.#ifndef#ifndef NOMCompile le bloc suivant seulement si NOM n’a pas été défini.#if#if conditionCompile le bloc suivant si la condition est vraie (exemple : #if VERSION &gt;= 2).#elif#elif condition”Else if” : ajoute une condition supplémentaire après un #if.#else#elseBloc alternatif si aucune condition précédente n’est remplie.#endif#endifMarque la fin d’un bloc conditionnel (#if, #ifdef, etc.).\n\n🚨 4. Gestion des erreurs et avertissements\n→ But : générer des erreurs pendant le prétraitement\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#error#error &quot;Message d&#039;erreur&quot;Force l’arrêt de la compilation avec un message.#warning (pas standard, dépend du compilateur)#warning &quot;Message d&#039;avertissement&quot;Affiche un avertissement sans bloquer la compilation (supporté par gcc, clang).\n\n⚙️ 5. Directives spéciales au compilateur\n→ But : donner des instructions spécifiques au compilateur\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#pragma#pragma optionPasse une commande spécifique au compilateur (exemple : #pragma once pour éviter les doubles inclusions).\n\n🧠 À retenir globalement :\n\n\n#include → pour ajouter du code externe.\n\n\n#define, #undef → pour définir ou supprimer des macros/constantes.\n\n\n#if, #ifdef, #ifndef… → pour faire du code conditionnel.\n\n\n#pragma → pour donner des ordres spéciaux au compilateur.\n\n\n#error, #warning → pour contrôler le comportement en cas de problème.\n\n\n\n📋 Petit résumé ultra rapide par familles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFamilleExemplesInclusion#includeMacro#define, #undefConditions#if, #ifdef, #ifndef, #elif, #else, #endifErreurs#error, #warningSpécial compilateur#pragma\n\nVeux-tu aussi que je te prépare un tableau final “complet prêt à copier” que tu pourrais intégrer directement dans ton vault Obsidian ? 🚀\n(Je peux aussi te proposer un exemple typique d’utilisation combinée de plusieurs directives si tu veux !)\nÀ retenir\n\nLe préprocesseur lit le fichier, exécute toutes les directives #..., puis produit un nouveau fichier prêt pour la compilation.\nC’est comme préparer une recette avant de commencer à cuisiner : rassembler les ingrédients (#include), ajuster la recette (#define), conditionner certaines étapes (#ifdef…).\n"},"durée-de-vie-des-objets":{"slug":"durée-de-vie-des-objets","filePath":"durée de vie des objets.md","title":"durée de vie des objets","links":["C++","objet","constructeur","destructeur","allocation-dynamique-de-la-mémoire","compilateur","pile","tas","bloc","fonction","/","membre-statique","C++11"],"tags":[],"content":"\nNom anglais: object lifetime\n\n\nLa durée de vie d’un objet en C++ désigne la période pendant laquelle cet objet existe en mémoire et peut être utilisé.\nElle commence à sa création (appel du constructeur) et se termine à sa destruction (appel du destructeur).\nComparaison C/C++ : En C, la gestion mémoire est manuelle. En C++, la durée de vie peut être automatique (gérée par le langage) ou dynamique lors d’une allocation dynamique de la mémoire (gérée par le programmeur via new / delete).\n\n\nDurée de vie automatique\nEn C++, lorsqu’on ne fait pas d’allocation dynamique de la mémoire avec new, les objets sont généralement :\nAutomatiques\n\nCela signifie qu’ils sont créés automatiquement par le compilateur au moment où ils entrent en portée, sans avoir besoin d’allocation manuelle.\nLeur durée de vie est gérée par le langage, sans new ni delete.\n\nDéclarés sur la pile (stack)\n\nCes objets sont stockés dans la mémoire de la pile (stack), une zone rapide et locale à chaque fonction.\nContrairement au tas (heap), la pile est libérée automatiquement à la fin du bloc.\n\nDétruits automatiquement à la fin du bloc\n\nDès que le bloc {} dans lequel l’objet a été créé se termine, le destructeur est automatiquement appelé, et la mémoire est libérée.\nC’est ce qu’on appelle la durée de vie automatique.\n\nExemple concret\nvoid fonction() {\n    MaClasse obj;  // constructeur appelé ici\n} // ← destructeur appelé ici automatiquement\nDans cet exemple le destructeur sera appelé automatiquement à la fin de la fonction. L’objetobj ne pourra donc pas être utilisé au-delà de la fonction dans laquelle il a été déclaré.\nvoid fonction() {\n    MaClasse obj;  // constructeur appelé ici\n} // destructeur appelé ici automatiquement\n\nDurée de vie dynamique\nA l’inverse, lorsqu’un objet est créé par allocation dynamique de la mémoire avec l’opérateur new, il est dit :\nDynamique\n\nCela signifie que sa mémoire est réservée manuellement sur le tas (heap) à l’exécution, via new.\nIl n’est pas libéré automatiquement à la fin d’un bloc : c’est au programmeur d’appeler delete.\n\nAlloué sur le tas (heap)\n\nCes objets sont stockés sur le tas, une zone mémoire conçue pour les allocations manuelles.\nContrairement à la pile (stack), la mémoire du tas persiste après la fin du bloc.\n\nPersistant jusqu’à destruction manuelle\n\nL’objet créé avec new continue d’exister jusqu’à ce que le programme appelle explicitement delete (ou delete[] pour les tableaux).\nSi on oublie de libérer la mémoire, on provoque une fuite mémoire.\n\nExemple concret\nvoid fonction() {\n    MaClasse* ptr = new MaClasse();  // constructeur appelé ici\n    // ...\n    delete ptr;                      // destructeur appelé ici manuellement\n}\nDans cet exemple, l’objet est valide au-delà de la fonction, tant que ptr est conservé. Mais si delete est oublié, la mémoire ne sera jamais libérée.\n\nCas particulier : objet statique\n\nUn objet déclaré avec le mot-clé static (dans une fonction ou un bloc) ne sera construit qu’une seule fois et détruit à la fin du programme.\nCela vaut aussi pour les variables globales ou les membres static.\n\nvoid f() {\n    static Compteur c; // construit à la première exécution\n} // détruit à la fin du programme\n→ Voir aussi : membre statique\n\nRésumé comparatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType de durée de vieCréationDestructionStockageExempleAutomatiqueentrée dans le blocfin du blocpileMaClasse obj;Dynamiquenewdeletetasnew MaClasse;Statiqueau premier usageà la fin du programmestatiquestatic MaClasse obj;\n\nBonnes pratiques\n\nPrivilégier la durée automatique quand c’est possible (plus sûre, gérée par le langage)\nNe pas oublier de libérer les objets dynamiques (delete) pour éviter les fuites mémoire.\nÀ partir de C++11, préférer l’usage de smart pointers (std::unique_ptr, std::shared_ptr) pour gérer automatiquement la durée de vie dynamique\n\n\nVoir aussi\n→ objet, constructeur, destructeur\n→ pile, tas, bloc\n→membre statique"},"débogage":{"slug":"débogage","filePath":"débogage.md","title":"débogage","links":[],"tags":[],"content":"\nQu’est-ce que?"},"déclaration-anticipée":{"slug":"déclaration-anticipée","filePath":"déclaration anticipée.md","title":"déclaration anticipée","links":["classe","compilation","C++"],"tags":[],"content":"\nNom anglais: forward declaration\n\n\nUne déclaration anticipée (forward declaration) permet d’annoncer l’existence d’une classe, d’une struct, ou d’une fonction avant sa définition complète. Cela aide à réduire les dépendances et à accélérer la compilation.\nComparaison C/C++ : Le C utilise déjà les déclarations anticipées pour les fonctions. En C++, elles sont aussi très utilisées pour les classes.\n\nPourquoi utiliser une déclaration anticipée?\nLes forward declarations permettent :\n\nd’annoncer un type sans inclure son détail,\nde réduire le couplage entre fichiers,\nd’accélérer la compilation en limitant les inclusions inutiles.\n\nDéfinir une déclaration anticipée\nExemple pour une classe :\nclass Moteur; // déclaration anticipée\n \nclass Voiture\n{\nprivate:\n    Moteur* moteur; // pointeur vers Moteur\n};\nIci, on annonce Moteur sans avoir besoin de sa définition complète.\nAttention : on ne peut utiliser qu’un pointeur ou une référence tant qu’on n’a pas la définition complète.\nRésumé\nLa forward declaration sert à préparer le compilateur à rencontrer un type sans le charger immédiatement."},"encapsulation":{"slug":"encapsulation","filePath":"encapsulation.md","title":"encapsulation","links":["programmation-orientée-objet","objet","attribut","méthode","accesseur","mutateur","classe","privé","publique"],"tags":[],"content":"\nNom anglais: encapsulation\n\n\nL’encapsulation est un principe fondamental de la programmation orientée objetqui consiste à protéger les données internes d’un objet en limitant l’accès direct à ses attributs. Elle impose de passer par des méthodes (accesseurs et mutateurs) pour interagir avec l’objet.\nComparaison avec le C: En C, les membres des structures sont accessibles librement. En C++, grâce à l’encapsulation, on peut cacher l’implémentation interne et contrôler l’accès.\n\nPourquoi utiliser l’encapsulation\nL’encapsulation permet :\n\nde protéger les attributs contre les accès ou modifications non désirés,\nde forcer un contrôle via des méthodes (accesseurs, mutateurs),\nde simplifier l’usage d’un objet en cachant sa complexité interne,\nde rendre possible l’évolution de la classe sans casser son utilisation par les autres parties du programme.\n\nEncapsulation et sections d’accès\nOn réalise l’encapsulation en utilisant les sections d’accès :\n\npartie privée (private) pour cacher les données sensibles,\npartie publique (public) pour exposer uniquement ce qui est nécessaire.\n\nExemple :\nclass Voiture\n{\nprivate:\n    int vitesse; // caché\n \npublic:\n    int getVitesse() const; // exposé de façon contrôlée\n    void setVitesse(int v); // modifiable sous conditions\n};\nRésumé\nL’encapsulation repose sur deux idées simples :\n\nCacher les détails d’implémentation.\nExposer une interface simple et sécurisée pour utiliser l’objet.\n"},"endl":{"slug":"endl","filePath":"endl.md","title":"endl","links":["Nom-pleinement-qualifié","manipulateur-de-flux","cout","tampon-de-sortie","flush","C++"],"tags":[],"content":"\nNom pleinement qualifié: std::endl\n\n\nstd::endl est un manipulateur de fluxutilisé avec std::cout (voir cout) pour insérer un saut de ligne (\\n) et forcer l’affichage immédiat en vidant le tampon de sortie (flush).\nComparaison C/C++ : En C, on écrit \\n dans une chaîne. En C++, std::endl a un effet supplémentaire : il vide le tampon de sortie, ce qui peut être utile pour garantir l’affichage immédiat.\n\nSaut de ligne et affichage\nQuand on écrit :\nstd::cout &lt;&lt; &quot;Bonjour&quot; &lt;&lt; std::endl;\ncela fait deux choses :\n\nAjoute un retour à la ligne (comme \\n)\nVide le tampon de sortie (flush)\n\nComparaison avec \\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉcritureComportement\\nAjoute un saut de ligne, ne flush pas le tamponstd::endlSaut de ligne et flush (affichage immédiat)\nRésumé\n\nstd::endl est un manipulateur de flux qui :\n\najoute un saut de ligne\nvide le tampon de sortie (= flush)\nIl garantit que l’affichage a bien lieu tout de suite.\n\n"},"ensemble-avec-doublons":{"slug":"ensemble-avec-doublons","filePath":"ensemble avec doublons.md","title":"ensemble avec doublons","links":["conteneur-associatif","conteneur-standard-de-la-STL","STL","C++","ensemble","bibliothèque-standard-C++","nom-pleinement-qualifié","vecteur","itérateur","Itérateur"],"tags":[],"content":"\nNom anglais: multiset\nNom pleinement qualifié: std::multiset\n\n\nUn ensemble avec doublons multiset est un conteneur associatif faisant partie des conteneur standard de la STL fourni par la STL en C++. Il permet de stocker une collection de valeurs triées, tout en autorisant les doublons.\nComme l’ensemble set, les éléments sont organisés dans un arbre binaire de recherche équilibré (typiquement un arbre rouge-noir), ce qui permet des opérations de recherche, insertion et suppression en O(log n).\nComparaison C/C++ : Un multiset est un ensemble trié où les doublons sont acceptés. C’est l’équivalent d’un ensemble set non strictement injectif.\n\n\nInclude\nPour utiliser std::multiset il faut l’inclusion suivante :\n#include &lt;set&gt;\n\nEspace de nom\nLes ensembles avec doublons multiset font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::multiset\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::multiset&lt;Type&gt; monMultiSet;\n \n// exemple :\nstd::multiset&lt;int&gt; ensembleValeurs;\nstd::multiset&lt;std::string&gt; motsAvecDoublons;\nInitialisation\n→ En C++98\nstd::multiset&lt;int&gt; s;\ns.insert(3);\ns.insert(1);\ns.insert(3); // accepté\ns.insert(2);\n→ En C++11 et plus\nstd::multiset&lt;int&gt; s = {3, 1, 3, 2};\n\n⚠️ L’initialisation avec {} n’est pas disponible en C++98, car elle repose sur std::initializer_list.\n\n\nImplémentation interne\nUn ensemble avec doublons multiset&lt;T&gt; encapsule :\n\nun arbre rouge-noir\ndes nœuds contenant uniquement des valeurs\nun tri automatique par operator&lt;, même en cas de valeurs dupliquées\n\n\nContrairement à l’ensembleset, les doublons sont conservés et peuvent coexister dans l’arbre.\n\n\nEnsembles avec doublons et mémoire\nChaque élément, même dupliqué, est stocké dans un nœud distinct, alloué dynamiquement.\nLes valeurs sont triées mais pas modifiables, car cela compromettrait l’ordre interne.\nLa mémoire est donc plus fragmentée que dans un vecteur vector, mais l’accès trié est plus rapide.\n\nQuand et pourquoi utiliser un ensemble avec doublons\nLe multiset est utile lorsque :\n\nles doublons sont significatifs (ex : histogrammes, logs, relevés)\non souhaite compter ou classer des éléments automatiquement\non a besoin de conserver les éléments dans un ordre trié, même s’ils sont répétés\n\nIl s’adapte à de nombreuses situations d’analyse, de tri partiel ou de regroupement.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Nombre total d’éléments (y compris les doublons)empty()Vérifie si le multiset est videcount(val)Nombre d’occurrences de valfind(val)Renvoie un itérateur vers la première occurrence de val\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptioninsert(val)Ajoute val, même si elle est déjà présenteerase(val)Supprime toutes les occurrences de valerase(it)Supprime un seul élément pointé par l’itérateurclear()Vide complètement le multiset\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs de début à fin (ordre trié)rbegin() / rend()Itérateurs inversés\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte un autre multisetswap()Échange deux multisets\n\nRemarques importantes\n\nContrairement à l’ensemble set, le multiset autorise plusieurs occurrences de la même valeur\nLes éléments sont triés automatiquement\nIl n’y a pas de suppression automatique des doublons\nOn peut parcourir les occurrences avec equal_range(), lower_bound() et upper_bound()\nLes performances sont équivalentes à celles de set, avec plus de flexibilité sur les doublons\n"},"ensemble":{"slug":"ensemble","filePath":"ensemble.md","title":"ensemble","links":["conteneur-associatif","conteneur-standard-de-la-STL","C++","STL","bibliothèque-standard-C++","nom-pleinement-qualifié","dictionnaire","cache","vecteur","itérateur","Itérateur","set","ensemble-avec-doublons"],"tags":[],"content":"\nNom anglais: set\nNom pleinement qualifié: std::set\n\n\nUn set est un conteneur associatif qui fait parti des conteneur standard de la STL en C++. Il permet de stocker une collection de valeurs uniques, automatiquement triées selon l’ordre défini par operator&lt;.\nLes éléments sont organisés dans un arbre binaire de recherche équilibré (typiquement un arbre rouge-noir), ce qui garantit des opérations de recherche, insertion et suppression en O(log n).\nComparaison C/C++ : Un set correspond à un ensemble mathématique : valeurs sans doublons, ordre défini, et recherche rapide.\n\n\nInclude\nPour utiliser std::set il faut l’inclusion suivante :\n#include &lt;set&gt;\n\nEspace de nom\nLes ensembes set font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::set\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::set&lt;Type&gt; monSet;\n \n// exemple :\nstd::set&lt;int&gt; ensembleEntiers;\nstd::set&lt;std::string&gt; ensembleMots;\nInitialisation\n→ En C++98\nstd::set&lt;int&gt; s;\ns.insert(3);\ns.insert(1);\ns.insert(2);\ns.insert(3); // ignoré (doublon)\n→ En C++11 et plus\nstd::set&lt;int&gt; s = {3, 1, 2, 3}; // doublon ignoré automatiquement\n\n⚠️ L’initialisation avec {} n’est pas disponible en C++98, car elle nécessite std::initializer_list.\n\n\nImplémentation interne\nUn set&lt;T&gt; encapsule :\n\nun arbre rouge-noir triant automatiquement les éléments\nune valeur unique par nœud\nune logique d’ordre strict (operator&lt;) entre éléments\n\n\nL’ensemble set est un dictionnaire map sans valeur associée : chaque élément est à la fois la clé et la valeur.\n\n\nEnsemble et mémoire\nChaque élément est stocké dans un nœud alloué dynamiquement, avec pointeurs vers ses voisins dans l’arbre.\nL’ordre est garanti, mais les éléments ne sont pas contigus en mémoire, donc les performances cache sont moindres.\nL’allocation est plus coûteuse que dans un vecteur vector, mais permet des opérations efficaces sur les éléments triés et sans doublon.\n\nQuand et pourquoi utiliser un ensemble\nUn ensemble set est idéal pour stocker des éléments uniques triés automatiquement.\nIl convient parfaitement pour :\n\néliminer les doublons\nfaire des tests d’appartenance rapides\nparcourir des données dans l’ordre\nimplémenter des ensembles mathématiques ou des index triés\n\nSa performance en O(log n) le rend utile même pour de grands volumes de données.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Nombre d’éléments présentsempty()Vérifie si l’ensemble est videcount(val)Retourne 1 si la valeur est présente, 0 sinonfind(val)Renvoie un itérateur vers la valeur si trouvée\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptioninsert(val)Ajoute val si elle n’est pas déjà présenteerase(val)Supprime val si elle est présenteerase(it)Supprime l’élément pointé par l’itérateurclear()Vide complètement l’ensemble\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs de début à fin (ordre trié)rbegin() / rend()Itérateurs inversés\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte un autre setswap()Échange deux ensembles\n\nRemarques importantes\n\nLes éléments sont uniques et triés automatiquement\nL’insertion d’un élément déjà présent n’a aucun effet\nLes éléments ne sont pas modifiables en place (car cela compromettrait le tri)\nset est efficace pour les tests d’appartenance et les opérations d’ensemble (intersection, union…)\n\n\nVariante : std::multiset\nLa std::multiset est une variante de set qui permet de stocker plusieurs occurrences identiques d’un même élément tout en conservant un ordre trié.\nElle repose sur la même structure (arbre rouge-noir), avec les mêmes performances (O(log n)), mais :\n\nelle autorise les doublons\nelle compte toutes les occurrences d’une même valeur\nelle est utile pour représenter un ensemble non strict, comme une collection triée avec répétitions\n\nLes fonctions count(), equal_range() et les itérateurs permettent de naviguer efficacement parmi les doublons.\n→ Voir la fiche dédiée: ensemble avec doublons"},"espace-de-noms":{"slug":"espace-de-noms","filePath":"espace de noms.md","title":"espace de noms","links":["C++","classe","fonction","bibliothèque","bibliothèque-standard-C++","compilation"],"tags":[],"content":"\nNom anglais: namespace\n\n\nUn espace de noms (ou namespace) permet en C++ de regrouper des noms (de fonctions, variables, classes, etc.) sous une même “étiquette” pour éviter les conflits entre différents morceaux de code.\nEn clair, les namespaces permettent d’utiliser des fonctions, classes ou types (provenant de bibliothèques différentes) mais ayant le même nom sans créer de conflit.\nComparaison C/C++ : En C, tous les noms sont globaux. En C++, les espaces de noms permettent de mieux organiser le code et de gérer les collisions de noms.\n\nPourquoi utiliser un namespace\nLes namespace sont utiles pour :\n\néviter les conflits de noms entre bibliothèques,\norganiser le code (par module, par fonctionnalité),\ncréer des éléments qui portent le même nom, mais dans des contextes différents.\n\nDéclarer un namespace\nExemple pour créer l’espace de nom monEspace :\nnamespace monEspace\n{\n    void afficher();\n    class Voiture;\n    int compteur;\n}\nOn peut ensuite accéder aux éléments avec le préfixe monEspace:: :\nmonEspace::afficher();\nLe namespace std\nTous les éléments de la bibliothèque standard C++ (comme cout, cin, string, vector, etc.) se trouvent dans le namespace std.\nC’est pourquoi on écrit :\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\nLa directive using namespace\nPour éviter d’écrire std:: partout, on peut utiliser la directive :\nusing namespace std;\n\nCette directive se place généralement :\n\njuste après les #include\nou avant le main() ou dans une fonction spécifique, selon ton besoin\nMais surtout pas dans les headers, les bibliothèques ou les fichiers partagés à grande échelle.\n\n\nCela permet d’accéder directement aux éléments sans préfixe :\ncout &lt;&lt; &quot;Bonjour&quot;; // fonctionne sans std::\n\n⚠️ Cette directive est pratique pour les petits programmes ou pour apprendre, mais déconseillée dans les projets sérieux (risques de conflit entre noms identiques dans différents namespace).\n\nExemple concret\nContexte du problème (sans namespace)\nImaginons deux bibliothèques différentes, LibMath et LibPhysique, qui contiennent toutes les deux une fonction calcul() :\n// Dans LibMath\nvoid calcul()\n{\n    std::cout &lt;&lt; &quot;Calcul mathématique&quot; &lt;&lt; std::endl;\n}\n \n// Dans LibPhysique\nvoid calcul()\n{\n    std::cout &lt;&lt; &quot;Calcul physique&quot; &lt;&lt; std::endl;\n}\nSi on inclut ces deux bibliothèques sans namespace, on obtient une erreur de compilation :\n\n❌ “la fonction calcul est définie deux fois”.\n\nSolution avec des namespace\nnamespace LibMath\n{\n    void calcul()\n    {\n        std::cout &lt;&lt; &quot;Calcul mathématique&quot; &lt;&lt; std::endl;\n    }\n}\n \nnamespace LibPhysique\n{\n    void calcul()\n    {\n        std::cout &lt;&lt; &quot;Calcul physique&quot; &lt;&lt; std::endl;\n    }\n}\nDans le code principal, on peut maintenant faire la distinction :\nLibMath::calcul();     // Affiche &quot;Calcul mathématique&quot;\nLibPhysique::calcul(); // Affiche &quot;Calcul physique&quot;\nPlus de conflit, car les fonctions sont maintenant dans des espaces de noms séparés.\n\nEn résumé : si deux bibliothèques définissent une fonction calcul(), un conflit apparaît.\nEn les plaçant dans namespace LibMath et namespace LibPhysique, on peut appeler LibMath::calcul() et LibPhysique::calcul() sans collision.\n"},"ex00":{"slug":"ex00","filePath":"ex00.md","title":"ex00","links":["objet","C++","allocation-dynamique-de-la-mémoire","classe","pile","tas"],"tags":[],"content":"\nCe premier exercice a pour objectif de nous faire comprendre la notion de portée d’un objet en C++ — c’est-à-dire où et combien de temps un objet existe dans le programme —, ainsi que de nous faire manipuler l’allocation dynamique de la mémoire, une technique essentielle pour créer des objets qui survivent au-delà d’un bloc ou d’une fonction.\n\nLa pile (stack) et le tas (heap)\nCet exercice nous amène à créer une classe, puis deux fonctions qui retourneront un objet de cette classe :\n\nl’une en déclarant l’objet sur la pile\nl’autre en allouant l’objet sur le tas\n\n→ Pour implémenter cette seconde version, il faudra nous familiariser avec l’allocation dynamique de la mémoire en C++ (new, delete, etc).\nPortée d’un objet en C++\nPar défaut, un objet déclaré sans new possède une durée de vie limitée au bloc ({}) dans lequel il a été créé.\nIl est automatiquement détruit à la fin de ce bloc, ce qui implique que l’objet retourné par une fonction ne sera plus valide une fois la fonction terminée.\nVous pourrez le constater en ajoutant un message dans le destructeur : celui-ci s’exécutera immédiatement à la fin de la fonction, et non à la fin du programme.\n→ Pour utiliser un objet au-delà du bloc dans lequel il a été créé, on doit recourir à l’allocation dynamique de la mémoire.\nL’objet créé dans la deuxième fonction (celle qui utilise new) continuera d’exister en dehors de la fonction et ne sera détruit qu’à la fin du programme (ou lorsqu’on appelle explicitement delete).\n→ N’oubliez pas d’utiliser explicitement delete sur l’objet qui a été alloué dynamiquement avant de quitter le programme pour éviter les fuites de mémoire."},"ex01":{"slug":"ex01","filePath":"ex01.md","title":"ex01","links":["C++","allocation-dynamique-de-la-mémoire"],"tags":[],"content":"\nCet exercice rapide vise à nous faire découvrir l’utilisation de new[] et delete[].\n\nAllocation et libération de tableaux\nEn C++, il est possible d’effectuer une allocation dynamique de la mémoire sur un tableau entier en une seule ligne, en utilisant l’opérateur new[] :\nint* tableau = new int[10];\nPour libérer correctement la mémoire ainsi allouée, il faut utiliser delete[] :\ndelete[] tableau;\n→ Ne jamais utiliser delete seul pour un tableau alloué avec new[] — cela entraînerait un comportement indéfini."},"ex02":{"slug":"ex02","filePath":"ex02.md","title":"ex02","links":["référence","C++","pointeur"],"tags":[],"content":"\nCet exercice a pour but de nous faire découvrir les références en C++ et de comprendre la différence entre :\n\nle passage par valeur\nle passage par pointeur\nle passage par référence\n\n\nPassage par valeur\n\nLa fonction reçoit une copie de la variable: Toute modification s’applique à la copie, pas à l’original.\n\nvoid increment(int n) {\n\tn = n + 1;  // on modifie une copie\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 2\n}\n→ Ici, nbr reste à 2, car la fonction a travaillé sur une copie temporaire.\nPassage par pointeur\n\nAvec le pointeur, la fonction reçoit l’adresse de la variable.\nEn déréférençant le pointeur (*), elle peut modifier directement la valeur d’origine.\n\nvoid increment(int* n) {\n\t*n = *n + 1;  // on modifie la valeur pointée\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(&amp;nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 3\n}\n→ Il faut appeler la fonction avec &amp;nbr pour passer l’adresse de la variable.\nPassage par référence\n\nLa fonction reçoit une référence (un alias) de la variable: Elle peut la modifier comme si elle travaillait sur l’original, sans syntaxe de pointeur.\n\nvoid increment(int&amp; n) {\n\tn = n + 1;\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 3\n}\n→ Pas besoin de &amp; ou * à l’usage, la syntaxe reste simple et naturelle.\nRésumé comparatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormeModifie la variable d’origine ?Syntaxe simplePeut passer nullptr ?Par valeur❌ Non✅ Oui✅ Sans intérêtPar pointeur✅ Oui (avec *)❌ Non✅ OuiPar référence✅ Oui✅ Oui❌ Non"},"ex03":{"slug":"ex03","filePath":"ex03.md","title":"ex03","links":["référence","pointeur","toute","objet"],"tags":[],"content":"\nCet exercice a pour but de nous faire manipuler les références (vues à l’exercice précédent), de comprendre leurs différences par rapport aux pointeurs, et de savoir quand et pourquoi utiliser l’un ou l’autre.\n\nVous avez déjà à ce stade toutes les notions nécessaires pour réaliser l’exercice.\nGardez en tête que :\nPassage par référence\n\nSi je déclare une variable, puis que je la passe par référence à un objet, toute modification de cette variable se reflètera immédiatement dans l’objet, car ils partagent la même donnée.\nInversement, si je modifie la variable depuis l’objet qui détient une référence sur elle, alors la variable d’origine sera également modifiée.\n\nPassage par pointeur\nLe comportement est très similaire à une référence :\nSi je passe un pointeur vers une variable, et que l’objet stocke ce pointeur, alors :\n\nmodifier la variable à travers le pointeur la modifie bien à l’extérieur\net modifier la variable d’origine (hors de l’objet) sera visible dans l’objet\n\nMais attention :\n\nIl faut déréférencer (*) le pointeur pour accéder à la valeur\nIl est possible de changer le pointeur pour qu’il pointe ailleurs\nIl est possible d’avoir un pointeur nul, ce qui n’est pas possible avec une référence\n"},"ex04":{"slug":"ex04","filePath":"ex04.md","title":"ex04","links":["manipulation-de-fichier","string","bibliothèque-standard-C++","C++98","stat","C++","flux","ifstream","ofstream"],"tags":[],"content":"\nCet exercice a pour but de nous faire découvrir les bases de la manipulation de fichier en C++.\n\nContrôles d’usage\nIl nous faut en premier lieu effectuer les contrôles d’usage dans notre programme:\nVérifier le nombre d’arguments\n\nIl faut d’abord vérifier que le nombre d’arguments saisis au lancement du programme correspond au nombre attendu.\n\nVérifier que la chaine de caractère à remplacer soit non nulle\n\nIl faut ensuite vérifier que la chaîne de caractère à remplacer ne soit pas nulle (sous peine d’entrer dans une boucle infinie).\n\nL’objet de type string de la bibliothèque standard C++ dispose d’une méthode parfaite pour cela:\n→ empty() renvoie un booléen  (true si la chaine est vide)\nPour utiliser cette méthode, il suffit de créer un string à partir de l’argument passé en entrée (car cette argument est un type char *) puis de tester:\nstd::string argument2(argv[2]);\nif (argument2.empty())\n   // retourner une erreur\nVérifier que le fichier à ouvrir ne soit pas un répertoire\n\nIl faut vérifier que le fichier passé en argument ne soit pas un répertoire. En effet, si ouvre un répertoire à la place d’un fichier, tester si l’ouverture a réussi ne sera pas suffisant (car l’ouverture réussira).\n\nEn C++98, nous ne pouvons pas utiliser std::filesystem. Il nous faut donc utiliser une fonction de la bibliothèque  :\n→ stat de la bibliothèque sys/stat.h\nManipuler les fichiers\nLa manipulation des fichiers en C++passe par l’utilisation de flux:\n\nPour lire un fichier on utilise ifstream\nPour écrire dans un fichier on utilise ofstream\n"},"fichier-binaire":{"slug":"fichier-binaire","filePath":"fichier binaire.md","title":"fichier binaire","links":["/","système-d’exploitation","compilateur","code-source"],"tags":[],"content":"\nnom anglais: binary file\n\n\nUn fichier binaire (ou exécutable) est un fichier contenant des données codées directement en langage machine (des 0 et des 1), que l’ordinateur peut lire et exécuter sans avoir besoin de comprendre le code source.\n\nDans le contexte de la compilation, c’est le résultat final du travail du compilateur: un fichier prêt à être lancé par le système d’exploitation.\nEn résumé :\n\nC’est ce que produit un compilateur à partir du code source.\nIl est composé d’instructions machines que le processeur comprend directement.\nIllisible pour un humain sans outils spéciaux.\n\nExemples de fichiers binaires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlateformeExemple de binaireWindowsprogramme.exeLinux/Mac./programme (sans extension)\nPourquoi un fichier binaire?\n\nPour exécuter rapidement un programme sans besoin du code source.\nPour protéger le code source(l’utilisateur n’a accès qu’à la version machine).\nPour optimiser la vitesse d’exécution (car tout est déjà “pré-digéré” pour la machine).\n"},"file-FIFO":{"slug":"file-FIFO","filePath":"file FIFO.md","title":"file FIFO","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","conteneur-séquentiel","itérateur","STL","bibliothèque-standard-C++","nom-pleinement-qualifié","adaptateur-de-conteneur","file-double","liste","conteneur"],"tags":[],"content":"\nNom anglais: queue\nNom pleinement qualifié: std::queue\n\n\nUne queue est un conteneur adaptateur faisant partie des conteneur standard de la STLen C++. Elle implémente une file FIFO (First In, First Out) : les éléments sont insérés en fin de file et retirés par l’avant.\nContrairement aux conteneur séquentiels classiques, elle expose une interface restreinte (pas d’itérateur, pas d’accès aléatoire), et s’utilise dans les cas où l’on veut respecter strictement l’ordre d’arrivée des éléments.\n\n\nInclude\nPour utiliser std::queue il faut l’inclusion suivante :\n#include &lt;queue&gt;\n\nEspace de nom\nLes file FIFO queue font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::queue\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::queue&lt;Type&gt; maFile;\n \n// exemple :\nstd::queue&lt;int&gt; fileEntiers;\nstd::queue&lt;std::string&gt; fileMots;\nSpécification du conteneur sous-jacent\nstd::queue&lt;int, std::deque&lt;int&gt; &gt; q1; // par défaut\nstd::queue&lt;int, std::list&lt;int&gt; &gt;  q2; // alternatif\n\n⚠️ std::vector n’est pas autorisé car il ne permet pas de retirer efficacement en tête.\n\n\nImplémentation interne\nUne queue&lt;T&gt; est un adaptateur de conteneur encapsulant :\n\nun conteneur séquentiel (deque par défaut, list possible)\nune interface strictement FIFO :\n\npush() → insère à l’arrière\npop() → retire à l’avant\nfront() / back() → accède à l’extrémité concernée\n\n\n\n\nAucun itérateur n’est exposé : la file est une boîte noire FIFO.\n\n\nFile FIFO et mémoire\nLa gestion mémoire est déléguée au conteneur sous-jacent (file double deque ou liste list).\nChaque push() ajoute un élément à l’arrière ; chaque pop() libère le premier élément.\nCela garantit une gestion efficace dans les cas de flux de données, systèmes événementiels, ou ordonnancement.\n\nQuand et pourquoi utiliser file FIFO\nUne queue est idéale lorsqu’on veut traiter les éléments dans l’ordre exact où ils sont arrivés.\nElle s’utilise naturellement pour :\n\ndes systèmes de messagerie\ndes files d’attente de tâches\ndes processus asynchrones ou séquentiels\ntout algorithme où l’ordre d’insertion doit être strictement respecté\n\nC’est un modèle très courant dans les systèmes temps réel, les moteurs de règles ou les simulateurs.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionfront()Accès à l’élément en tête (le plus ancien)back()Accès à l’élément en queue (le plus récent)size()Nombre d’éléments présents dans la fileempty()Vérifie si la file est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush(val)Ajoute val à la fin de la filepop()Supprime l’élément en tête de file\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte une autre fileswap()Échange deux queue entre elles\n\nRemarques importantes\n\nstd::queue ne donne aucun accès à ses éléments internes sauf front() et back()\nPas d’itérateur → pas de begin(), pas de [], pas de parcours\nSon comportement dépend du conteneur sous-jacent, mais son interface est fixe\nC’est une abstraction simple mais puissante pour gérer des flux ordonnés\n"},"file-de-priorité":{"slug":"file-de-priorité","filePath":"file de priorité.md","title":"file de priorité","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","STL","bibliothèque-standard-C++","nom-pleinement-qualifié","foncteur","vecteur","itérateur"],"tags":[],"content":"\nNom anglais: priority queue\nNom pleinement qualifié: std::priority_queue\n\n\nUne priority_queue est un conteneur adaptateur faisant partie des conteneur standard de la STLen C++. Elle implémente une file de priorité : les éléments sont toujours triés de manière à ce que le plus prioritaire soit accessible en premier.\nPar défaut, les éléments sont organisés en max-heap (le plus grand en tête), selon l’ordre défini par operator&lt;.\n\n\nInclude\nPour utiliser std::priority_queue il faut l’inclusion suivante :\n#include &lt;queue&gt;\n\nEspace de nom\nLes files de priorité  priority_queue font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::priority_queue\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::priority_queue&lt;Type&gt; filePrio;\n \n// exemple :\nstd::priority_queue&lt;int&gt; scores;\nstd::priority_queue&lt;std::string&gt; mots;\nPersonnalisation du comparateur\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; minHeap;\n\nstd::greater&lt;T&gt; → transforme la file en min-heap\nOn peut aussi passer un foncteur personnalisé\n\n\nImplémentation interne\nUne priority_queue&lt;T&gt; encapsule :\n\nun vecteur std::vector&lt;T&gt; par défaut\nun algorithme make_heap, push_heap, pop_heap\nune organisation en tas binaire (max-heap par défaut)\n\n\nElle ne fournit pas d’itérateur ni d’accès aléatoire.\n\n\nPriority queue et mémoire\nLes éléments sont stockés dans un vecteur vector, réorganisé à chaque insertion ou suppression pour maintenir la propriété de tas.\nCela garantit :\n\nun accès rapide au maximum (top() en O(1))\ndes insertions et suppressions en O(log n)\n\n\nQuand et pourquoi utiliser une file de priorité\nUne file de priorité  priority_queue est idéale lorsqu’on doit toujours traiter l’élément ayant la plus haute priorité en premier, indépendamment de son ordre d’insertion.\nElle est utilisée pour :\n\ndes ordonnancements de tâches\ndes algorithmes gloutons (Dijkstra, A*, Huffman)\ndes systèmes de gestion d’événements par priorité\n\nSon comportement automatique permet de remplacer des tris manuels coûteux dans de nombreuses applications.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptiontop()Accès à l’élément prioritaire (le plus haut)size()Nombre d’éléments dans la fileempty()Vérifie si la file est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush(val)Ajoute val et réorganise la filepop()Retire l’élément le plus prioritaire\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte une autre file de prioritéswap()Échange deux priority_queue\n\nRemarques importantes\n\nPar défaut, c’est une max-heap (top() donne le plus grand)\nPour créer une min-heap, il faut passer std::greater&lt;T&gt; en troisième template paramètre\nAucun itérateur n’est fourni\nL’ordre d’insertion n’est pas conservé : seuls les niveaux de priorité comptent\nC’est un outil puissant pour gérer des flux où l’ordre n’est pas chronologique, mais stratégique\n"},"file-double":{"slug":"file-double","filePath":"file double.md","title":"file double","links":["conteneur-séquentiel","conteneur-standard-de-la-STL","C++","vecteur","STL","bibliothèque-standard-C++","nom-pleinement-qualifié","cache","liste","Itérateur","itérateur","conteneur-adaptateur","pile-algorithmique-LIFO","file-FIFO"],"tags":[],"content":"\nNom anglais: deque\nNom pleinement qualifié: std::deque\n\n\nUne file double deque (double-ended queue) est un conteneur séquentiel faisant partie des conteneur standard de la STL en C++. Elle permet une insertion et une suppression rapides en tête comme en queue, contrairement à un vecteur std::vector qui est optimisé uniquement pour l’arrière.\nElle combine certains avantages du vecteur vector (accès rapide par index) et de list (insertion rapide en début), au prix d’une structure interne plus complexe.\nLe nom deque est l’abréviation de double-ended queue, ce qui signifie en français : file à double extrémité\nComparaison C/C++ : Une deque est l’équivalent d’un tableau dynamique à deux extrémités, qui permet de croître ou décroître efficacement aux deux bouts.\n\n\nInclude\nPour utiliser std::deque il faut l’inclusion suivante :\n#include &lt;deque&gt;\n\nEspace de nom\nLes files double dequefont partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::deque\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nPour déclarer une deque il faut utiliser la syntaxe suivante :\nstd::deque&lt;type&gt; myDeque;\n \n// exemple pour une deque d&#039;int :\nstd::deque&lt;int&gt; myIntDeque;\n \n// exemple pour une deque de std::string :\nstd::deque&lt;std::string&gt; myStringDeque;\n \n// exemple avec initialisation (C++98) :\nint arr[] = {1, 2, 3};\nstd::deque&lt;int&gt; myDeque(arr, arr + 3); // copie depuis un tableau\nInitialisation\n→ En C++98\nstd::deque&lt;int&gt; d1;                    // deque vide\nstd::deque&lt;int&gt; d2(5);                 // 5 éléments valant 0\nstd::deque&lt;int&gt; d3(5, 42);             // 5 éléments valant 42\nint arr[] = {1, 2, 3};\nstd::deque&lt;int&gt; d4(arr, arr + 3);      // depuis un tableau C\nstd::deque&lt;std::string&gt; d5(3, &quot;ok&quot;);   // 3 éléments &quot;ok&quot;\n→ En C++11 et plus\nstd::deque&lt;int&gt; d6 = {1, 2, 3};        // initialisation par liste\nstd::deque&lt;std::string&gt; d7{&quot;a&quot;, &quot;b&quot;};  // initialisation par accolades\nstd::deque&lt;int&gt; d8{10};               // un seul élément valant 10\nstd::deque&lt;int&gt; d9{10, 5};            // deux éléments : 10 et 5\n\n⚠️ L’initialisation par {} n’est pas disponible en C++98\n\n\nImplémentation interne\nUne deque&lt;T&gt; encapsule :\n\nun tableau segmenté (tableaux discontinus appelés blocs ou buffers)\nun système d’indexation pour accéder rapidement à chaque bloc\nune mémoire non contiguë, mais un accès logique en séquence\n\n\nContrairement à un vecteur vector, les éléments d’une file double deque ne sont pas tous en mémoire contiguë, mais l’accès par index reste O(1) grâce à une structure d’index intermédiaire.\n\n\nDeque et mémoire\nLa std::deque est conçue pour permettre des insertions et suppressions rapides aux deux extrémités. Pour cela, elle alloue la mémoire sous forme de blocs discontinus.\n\nAccès par index : rapide (O(1)) mais légèrement plus lent que vector\nInsertion/suppression en tête ou queue : très efficace (O(1) amorti)\nInsertion au milieu : coûteuse (O(n))\n\nContrairement à std::vector (un vecteur alloue toute sa mémoire d’un seul tenant), une file std::deque fonctionne comme un tableau de pointeurs vers des blocs de données, où :\n\nchaque bloc contient plusieurs éléments (souvent 512 ou 1024 octets selon l’implémentation)\nles blocs ne sont pas nécessairement adjacents en mémoire\non peut ajouter un nouveau bloc à gauche ou à droite rapidement\n\nLes performances en cache sont moindres par rapport à un vecteur mais meilleures qu’une liste.\n\nQuand et pourquoi utiliser une file double\nUne file (ou queue) est une structure adaptée aux situations où les données doivent être traitées dans l’ordre d’arrivée (FIFO – First In, First Out). Elle est particulièrement utile lorsqu’on doit gérer des tâches, des requêtes ou des événements dans l’ordre chronologique.\nPar exemple :\n\nune file d’attente de traitements\nune file de messages réseau\nou une file de jobs dans un système multitâche.\n\nLa file garantit que le premier élément inséré sera aussi le premier traité, ce qui correspond à de nombreux modèles de communication ou de programmation orientée événements.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Retourne le nombre d’élémentsempty()Vérifie si la deque est videoperator[]Accès direct sans vérificationat(index)Accès sécurisé (avec vérification)front() / back()Accès au premier / dernier élémentmax_size()Nombre maximal théorique d’éléments\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush_back(val)Ajoute val à la finpush_front(val)Ajoute val au débutpop_back()Supprime le dernier élémentpop_front()Supprime le premier élémentinsert(pos, val)Insère val à la position poserase(pos)Supprime l’élément à la position posclear()Vide complètement la deque\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs sur le début / fin de la dequerbegin() / rend()Itérateurs inversés\n\nLes itérateurs permettent un parcours séquentiel standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionassign(n, val)Remplit la deque avec n copies de valoperator=Affecte une autre deque\n\nRemarques importantes\n\nstd::deque est idéale pour des accès par index combinés à des ajouts en tête\nElle remplace avantageusement une liste ou un vecteur (list ou vector) dans des cas spécifiques\nLes insertions au milieu sont coûteuses (O(n)), comme pour vector\nLes éléments ne sont pas contigus, donc la deque n’est pas cache-friendly\n\n\nUtilisation comme base d’autres conteneurs\nLe std::deque est non seulement un conteneur séquentiel à part entière, mais il sert aussi de conteneur sous-jacent par défaut pour plusieurs conteneur adaptateurs de la STL :\n\nstd::stack : pour une pile algorithmique LIFO\nstd::queue : pour une file FIFO\n\nCela s’explique par sa capacité unique à insérer et retirer efficacement aux deux extrémités, ce que ne permet pas un vecteur vector.\nGrâce à cette flexibilité, deque est souvent préféré comme structure de support pour les structures d’accès restreint.\n\nIl est également possible de substituer deque par d’autres conteneurs compatibles (comme vector ou list), mais deque reste le choix par défaut recommandé.\n"},"flush":{"slug":"flush","filePath":"flush.md","title":"flush","links":["tampon-de-sortie","cout","cin","endl"],"tags":[],"content":"\nNom anglais: flush\n\n\nLe flush est l’opération qui consiste à vider le tampon de sortie, c’est-à-dire à envoyer immédiatement les données stockées vers leur destination (écran, fichier, etc.).\nComparaison C/C++ : En C, on utilise fflush(stdout). En C++, on peut utiliser std::flush ou std::endl (qui fait aussi un flush).\n\nPourquoi flusher ?\nPar défaut, cout utilise un tampon pour optimiser les performances.\nMais il peut arriver qu’on veuille forcer l’affichage immédiat, par exemple :\n\njuste avant une lecture avec std::cin (voir cin)\npour voir un message de débogage avant un crash\npour synchroniser la sortie avec une autre opération\n\nComment flusher en C++\nAvec std::endl (voir endl):\nstd::cout &lt;&lt; &quot;Message&quot; &lt;&lt; std::endl; // saut de ligne + flush\nAvec std::flush (sans saut de ligne) :\nstd::cout &lt;&lt; &quot;Attente utilisateur...&quot; &lt;&lt; std::flush;\nExemple\nstd::cout &lt;&lt; &quot;Chargement...&quot; &lt;&lt; std::flush;\n// attente, traitement, etc.\nSans flush, il est possible que &quot;Chargement...&quot; ne s’affiche pas tout de suite.\nRésumé\n\nFlusher, c’est forcer l’envoi immédiat des données du tampon de sortie vers la destination finale.\nEn C++, on utilise std::flush ou implicitement via std::endl.\n"},"flux-de-la-bibliothèque-standard":{"slug":"flux-de-la-bibliothèque-standard","filePath":"flux de la bibliothèque standard.md","title":"flux de la bibliothèque standard","links":["C++","objet","flux","programmation-orientée-objet","classe","STL","bibliothèque","bibliothèque-iostream","bibliothèque-fstream","bibliothèque-sstream","tampon","manipulateur-de-flux","itérateur"],"tags":[],"content":"\nNom anglais: standard streams\n\n\nLes flux de la bibliothèque standard C++ sont des objets de flux qui permettent de gérer l’entrée et la sortie de données de manière uniforme en programmation orientée objet  .\nIls reposent sur une hiérarchie de classes de la STL, et peuvent manipuler aussi bien l’entrée/sortie standard (écran, clavier) que les fichiers ou des chaînes de caractères.\n\n\nEspace de nom\nLes flux standards font partie de la bibliothèque standard C++, et sont donc définis dans l’espace de nom std.\nIls doivent être utilisés de cette façon :\n→ std::cout,  std::cin, etc\n\nPour éviter de préfixer chaque flux avec std::, on peut inclure :\n\n→ using namespace std\n⚠️ Cette pratique peut être acceptable dans de petits fichiers ou des exemples simples, mais elle est déconseillée dans les projets de grande taille (risque de conflits de noms avec d’autres bibliothèques).\n\nPrincipaux flux disponibles\nFlux standard (console)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::cinistreamLecture depuis l’entrée standard (clavier)std::coutostreamÉcriture vers la sortie standard (écran)std::cerrostreamÉcriture vers la sortie d’erreur immédiatestd::clogostreamÉcriture vers la sortie d’erreur tamponnée\n→ Voir la fiche dédiée bibliothèque iostream\nFlux de fichiers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::ifstreamistreamLecture depuis un fichierstd::ofstreamostreamÉcriture vers un fichierstd::fstreamiostreamLecture et écriture dans un fichier\n→ Voir la fiche dédiée bibliothèque fstream\nFlux de chaînes de caractères\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::istringstreamistreamLecture depuis une chaînestd::ostringstreamostreamÉcriture dans une chaînestd::stringstreamiostreamLecture et écriture dans une chaîne\n→ Voir la fiche dédiée bibliothèque sstream\n\nÉtats des flux\nChaque flux possède des méthodes pour vérifier son état :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeSignificationgood()Tout va bien (aucune erreur)eof()Fin de fichier atteintefail()Une erreur non fatale est survenue (ex: type incorrect)bad()Erreur grave sur le flux (ex: matériel)clear()Réinitialise l’état du flux\n\nExemple\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ifstream fichier(&quot;donnees.txt&quot;);\n    std::string ligne;\n \n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur d&#039;ouverture !&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    while (std::getline(fichier, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n}\n\nRemarques\n\nTous les flux utilisent des tampons pour améliorer les performances.\nIls peuvent être manipulés avec des manipulateur de flux comme std::endl, std::hex, std::setw, etc.\nIls reposent tous sur le concept d’itérateur implicite, permettant un usage fluide avec les types de données.\n"},"flux":{"slug":"flux","filePath":"flux.md","title":"flux","links":["C++","cout","cin","ofstream","bibliothèque-standard-C++","objet","flux-de-la-bibliothèque-standard"],"tags":[],"content":"\nNom anglais: stream\n\n\nUn flux est une abstraction en C++ qui représente une source ou une destination de données. Il permet de lire ou écrire des données de manière séquentielle, comme si elles coulaient dans un “tuyau”.\nComparaison C/C++ : En C, on utilise printf/scanf et les FILE*. En C++, on utilise des objets flux comme std::cout, std::cin, ou std::ifstream.\n\n\nTypes de flux en C++\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeDescriptionExempleFlux de sortiePour afficher des donnéesstd::coutFlux d’entréePour lire des donnéesstd::cinFlux de fichierPour lire ou écrire dans un fichierstd::ifstream, std::ofstream\n\nFonctionnement\nUn flux agit comme un tuyau entre le programme et une destination/source :\n\navec cout: std::cout envoie les données vers l’écran\navec cin: std::cin récupère des données depuis le clavier\navec ofstream: std::ofstream envoie les données dans un fichier\n\nExemple\n#include &lt;iostream&gt;\n \nstd::cout &lt;&lt; &quot;Nom : &quot;;\nstd::string nom;\nstd::cin &gt;&gt; nom;\nIci :\n\nstd::cout écrit dans le flux de sortie\nstd::cin lit depuis le flux d’entrée\n\n\nPrincipaux flux de la bibliothèque standard\nLa bibliothèque standard C++fournit plusieurs objets de flux prédéfinis, regroupés dans différents types selon leur usage :\nFlux standard (console)\n\nstd::cin : flux d’entrée standard (lecture depuis le clavier)\nstd::cout : flux de sortie standard (affichage à l’écran)\nstd::cerr : flux de sortie d’erreur non tamponnée (affichage immédiat des erreurs)\nstd::clog : flux de sortie d’erreur tamponnée (log ou messages d’état)\n\nFlux de fichiers\n\nstd::ifstream : flux d’entrée depuis un fichier\nstd::ofstream : flux de sortie vers un fichier\nstd::fstream : flux bidirectionnel (lecture/écriture dans un fichier)\n\nCes objets sont déclarés dans l’en-tête #include &lt;iostream&gt; (pour les flux standard) et #include &lt;fstream&gt; (pour les fichiers).\n\nTous ces flux reposent sur les classes de base std::istream, std::ostream, std::iostream, et std::fstream.\n\n→ Voir la fiche dédiée flux de la bibliothèque standard\n\nRésumé\n\nUn flux est un objet qui transporte des données entre le programme et une source ou une destination (écran, clavier, fichier, etc.).\nIl existe des flux d’entrée, de sortie, et de fichiers.\n"},"foncteur":{"slug":"foncteur","filePath":"foncteur.md","title":"foncteur","links":["C++","fonction","classe","surcharge","opérateur","STL","bibliothèque-algorithm"],"tags":[],"content":"\nNom anglais: functor\nNom complet: objet fonctionnel\n\n\nEn C++, un foncteur (ou objet fonctionnel) est un objet qui se comporte comme une fonction.\nIl s’agit d’une classe ou structure qui surcharge l’opérateur operator(), ce qui permet d’appeler une instance comme une fonction.\n\n\nExemple simple\nstruct EstPair {\n\tbool operator()(int n) const {\n\t\treturn n % 2 == 0;\n\t}\n};\n \nEstPair estPair;\nbool res = estPair(4); // true\n\nUtilisation typique\nLes foncteurs sont utilisés dans la STL avec les algorithmes de la bibliothèque algorithm comme sort, find_if, count_if, etc., pour fournir un comportement personnalisable.\nstd::sort(v.begin(), v.end(), EstPair()); // Utilise le foncteur comme critère de tri\n\nAvantages\n\nUn foncteur peut contenir un état (contrairement à une fonction simple).\nIl peut être réutilisable et configurable via ses attributs.\nIl peut être passé comme paramètre là où une fonction est attendue.\n\n\nComparaison avec d’autres approches\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypePeut contenir un étatPeut être passé comme paramètreSyntaxe conciseFonction❌ Non✅ Oui✅ OuiLambda✅ (via capture)✅ Oui✅ Très conciseFoncteur✅ Oui✅ Oui❌ Plus verbeuse\n\nRemarques\n\nUn foncteur peut être mutable ou const, selon la définition de operator().\nÀ partir de C++11, les lambdas sont souvent préférées pour leur concision, mais les foncteurs restent utiles pour des traitements complexes et réutilisables.\n"},"fonction-statique":{"slug":"fonction-statique","filePath":"fonction statique.md","title":"fonction statique","links":["membre-statique"],"tags":[],"content":"→ Voir la fiche : membre statique"},"fonction":{"slug":"fonction","filePath":"fonction.md","title":"fonction","links":["classe","méthode","C++"],"tags":[],"content":"\nNom anglais: function\n\n\nUne fonction est un bloc de code réutilisable qui accomplit une tâche précise. Elle peut prendre des paramètres en entrée, effectuer des opérations, et retourner une valeur.\nComparaison C/C++ : Les fonctions existent en C et en C++, mais en C++ elles peuvent aussi être membres d’une classe (on les appelle alors méthodes).\n\nDéfinir une fonction\nExemple :\nint addition(int a, int b)\n{\n    return a + b;\n}\n\nint : type de retour\naddition : nom de la fonction\nint a, int b : paramètres\nreturn : valeur retournée\n\nAppeler une fonction\nExemple d’utilisation :\nint resultat = addition(2, 3); // résultat = 5\nFonctions sans retour\nElle sera de type void:\nvoid afficherMessage()\n{\n    std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;\n}\nRésumé\n\n📌 Une fonction permet de nommer une action, de la réutiliser facilement, et de structurer ton programme.\nEn C++, les fonctions peuvent être libres ou membres d’une classe (dans ce cas, ce sont des méthodes).\n"},"forme-canonique-de-Coplien":{"slug":"forme-canonique-de-Coplien","filePath":"forme canonique de Coplien.md","title":"forme canonique de Coplien","links":["C++","méthode","classe","objet","constructeur-par-défaut","compilateur","constructeur-par-copie","opérateur-d'affectation","destructeur","C++11","rule-of-three","membre"],"tags":[],"content":"\nNom anglais : canonical form\n\n\nLa forme canonique (canonical form) en C++ est une convention de conception qui recommande d’implémenter systématiquement quatre méthodes fondamentales dans une classe.\nCes méthodes contrôlent la construction, la copie, l’affectation, et la destruction des objets, pour garantir un comportement sûr et prévisible.\n\n\nÀ 42, cette forme est explicitement exigée dans la majorité des projets C++.\n\n\nObjectif de la forme canonique\n\n\nPrévenir les effets indésirables lors des copies, affectations, ou destructions.\n\n\nContrôler finement ce qu’il se passe quand un objet est copié, assigné, ou détruit.\n\n\nFaciliter le debug, la maintenance, et la gestion des ressources (notamment lors de l’utilisation de pointeurs ou de mémoire dynamique).\n\n\n\nLes 4 méthodes de la forme canonique\n\n✅ Constructeur par défaut\nDéfinit comment un objet est créé sans argument.\nIl est indispensable pour instancier un objet simple, ou pour créer un tableau d’objets.\nMaClasse(); // pas de paramètres\n→ Voir la fiche dédiée : constructeur par défaut\n\n✅ Constructeur par copie\nDéfinit comment un objet est copié à partir d’un autre (passage par valeur, retour de fonction, etc.).\nMaClasse(const MaClasse&amp; other);\nSans ce constructeur, le compilateur en génère un par défaut — mais il fait une copie membre par membre, ce qui peut être dangereux avec des pointeurs.\n→ Voir la fiche dédiée : constructeur par copie\n\n✅ Opérateur d’affectation par copie\nDéfinit comment un objet déjà existant reçoit une copie d’un autre.\nMaClasse&amp; operator=(const MaClasse&amp; other);\nCe n’est pas la même chose que le constructeur par copie : ici, l’objet existe déjà.\nIl faut toujours vérifier l’auto-affectation (if (this != &amp;other)).\n→ Voir la fiche dédiée : opérateur d’affectation\n\n✅ Destructeur\nDéfinit ce qu’il se passe quand un objet sort de portée ou est détruit.\nPermet de libérer les ressources (mémoire dynamique, fichiers, sockets, etc.).\n~MaClasse();\nMême si le compilateur en génère un par défaut, il est indispensable de le redéfinir dès qu’il y a de l’allocation manuelle.\n→ Voir la fiche dédiée : destructeur\n\nBonnes pratiques\n\n\nImplémente toutes les méthodes canoniques même si certaines semblent inutiles au début.\n\n\nAppelle les méthodes dans l’ordre logique : constructeur → opérateur → destructeur.\n\n\nUtilise la liste d’initialisation dans les constructeurs.\n\n\nDans l’opérateur d’affectation, teste l’auto-affectation et retourne *this.\n\n\n\nÀ ne pas confondre avec…\nLa Rule of Three, qui est une généralisation de la forme canonique.\nEt en C++11 et au-delà, on parle aussi de la Rule of Five (ajout du move constructor et de l’opérateur de move).\n\nVoir aussi\n→ constructeur par défaut, constructeur par copie, opérateur d’affectation, destructeur, classe, objet, rule of three, membre.\nSouhaites-tu que je prépare maintenant les fiches correspondantes pour les 4 méthodes (si elles ne sont pas encore créées) ?"},"forme-canonique":{"slug":"forme-canonique","filePath":"forme canonique.md","title":"forme canonique","links":["C++","méthode","classe","objet","constructeur-par-défaut","compilateur","attribut","constructeur-par-copie","membre","opérateur-d’affectation-par-copie","opérateur-d'affectation-par-copie","bloc","destructeur","liste-d’initialisation","constructeur","this","C++11"],"tags":[],"content":"\nNom anglais : canonical form\n\n\nLa forme canonique (ou forme canonique de Coplien) en C++ est une convention de conception qui recommande d’implémenter systématiquement quatre méthodes fondamentales dans une classe.\nCes méthodes contrôlent la construction, la copie, l’affectation, et la destruction des objets, pour garantir un comportement sûr et prévisible.\nÀ 42, cette forme est explicitement exigée dans la majorité des projets C++.\n\n\nObjectif de la forme canonique\n\nPrévenir les effets indésirables lors des copies, affectations, ou destructions.\nContrôler finement ce qu’il se passe quand un objet est copié, assigné, ou détruit.\nFaciliter le debug, la maintenance, et la gestion des ressources (notamment lors de l’utilisation de pointeurs ou de mémoire dynamique).\n\n\nLes 4 méthodes de la forme canonique\nAfin de respecter la forme canonique, une classe doit implémenter 4 méthodes :\n1. Constructeur par défaut\nDéfinit comment un objet est créé sans argument. Il est indispensable pour instancier un objet simple, ou pour créer un tableau d’objets.\nMaClasse(); // pas de paramètres\n\nSi on n’implémente pas de constructeur par défaut, le compilateur en génère un automatiquement, mais uniquement s’il le peut, et il ne réalise aucune initialisation explicite des attributs.\nLes attributs non initialisés auront donc des valeurs indéterminées, sauf s’ils sont eux-mêmes des objets d’une classe : dans ce cas, leur propre constructeur par défaut sera appelé, et ils recevront les valeurs prévues par ce constructeur.\n\n→ Voir la fiche dédiée : constructeur par défaut\n2. Constructeur par copie\nDéfinit comment un objet est créé en étant copié à partir d’un autre (passage par valeur, retour de fonction, etc.).\nMaClasse(const MaClasse&amp; other);\n\nSi on n’implémente pas de constructeur par copie, le compilateur en génèrera un par défaut qui fera une copie membre par membre, ce qui fonctionne correctement pour les types simples, mais peut être dangereux pour les types complexes (pointeurs, ressources dynamiques, etc).\n\n→ Voir la fiche dédiée : constructeur par copie\n3. Opérateur d’affectation par copie\nDéfinit comment un objet déjà existant reçoit une copie d’un autre.\nMaClasse&amp; operator=(const MaClasse&amp; other);\nCe n’est pas la même chose que le constructeur par copie : ici, l’objet existe déjà, mais on va le modifier en lui affectant les valeurs d’un autre objet de même type.\n\nComme pour le constructeur par copie, si on n’implémente pas l’opérateur d’affectation par copie, le compilateur en génèrera un par défaut qui fera une copie membre par membre, ce qui fonctionne correctement pour les types simples, mais peut être dangereux pour les types complexes (pointeurs, ressources dynamiques, etc).\n\n→ Voir la fiche dédiée : opérateur d’affectation par copie\n4. Destructeur\nDéfinit ce qu’il se passe quand un objet sort de portée (c’est à dire lorsque le bloc ({}) dans lequel il a été déclaré se termine) ou est détruit.  Le destructeur permet de libérer les ressources (mémoire dynamique, fichiers, sockets, etc.).\n~MaClasse();\nSi le destructeur n’est pas implémenté, le compilateur en génèrera un par défaut, mais il est indispensable de le redéfinir dès qu’il y a de l’allocation manuelle de mémoire.\n→ Voir la fiche dédiée : destructeur\n\nBonnes pratiques\n\nImplémenter toutes les méthodes canoniques même si certaines semblent inutiles au début.\nAppeller les méthodes dans l’ordre logique : constructeur → opérateur → destructeur.\nUtiliser la liste d’initialisationdans les constructeurs.\nDans l’opérateur d’affectation par copie, tester l’auto-affectation et retourner *this (voir this).\n\n\nNe pas confondre avec la Rule of Three (règle des trois)\nLa Rule of Three est une généralisation de la forme canonique.  C’est une règle de conception C++ qui dit :\n\nSi on a besoin de définir l’un de ces trois éléments dans une classe, alors on doit probablement définir les deux autres :\n\nle destructeur\nle constructeur par copie\nl’opérateur d’affectation par copie\n\n\nParce que ces trois méthodes sont toutes liées à la gestion des ressources internes (pointeurs, fichiers, mémoire, etc.).  Si on en modifie une, les deux autres doivent gérer les mêmes ressources correctement, sous peine de :\n\nfuites mémoire\ndouble delete\naliasing indésirable\ncomportements indéfinis\n\nEt en C++11 et au-delà, on parle aussi de la Rule of Five (ajout du move constructor et de l’opérateur de move).\n\nVoir aussi\n→ Voir les fiches dédiées : constructeur par défaut, constructeur par copie, opérateur d’affectation par copie, destructeur, classe, objet, membre."},"getline":{"slug":"getline","filePath":"getline.md","title":"getline","links":["Nom-pleinement-qualifié","fonction","bibliothèque-standard-C++","flux","string","C++"],"tags":[],"content":"\nNom pleinement qualifié: std::getline\n\n\nstd::getline est une fonction de la bibliothèque standard C++ qui permet de lire une ligne complète de texte depuis un flux (comme std::cin) et de la stocker dans une string.\nContrairement à std::cin &gt;&gt;, elle ne s’arrête pas aux espaces mais lit jusqu’au caractère de fin de ligne (\\n).\nComparaison C/C++ : En C, on utilise fgets() pour lire une ligne entière. En C++, std::getline est plus sûre, plus flexible, et intégrée à std::string.\n\nSyntaxe\nstd::getline(source, destination);\n\nsource : un flux (souvent std::cin)\ndestination : une string dans laquelle stocker la ligne\n\nExemple simple\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::string nomComplet;\n    std::cout &lt;&lt; &quot;Entrez votre nom complet : &quot;;\n    std::getline(std::cin, nomComplet);\n    std::cout &lt;&lt; &quot;Bonjour &quot; &lt;&lt; nomComplet &lt;&lt; std::endl;\n    return 0;\n}\n\nCe code lit toute la ligne, même si elle contient des espaces.\n\nPourquoi utiliser std::getline ?\n\nPour lire des phrases complètes\nPour éviter que std::cin &gt;&gt; tronque la lecture après un espace\nPour mieux gérer les entrées utilisateur dans les programmes interactifs\n\nPiège du EOF\nLorsque l’utilisateur tape Ctrl+D sous Linux, cela génère un **EOF (End Of File), qui indique la fin de l’entrée standard.\nSi on appelle std::getline après l’EOF, la lecture échoue silencieusement : la chaîne n’est pas remplie, et le programme peut continuer avec une valeur vide.\nPour éviter les erreurs logiques (comme par exemple une boucle infinie), il est conseillé de tester l’état du flux avant d’utiliser la chaîne lue :\nstd::string ligne;\nif (std::getline(std::cin, ligne)) {\n    // OK : on peut utiliser `ligne`\n} else {\n    // Erreur ou fin de fichier\n}\n\nLe test if (std::getline(...)) est une manière sûre de détecter à la fois EOF et les erreurs de lecture.\n\nPièges du \\n\nSi on utilise std::cin &gt;&gt; juste avant std::getline, le caractère \\n laissé dans le flux par std::cin peut faire que std::getline lit une ligne vide.\nExemple du piège :\nint age;\nstd::cin &gt;&gt; age;         // saisie : 42\nstd::getline(std::cin, nom); // capte seulement le &#039;\\n&#039;\nSolution :\nAjouter une ligne pour vider le \\n :\nstd::cin.ignore();\nstd::getline(std::cin, nom);\nRésumé\n\nstd::getline permet de lire une ligne entière de texte dans une string, y compris les espaces.\nElle est indispensable dès qu’on attend une saisie textuelle libre, comme un nom complet, une phrase ou un message.\n"},"gmtime":{"slug":"gmtime","filePath":"gmtime.md","title":"gmtime","links":["bibliothèque-standard-C++"],"tags":[],"content":"\nNom pleinement qualifié : std::gmtime\n\n\nLa fonction gmtime de la bibliothèque standard C++ convertit un time_t (nombre de secondes) en une structure tm représentant la date UTC (temps universel).\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);\n    std::tm* utc = std::gmtime(&amp;now);\n \n    std::cout &lt;&lt; &quot;Année : &quot; &lt;&lt; 1900 + utc-&gt;tm_year &lt;&lt; std::endl;\n}\n\nRetourne un pointeur vers une structure tm remplie avec l’heure en temps universel (UTC).\n\nUsage concret\n\nRécupérer les composants de la date : année, mois, jour, heure, etc.\nUtiliser avec strftime pour formater la date\n"},"héritage":{"slug":"héritage","filePath":"héritage.md","title":"héritage","links":["programmation-orientée-objet","classe","objet","classe-de-base","classe-dérivée"],"tags":[],"content":"\nNom anglais: inheritance\n\n\nL’héritage est un principe fondamental de la programmation orientée objet qui permet de créer une nouvelle classe en réutilisant les éléments d’une classe existante. Cela permet de construire des hiérarchies d’objets partageant des caractéristiques communes.\nComparaison avec le C: Le langage C n’a pas de mécanisme d’héritage natif. En C++, l’héritage permet de structurer et de réutiliser du code de manière plus propre et plus naturelle.\n\nPourquoi utiliser l’héritage\nL’héritage permet :\n\nde réutiliser le code existant,\nde organiser les classes en familles logiques,\nde spécialiser ou compléter des comportements existants.\n\nOn parle souvent de classe de base (ou de base) et de classe dérivée (ou dérivée).\nDéfinir un héritage\nOn utilise le symbole : suivi du mot-clé d’accès (public, private, ou protected) :\nclass Vehicule\n{\npublic:\n    void demarrer();\n};\n \nclass Voiture : public Vehicule\n{\npublic:\n    void ouvrirCoffre();\n};\nIci, Voiture hérite de Vehicule.\nVoiture possède donc la méthode demarrer() en plus de ses propres méthodes.\nTypes d’héritage\n\npublic : les éléments publics restent publics pour l’enfant.\nprotected : les éléments publics deviennent protégés pour l’enfant.\nprivate : les éléments hérités deviennent privés pour l’enfant.\n\nLe plus courant est l’héritage public.\nExemple\nVoiture v;\nv.demarrer();     // hérité de Vehicule\nv.ouvrirCoffre(); // défini dans Voiture\nL’objet v peut utiliser à la fois ce qu’il a hérité et ce qui a été ajouté."},"ifstream":{"slug":"ifstream","filePath":"ifstream.md","title":"ifstream","links":["classe","bibliothèque-standard-C++","flux","C++","getline","Méthode"],"tags":[],"content":"\nNom pleinement qualifié : std::ifstream\n\n\nstd::ifstream (input file stream) est une classe de la bibliothèque standard C++ qui permet de lire des fichiers texte ou binaires.\nC’est un flux en lecture, analogue à std::cin, mais connecté à un fichier.\nComparaison C / C++: En langage C, on utilise les fonctions comme fopen(), fgets(), fscanf() ou fclose() pour manipuler des fichiers. Ces fonctions nécessitent de gérer manuellement les pointeurs, les buffers de lecture (char[]) et les erreurs, ce qui les rend plus verbeuses et moins sûres. En C++, std::ifstream offre une interface orientée objet, qui fonctionne naturellement avec les types de la bibliothèque standard C++ (comme std::string), et qui permet une lecture plus lisible, plus sûre, et mieux intégrée au langage. La gestion des fichiers repose sur le principe du RAII : le fichier est automatiquement fermé quand l’objet std::ifstream sort de sa portée.\n\nInclude\nstd::ifstream appartient à la bibliothèque standard C++. Il faut mettre l’include:\n#include &lt;ifstream&gt;\nDéclaration et ouverture du fichier\nstd::ifstream fichier(&quot;nom.txt&quot;); // ouverture à la déclaration\nOu bien en deux étapes :\nstd::ifstream fichier;\nfichier.open(&quot;nom.txt&quot;);\nVérification d’ouverture\nToujours tester l’état du fichier :\nif (!fichier) {\n    std::cerr &lt;&lt; &quot;Erreur : impossible d’ouvrir le fichier.&quot; &lt;&lt; std::endl;\n}\nLecture de contenu\nLire ligne par ligne avec getline:\nstd::string ligne;\nwhile (std::getline(fichier, ligne)) {\n    std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n}\nLire mot par mot :\nstd::string mot;\nwhile (fichier &gt;&gt; mot) {\n    std::cout &lt;&lt; mot &lt;&lt; std::endl;\n}\nLire caractère par caractère :\nchar c;\nwhile (fichier.get(c)) {\n    std::cout &lt;&lt; c;\n}\nMéthodes utiles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeRôleopen(&quot;nom&quot;)Ouvre un fichieris_open()Vérifie si le fichier est ouvertclose()Ferme le fichiergetline(ifs, str)Lit une ligne entièreeof()Teste si fin de fichier atteintefail()Teste si une erreur est survenuegood()Teste si le flux est encore utilisable\nExemple complet\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ifstream fichier(&quot;donnees.txt&quot;);\n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur : impossible d’ouvrir le fichier.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    std::string ligne;\n    while (std::getline(fichier, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n \n    fichier.close(); // facultatif\n    return 0;\n}"},"inclusion-de-fichiers":{"slug":"inclusion-de-fichiers","filePath":"inclusion de fichiers.md","title":"inclusion de fichiers","links":["bibliothèque-standard","système-d’exploitation"],"tags":[],"content":"Qu’est-ce que l’inclusion de fichier en C++?\n\nEn C++, l’inclusion permet d’ajouter du contenu externe (définitions de fonctions, classes, constantes…) dans ton fichier source.\n\nCela se fait avec la directive :\n#include\nSyntaxes possibles\nIl existe deux formes d’inclusion :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntaxeUtilisationExemple#include &lt;fichier&gt;Inclure un fichier standard du système (bibliothèque standard)#include &lt;iostream&gt;#include &quot;fichier&quot;Inclure un fichier personnel (header)#include &quot;mon_header.hpp&quot;\nDifférences entre &lt;...&gt; et &quot;...&quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormeDétail&lt;fichier&gt;Le compilateur cherche dans les répertoires système uniquement pour utiliser une bibliothèque standard.&quot;fichier&quot;Le compilateur cherche d’abord dans le répertoire du projet (un header), puis dans les répertoires système si non trouvé.\nExemples :\n\n&lt;iostream&gt; ➔ trouvé dans /usr/include ou /Library/Developer/CommandLineTools/usr/include/ (dépend du système d’exploitation).\n&quot;fonctions.hpp&quot; ➔ trouvé dans un dossier personnel (ex: /projet/include/).\n\nPourquoi inclure des fichiers ?\n\nUtiliser des bibliothèques standards (iostream, vector, string, etc.).\nOrganiser ton projet en plusieurs fichiers (fonctions.hpp, fonctions.cpp, etc.).\nRéutiliser du code sans tout réécrire.\n\nExemple concret\nFichier fonctions.hpp :\n#ifndef FONCTIONS_HPP\n#define FONCTIONS_HPP\n \nint addition(int a, int b);\n \n#endif\nFichier fonctions.cpp :\n#include &quot;fonctions.hpp&quot;\n \nint addition(int a, int b) {\n    return a + b;\n}\nFichier main.cpp :\n#include &lt;iostream&gt;\n#include &quot;fonctions.hpp&quot;\n \nint main() {\n    std::cout &lt;&lt; addition(2, 3) &lt;&lt; std::endl;\n    return 0;\n}\nAttention : éviter les inclusions multiples\nSi un fichier est inclus plusieurs fois, cela peut provoquer des erreurs.\n➔ Solution : protéger avec un include guard ou utiliser #pragma once.\nMéthode classique (include guards) :\n#ifndef MON_FICHIER_HPP\n#define MON_FICHIER_HPP\n \n// Contenu du header\n \n#endif\nMéthode moderne :\n#pragma once\n(Équivalent à l’include guard mais plus simple.)\n\n🔥 Résumé ultra rapide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPoint cléRésuméButRéutiliser du code sans le réécrire&lt;...&gt;Cherche dans les bibliothèques système&quot;...&quot;Cherche d’abord dans ton projetProtégerUtiliser #ifndef/#define/#endif ou #pragma once\n\nVeux-tu aussi que je te prépare un exemple réel d’architecture de projet C++ montrant plusieurs fichiers et inclusions (include/, src/, etc.) ? 🚀\n(Ça te donnerait une base propre à recopier pour n’importe quel futur projet !)"},"index":{"slug":"index","filePath":"index.md","title":"index","links":["C++","langage-compilé","C++11","Module_00","Module_01","Module_02"],"tags":[],"content":"Cette collection d’articles constitue une initiation au langage C++ tel que je l’ai appris durant le tronc commun de l’école42.\nA qui s’adressent ces articles?\nPrincipalement aux étudiants de 42 qui sont dans le quatrième cercle du tronc commun et qui commencent leur apprentissage du C++.\nMais ces articles peuvent intéresser toute personne désireuse d’apprendre le C++ à condition de respecter le pré-requis suivants:\n\n→ Disposer de connaissances minimales en langage C.\n\nSi vous ne disposez pas des notions de base en C, vous trouverez quelques notions expliquées à partir de l’article sur ce qu’est un langage compilé, mais cette documentation reste pour l’heure très parcellaire.\nCe que ne sont pas ces articles\nCes articles présentent les concepts à connaître pour réaliser les différents module C++ de 42. Ils ne donnent pas directement les solutions aux exercices.\nVous ne trouverez donc ni code complet, ni les fichiers que j’ai moi-même écrits lors de mon cursus.\nComment sont organisés les articles?\nLes articles sont organisés par modules et par exercices; c’est à dire qu’ils présentent et expliquent les notions à connaître afin de réaliser chaque exercice de chaque module C++ du cursus 42.\nIls sont donc classés de manière progressive afin de “coller” à la pédagogie par projet de l’école 42.\nVersions du C++\nL’utilisation du C++11est interdit pour les premiers modules de découverte du C++ à l’école 42. Seul les outils offerts par le C++98 seront abordés pour répondre aux besoins de ces exercices.\nSommaire\n\nModule_00\nModule_01\nModule_02\n"},"interface-graphique":{"slug":"interface-graphique","filePath":"interface graphique.md","title":"interface graphique","links":[],"tags":[],"content":"Qu’est-ce que?"},"interpréteur-de-commande":{"slug":"interpréteur-de-commande","filePath":"interpréteur de commande.md","title":"interpréteur de commande","links":["terminal","système-d’exploitation","scripts","syntaxe"],"tags":[],"content":"Qu’est-ce qu’un interpréteur de commmande?\n\nUn interpréteur de commandes est un programme qui reçoit les instructions que l’utilisateur tape dans un terminal, les interprète et les exécute.\nC’est lui qui comprend des commandes comme ls, cd, mkdir, et qui demande au système d’exploitationde faire les actions correspondantes.\n\nEn résumé\n\nL’utilisateur écrit une commande ➔ l’interpréteur la traduit ➔ l’ordinateur l’exécute.\nC’est l’interface entre l’utilisateur et le système, via du texte.\nIl peut aussi exécuter des scripts (séries de commandes automatisées).\n\nExemples d’interpréteurs de commandes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpréteurCaractéristiquebashLe plus courant sur Linux et macOSzshPlus moderne, utilisé par défaut sur macOS récentfishTrès convivial et intelligentcmd.exeAncien interpréteur de WindowsPowerShellInterpréteur avancé de Windows, plus moderne\nÀ retenir\n\nLe terminal affiche ➔ l’interpréteur comprend et agit.\nbash par exemple (ou zsh, ou fish) est un interpréteur de commande, pas un terminal.\nChaque interpréteur a ses petites différences de syntaxe et ses scripts propres.\n"},"interpréteur":{"slug":"interpréteur","filePath":"interpréteur.md","title":"interpréteur","links":["code-source","fichier-binaire","compilation","débogage"],"tags":[],"content":"Qu’est-ce qu’un interpréteur?\n\nUn interpréteur est un programme qui lit le code source d’un autre programme ligne par ligne, le traduit immédiatement et l’exécute directement sans créer d’exécutable (pas de fichier binaire).\nCela permet de tester rapidement du code sans passer par une étape de compilation.\n\nEn résumé\n\nLit et exécute le code en temps réel.\nPas d’exécutable intermédiaire (pas de fichier binaire) contrairement à la compilation.\nUtile pour le développement rapide et le débogage.\n\nExemples d’interpréteurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpréteurLangagepythonPythonnodeJavaScript (côté serveur)rubyRuby\nÀ retenir\n\nAvec un interpréteur, le code source est exécuté directement.\nCela rend l’exécution plus flexible, mais souvent moins rapide qu’un programme compilé.\n\nExemple\npython mon_script.py\n    ```"},"itérateur":{"slug":"itérateur","filePath":"itérateur.md","title":"itérateur","links":["conteneur","algorithmes-STL","STL"],"tags":[],"content":"\nNom anglais: iterator\n\n\nUn itérateur est un objet spécial qui permet de parcourir les éléments d’un conteneur (comme un std::vector, std::list, etc.).\nC’est l’équivalent en C++ de “pointeurs intelligents” qui permettent d’accéder aux éléments sans connaître leur structure interne.\nComparaison C/C++ : en C, on utilise des pointeurs pour parcourir un tableau. En C++, on utilise des itérateurs pour parcourir un conteneur.\n\nÀ quoi ça sert ?\nUn itérateur sert à :\n\nParcourir un conteneur du début à la fin (ou dans l’autre sens)\nLire ou modifier les valeurs contenues\nUtiliser les algorithmes STL (std::sort, std::find, etc.)\nNe pas dépendre du type ou de la structure du conteneur\n\nSyntaxe de base\nImaginons un std::vector v que l’on veut parcourir avec une boucle foren utilisant unn itérateur :\nstd::vector&lt;int&gt; v = {10, 20, 30};\n \nfor (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n\nv.begin() → itérateur vers le premier élément\nv.end() → itérateur vers la fin (non valide) du conteneur\n*it → accède à l’élément pointé\n++it → avance vers l’élément suivant\n\n📚 Types d’itérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeDescriptioniteratorLecture + écritureconst_iteratorLecture seulereverse_iteratorParcours en sens inverseconst_reverse_iteratorParcours inverse en lecture seuleauto (depuis C++11)Déduit automatiquement le type de l’itérateur\nExemples d’utilisation\nLecture avec auto\nfor (auto it = v.begin(); it != v.end(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\nLecture seule (const)\nfor (std::vector&lt;int&gt;::const_iterator it = v.cbegin(); it != v.cend(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\nParcours inverse\nfor (auto rit = v.rbegin(); rit != v.rend(); ++rit) {\n\tstd::cout &lt;&lt; *rit &lt;&lt; std::endl;\n}\n⚠️ Attention\n\nv.end() ne pointe pas vers le dernier élément, mais un cran après\nNe pas faire *v.end() ➝ comportement indéfini\nModifier un conteneur pendant qu’on le parcourt invalide les itérateurs\n\nRésumé\n\nLes itérateurs sont essentiels en C++ pour parcourir proprement les conteneurs de la STL.\nIls agissent comme des pointeurs génériques et sûrs, et sont compatibles avec les algorithmes STL.\n"},"langage-compilé":{"slug":"langage-compilé","filePath":"langage compilé.md","title":"langage compilé","links":["code-source","fichier-binaire","/","compilation","langage-interprété"],"tags":[],"content":"Qu’est ce qu’un langage compilé\n\nUn langage compilé est un langage de programmation dont le code source doit être traduit en un fichier exécutable (fichier binaire) par un compilateur (processus de compilation) avant de pouvoir être lancé par l’ordinateur.\n\nDifférences avec un langage interprété\nContrairement à un langage interprété (comme Python ou JavaScript), qui est lu et exécuté ligne par ligne par un interpréteur, un langage compilé transforme tout le programme d’un coup en un fichier machine optimisé, ce qui rend son exécution plus rapide.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLangage compiléLangage interprétéCode transformé avant l’exécutionCode exécuté directementBesoin d’un compilateur (g++, clang++)Besoin d’un interpréteur (Python, Node.js)Exécution rapideExécution plus lenteExemples : C, C++, RustExemples : Python, JavaScript"},"langage-interprété":{"slug":"langage-interprété","filePath":"langage interprété.md","title":"langage interprété","links":["code-source","interpréteur","compilation"],"tags":[],"content":"Qu’est-ce qu’un langage interprété?\n\nUn langage interprété est un langage où le code sourceest lu et exécuté directement, ligne par ligne, par un interpréteur sans passer par une phase de compilation complète.\n\nCela rend le développement souvent plus rapide (pas besoin de compiler), mais l’exécution du programme est généralement plus lente qu’avec un langage compilé, car chaque instruction est traduite à la volée pendant que le programme tourne.\nExemples de langages interprétés\n\nPython\nJavaScript\nRuby\nPHP\n"},"lecture-et-écriture-de-fichiers-en-C++":{"slug":"lecture-et-écriture-de-fichiers-en-C++","filePath":"lecture et écriture de fichiers en C++.md","title":"lecture et écriture de fichiers en C++","links":["C++98","manipulation-de-position-dans-les-fichiers"],"tags":[],"content":"\nNom pleinement qualifié: fstream (lecture et écriture de fichiers en C++)\n\n\nEn C++98, la gestion des fichiers se fait grâce aux classes de la bibliothèque &lt;fstream&gt;.\nOn peut ouvrir, lire, écrire et fermer des fichiers avec des objets de type ifstream, ofstream ou fstream.\nComparaison C/C++ : contrairement à fopen() en C, le C++ propose une interface orientée objet, plus sûre et intuitive, pour manipuler les fichiers.\n\nInclude\nPour lire ou écrire un fichier, il faut inclure :\n#include &lt;fstream&gt;\nClasses principales\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClasseRôlestd::ifstreamLecture uniquement (input file stream)std::ofstreamÉcriture uniquement (output file stream)std::fstreamLecture et écriture\nOuvrir un fichier\nstd::ifstream in(&quot;monfichier.txt&quot;);   // ouverture en lecture\nstd::ofstream out(&quot;resultat.txt&quot;);    // ouverture en écriture\nstd::fstream file(&quot;donnees.txt&quot;, std::ios::in | std::ios::out); // lecture/écriture\n⚠️ Tu peux aussi ouvrir le fichier plus tard avec .open() :\nstd::ifstream fichier;\nfichier.open(&quot;exemple.txt&quot;);\nLecture simple ligne par ligne\nstd::ifstream in(&quot;texte.txt&quot;);\nstd::string ligne;\n \nwhile (std::getline(in, ligne)) {\n\tstd::cout &lt;&lt; ligne &lt;&lt; std::endl;\n}\nin.close();\nÉcriture dans un fichier\nstd::ofstream out(&quot;log.txt&quot;);\n \nout &lt;&lt; &quot;Ceci est une ligne.&quot; &lt;&lt; std::endl;\nout &lt;&lt; &quot;Encore une autre.&quot; &lt;&lt; std::endl;\n \nout.close();\nVérification d’ouverture\nToujours vérifier si un fichier est bien ouvert :\nstd::ifstream in(&quot;config.txt&quot;);\nif (!in) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d&#039;ouvrir le fichier.&quot; &lt;&lt; std::endl;\n}\nModes d’ouverture (std::ios)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeSignificationstd::ios::inLecturestd::ios::outÉcriture (efface le fichier existant)std::ios::appAjout à la fin (append)std::ios::truncTronque le fichier existant (défaut en out)std::ios::binaryMode binaire (par défaut = texte)\n⚠️ Attention\n\nNe pas oublier de fermer le fichier (.close())\nToujours vérifier l’ouverture avec if (!fichier)\nL’ouverture en std::ios::out efface le fichier existant par défaut\n\nManipulation de position\nPour les manipulations de position du curseur de lecture dans un fichier :\n→ voir l’article manipulation de position dans les fichiers.\nRésumé\n\nEn C++98, la lecture/écriture de fichiers passe par ifstream, ofstream et fstream.\nIl faut inclure &lt;fstream&gt;, utiliser les bons modes (ios::in, ios::out, etc.),\net toujours vérifier que le fichier est bien ouvert.\n"},"liste-d'initialisation":{"slug":"liste-d'initialisation","filePath":"liste d'initialisation.md","title":"liste d'initialisation","links":["C++","constructeur","attribut","objet","fonction","référence","constructeur-par-défaut","structure","classe"],"tags":[],"content":"\nNom anglais : member initializer list\n\n\nUne liste d’initialisation en C++ est une syntaxe spéciale utilisée dans les constructeurs pour initialiser directement les attributs d’un objet, avant même l’exécution du corps de la fonction.\nElle permet de garantir une initialisation efficace, sûre et déterministe, notamment pour les attributs constants (const), les références, ou les objets sans constructeur par défaut.\nComparaison C/C++ : En C, les champs d’une structure sont souvent initialisés par affectation (=) après déclaration. En C++, on préfère les initialiser dès la construction à l’aide d’une liste d’initialisation, ce qui évite des appels inutiles à des constructeur par défaut ou des copies.\n\n\nSyntaxe d’une liste d’initialisation\nUne liste d’initialisation suit la signature du constructeur et précède le corps de la fonction ({}) :\nNomDeLaClasse::NomDeLaClasse(type1 arg1, type2 arg2)\n    : attribut1(valeur1), attribut2(valeur2)\n{\n    // corps du constructeur (souvent vide si tout est initialisé avant)\n}\n\nRègles de syntaxe\n\nChaque attribut est suivi de parenthèses contenant la valeur à lui attribuer : attribut(valeur).\nLes initialisations sont séparées par des virgules.\nLa liste d’initialisation commence par un : après la signature du constructeur.\nLe corps du constructeur est placé ensuite entre accolades {}, même s’il est vide.\n\n\nExemple\nclass Voiture {\nprivate:\n    std::string _marque;\n    int _vitesse;\n    const int _id;\n \npublic:\n    Voiture(std::string marque, int vitesse, int id)\n        : _marque(marque), _vitesse(vitesse), _id(id) {}\n};\n\nPourquoi utiliser une liste d’initialisation ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRaisonExplicationEfficacitéÉvite une double opération (construction par défaut + affectation)Obligatoire pour certains membresLes const, les reference, et les membres sans constructeur par défaut doivent être initialisés ainsiAppelle directement le bon constructeurUtile pour les objets membres d’autres classesCohérence et lisibilitéCentralise la logique d’initialisation en un seul endroit\n\nMauvais exemple (affectation dans le corps)\nVoiture::Voiture(std::string marque, int vitesse, int id)\n{\n    _marque = marque;\n    _vitesse = vitesse;\n    _id = id; // ❌ Erreur : _id est const et ne peut être affecté\n}\n⚠️ Ici :\n\n_marque et _vitesse sont d’abord construits par défaut, puis réassignés.\n_id cause une erreur car on ne peut pas affecter une const après construction.\n\n\nBonnes pratiques\n\nToujours préférer la liste d’initialisation pour les types complexes, les const, les reference, les classes personnalisées.\nRéserver l’affectation dans le corps uniquement à la logique métier (c’est à dire si ça fait partie de la raison d’être du programme) ou aux cas exceptionnels.\n\n\nVoir aussi\n→ constructeur, attribut,  référence, objet"},"liste":{"slug":"liste","filePath":"liste.md","title":"liste","links":["conteneur","STL","C++","bibliothèque-standard-C++","nom-pleinement-qualifié","itérateur","cache","allocateur"],"tags":[],"content":"\nNom anglais: list\nNom pleinement qualifié: std::list\n\n\nUne list est un conteneur séquentiel fourni par la STL en C++. Elle permet de stocker des éléments dans une liste doublement chaînée, où chaque élément connaît son précédent et son suivant.\nElle offre des performances optimales pour les insertions et suppressions n’importe où dans la séquence, mais au prix d’un accès plus lent aux éléments par position.\nComparaison C/C++ : Une list est une version sécurisée et généralisée d’une liste chaînée en C. Elle gère :\n\nla mémoire dynamiquement\nles liens entre les éléments\nles cas limites (début/fin) automatiquement\n\n\n\nInclude\nPour utiliser std::list il faut l’inclusion suivante :\n#include &lt;list&gt;\n\nEspace de nom\nLes listes font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::list\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nPour déclarer une list il faut utiliser la syntaxe suivante :\nstd::list&lt;type&gt; myList;\n \n// exemple pour une liste d&#039;int :\nstd::list&lt;int&gt; myIntList;\n \n// exemple pour une liste de std::string :\nstd::list&lt;std::string&gt; myStringList;\n \n// exemple avec initialisation (C++98) :\nint arr[] = {1, 2, 3};\nstd::list&lt;int&gt; myList(arr, arr + 3); // copie depuis un tableau\nInitialisation\n→ En C++98\nstd::list&lt;int&gt; l1;                     // liste vide\nstd::list&lt;int&gt; l2(5);                  // 5 éléments initialisés à 0\nstd::list&lt;int&gt; l3(5, 42);              // 5 éléments valant 42\nint arr[] = {1, 2, 3};\nstd::list&lt;int&gt; l4(arr, arr + 3);       // copie depuis un tableau C\nstd::list&lt;std::string&gt; l5(3, &quot;ok&quot;);    // 3 éléments contenant &quot;ok&quot;\n→ En C++11 et plus\nstd::list&lt;int&gt; l6 = {1, 2, 3};         // initialisation par liste\nstd::list&lt;std::string&gt; l7{&quot;a&quot;, &quot;b&quot;};   // initialisation par accolades\nstd::list&lt;int&gt; l8{10};                // une seule valeur : 10\nstd::list&lt;int&gt; l9{10, 5};             // deux valeurs : 10 et 5\n\n⚠️ Attention : contrairement à std::vector, il n’y a aucune ambiguïté sur {10, 5} pour std::list (même en C++11), car la syntaxe liste n’est pas surchargée pour compter des éléments.\n\n\nImplémentation interne\nUne list&lt;T&gt; encapsule :\n\nune liste doublement chaînée\ndes nœuds alloués dynamiquement, chaque nœud contenant :\n\nun pointeur vers l’élément précédent\nun pointeur vers l’élément suivant\nla valeur elle-même\n\n\nun pointeur vers le début et la fin de la liste\n\n\nContrairement à un vector, une list ne stocke pas les éléments en mémoire contiguë.\n\n\nListe et mémoire\nLa std::list utilise une structure en nœuds reliés dynamiquement, ce qui signifie :\n\nles éléments ne sont pas adjacents en mémoire\nles accès par index sont lents (O(n))\nmais les insertions et suppressions en n’importe quelle position sont rapides (O(1) avec un itérateur)\n\nCela la rend peu efficace vis-à-vis du cache, mais très souple pour des opérations complexes sur des séquences.\nLa mémoire est allouée nœud par nœud, et chaque insertion implique un appel à new (ou à l’allocateur).\n\nQuand et pourquoi utiliser une liste\nUne liste (std::list) est particulièrement adaptée aux situations où l’on effectue de nombreuses insertions ou suppressions en milieu de séquence, ou lorsque la position des éléments est gérée via des itérateurs plutôt que des indices. Grâce à sa structure en liste doublement chaînée, elle permet ces opérations en temps constant (O(1)) dès lors qu’on dispose de l’itérateur correspondant. Elle est utile lorsque la performance d’accès par index n’est pas cruciale, mais que la flexibilité de modification de la structure est primordiale (par exemple, dans les éditeurs de texte, moteurs de règles, ou gestion dynamique d’éléments).\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Retourne le nombre d’élémentsempty()Vérifie si la liste est videfront() / back()Accès au premier / dernier élémentmax_size()Nombre maximal théorique d’éléments (implémentation dépendante)\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush_back(val)Ajoute un élément à la finpush_front(val)Ajoute un élément au débutpop_back()Supprime le dernier élémentpop_front()Supprime le premier élémentinsert(pos, val)Insère val à la position poserase(pos)Supprime l’élément à la position posclear()Supprime tous les élémentsremove(val)Supprime toutes les occurrences de valremove_if(pred)Supprime tous les éléments pour lesquels pred est vrai\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs sur le début / fin de la listerbegin() / rend()Itérateurs inversés\n\nLes itérateurs permettent un parcours standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionassign(n, val)Remplit la liste avec n copies de valoperator=Affecte une autre liste\nOpérations spécifiques aux listes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsort()Trie la listemerge(other)Fusionne avec une autre liste triéereverse()Inverse l’ordre des élémentsunique()Supprime les doublons consécutifssplice(pos, other)Déplace les éléments d’une autre liste\n\nRemarques importantes\n\nstd::list est idéale si le programme requiert de nombreuses insertions et suppressions au milieu\nLes accès par index sont très lents (O(n)) car il n’y a pas d’accès direct\nLes itérateurs sont stables : ils restent valides tant que l’élément n’est pas supprimé\nContrairement à vector, list n’est pas cache-friendly car les éléments sont dispersés en mémoire\n"},"lowerCamelCase":{"slug":"lowerCamelCase","filePath":"lowerCamelCase.md","title":"lowerCamelCase","links":["convention-de-nommage","fonction","méthode","variable","attribut","variable-locale","privé","protégé","C++"],"tags":[],"content":"\nNom anglais: lowerCamelCase\n\n\nLe lowerCamelCase est une convention de nommage utilisée pour nommer les fonctions, méthodes, variables ou attributs.\nLe premier mot commence par une minuscule, puis chaque mot suivant commence par une majuscule, et les mots sont collés sans séparateurs.\n\n\nExemples\nint compteurTotal;\nvoid afficherResultat();\nstd::string nomFichier;\n\nUsage en C++\nLa convention de nommage lowerCamelCase est généralement utilisée pour :\n\nfonction void\nméthode de classe\nvariable locale\nattribut privé ou protégé (parfois avec suffixe _)\n\n\nComparaison avec d’autres styles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyleExempleUsage typiqueUpperCamelCaseMaClasseClasses, typeslowerCamelCasemaVariableFonctions, variables, méthodessnake_casema_variableVariables (C), fichiersSCREAMING_SNAKE_CASETAILLE_MAXConstantes, macros\n\nRésumé\n\nLe lowerCamelCase est un style d’écriture en C++ où le premier mot est en minuscule, et les suivants commencent par une majuscule.\nIl permet de différencier visuellement les fonctions et variables des types (class, struct, etc.) tout en gardant une écriture compacte et lisible.\n"},"macro":{"slug":"macro","filePath":"macro.md","title":"macro","links":["compilation","fonction","bloc","compilateur","C++","surcharge"],"tags":[],"content":"\nNom anglais : macro\n\n\nUne macro est une instruction du préprocesseur (et non du compilateur) qui permet de substituer du texte avant la compilation.\nLes macros sont définies avec la directive #define et peuvent servir à définir des constantes, des fonctions simples ou des blocs conditionnels.\nComparaison C/C++: les macros existent dans les deux langages.\n\nSyntaxe\n#define NOM valeur\n#define CARRE(x) ((x) * (x))\n\nNOM sera remplacé partout dans le code source par valeur\nCARRE(x) sera remplacé par ((x) * (x))\n\nExemples\n#define PI 3.14159\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n \nint rayon = 5;\nfloat surface = PI * rayon * rayon;\nÀ savoir\n\nContrairement aux fonctions normales en C/C++, les macros sont des substitutions textuelles*, réalisées par le préprocesseur, avant la compilation. Elles ne sont pas vérifiées par le compilateur comme des fonctions typées.\n\n\nLes macros sont traitées avant la compilation (phase de préprocesseur)\nElles ne respectent pas le typage : attention aux erreurs inattendues\nEn C++, on préfère souvent utiliser const ou inline à la place des macros\n\nConséquences\n\nPas de vérification de type :\nLe compilateur n’exige pas que les arguments aient un type précis, car pour lui ce ne sont que des morceaux de texte.\nPas de surcharge :\nOn ne peut pas faire de macro “différente” pour int, float, etc.\nComportements inattendus si mal protégée :\nSi on oublie des parenthèses, le résultat peut changer selon les priorités d’opérateurs.\n\nExemple problématique\n#define CARRE(x) x * x\n \nint a = 3 + 1;\nint res = CARRE(a);  // devient : 3 + 1 * 3 + 1 = 3 + 3 + 1 = 7 \n→ Le résultat devrait être 16, mais on obtient 7 à cause de l’ordre des opérations.\nBonne pratique :\n#define CARRE(x) ((x) * (x))  // encapsuler chaque argument\nComparaison avec inline\ninline int carre(int x) { return x * x; }\n\nvérifie que x est bien un int\névite les erreurs d’ordre de priorité\nrespecte les règles de type et de portée\n\nRésumé\n\nLes macros sont des outils puissants mais bas niveau pour remplacer du code automatiquement avant la compilation.\nElles sont utiles pour les valeurs constantes, les tests conditionnels (#ifdef, #ifndef), ou les fonctions simples sans surcharge.\n"},"manipulateur-de-flux":{"slug":"manipulateur-de-flux","filePath":"manipulateur de flux.md","title":"manipulateur de flux","links":["bibliothèque-standard-C++","flux","cout","C++","objet","fonction","flush","Flush"],"tags":[],"content":"\nNom anglais: stream manipulator\n\n\nUn manipulateur de flux est une fonction spéciale fournie par la bibliothèque standard C++ que l’on peut insérer dans un flux (comme std::cout - voir cout) pour modifier son comportement ou formater l’affichage, sans écrire de fonction personnalisée.\nIl s’utilise comme une valeur, mais il agit sur le flux.\nComparaison C/C++: En C, il n’existe pas de manipulateurs de flux — l’affichage se fait uniquement via des fonctions comme printf() qui utilisent des modificateurs de format (comme %d, %f, \\n, etc.) dans la chaîne de caractères. En C++ les manipulateurs de flux (comme std::endl, std::setw, std::hex…) sont des objets/fonctions spécialisés insérés dans un flux (std::cout) pour modifier son comportement ou formater l’affichage.\n\nExemples courants\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManipulateurEffet principalstd::endlSaut de ligne + flushstd::flushFlush (sans saut de ligne)std::setw(n)Fixe la largeur du champstd::setprecision(n)Fixe le nombre de chiffres affichésstd::hex, std::dec, std::octChange la base d’affichage des entiers\nUtilisation\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt; // pour setw, setprecision, etc.\n \nstd::cout &lt;&lt; std::setw(10) &lt;&lt; 42;      // affiche &quot;        42&quot;\nstd::cout &lt;&lt; std::setprecision(3) &lt;&lt; 3.14159; // affiche &quot;3.14&quot;\nstd::cout &lt;&lt; std::hex &lt;&lt; 255;         // affiche &quot;ff&quot;\nIls sont insérés directement dans la chaîne d’affichage, comme des instructions discrètes.\nRésumé\n\nUn manipulateur de flux est une fonction standard utilisée dans un flux pour contrôler l’affichage, formater les données ou déclencher des actions (comme  flush).\nIls rendent le code plus lisible et puissant.\n"},"manipulation-de-position-dans-les-fichiers":{"slug":"manipulation-de-position-dans-les-fichiers","filePath":"manipulation de position dans les fichiers.md","title":"manipulation de position dans les fichiers","links":["C++98"],"tags":[],"content":"\nNom pleinement qualifié: manipulation de position dans les fichiers (seekg, seekp, tellg, tellp)\n\n\nEn C++98, les flux de fichiers permettent de manipuler la position du curseur de lecture (get) ou d’écriture (put).\nCela permet par exemple de sauter des parties d’un fichier, d’aller à la fin, ou de revenir au début.\n\nInclude\n#include &lt;fstream&gt;\nFonctions principales\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionseekg(pos)Déplace le curseur de lecture (get position)seekp(pos)Déplace le curseur d’écriture (put position)tellg()Renvoie la position actuelle du curseur de lecturetellp()Renvoie la position actuelle du curseur d’écriture\n📥 Lecture : seekg et tellg\nstd::ifstream in(&quot;texte.txt&quot;);\n \nin.seekg(0); // retourne au début\nstd::streampos pos = in.tellg(); // position actuelle (0)\n \nin.seekg(10); // va au 10e octet\nchar c;\nin &gt;&gt; c;\nstd::cout &lt;&lt; &quot;Caractère à la position 10 : &quot; &lt;&lt; c &lt;&lt; std::endl;\n \nin.close();\n📝 Écriture : seekp et tellp\nstd::ofstream out(&quot;donnees.txt&quot;);\n \nout.seekp(5); // écrit à partir du 6e octet\nout &lt;&lt; &quot;X&quot;;\n \nstd::streampos p = out.tellp();\nstd::cout &lt;&lt; &quot;Position actuelle : &quot; &lt;&lt; p &lt;&lt; std::endl;\n \nout.close();\n🎯 Avec offset (second argument facultatif)\nLes fonctions seekg et seekp acceptent un décalage (offset) et un point de départ :\nin.seekg(0, std::ios::beg); // début\nin.seekg(-2, std::ios::end); // 2 octets avant la fin\nin.seekg(5, std::ios::cur); // 5 octets après la position actuelle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstanteSignificationstd::ios::begDepuis le début du fichierstd::ios::curDepuis la position actuellestd::ios::endDepuis la fin du fichier\n⚠️ Attention\n\nCes fonctions manipulent des positions en octets, pas en caractères.\nSur les fichiers texte, certains comportements peuvent dépendre du système (ex: \\r\\n).\nElles ne fonctionnent pas toujours de manière fiable en mode texte → préférer mode binaire (std::ios::binary) pour un positionnement précis.\n\nRésumé\n\n📌 En C++98, tu peux manipuler la position dans un fichier avec seekg, seekp, tellg, tellp.\nCela te donne un contrôle précis du curseur de lecture ou d’écriture, utile pour naviguer dans un fichier sans tout lire/sauter.\n"},"membre-statique":{"slug":"membre-statique","filePath":"membre statique.md","title":"membre statique","links":["attribut","méthode","classe","membre","objet","C++98","publique","opérateur","fonction","this","privé","protégé"],"tags":[],"content":"\nNom anglais: static member\n\n\nUn membre statique (ou membre de classe) est un attribut ou une méthode déclaré avec le mot-clé static à l’intérieur d’une classe.\nContrairement aux membres ordinaires, un membre statique n’appartient pas à une instance (pas à un objet) mais à la classe elle-même.\nIl est partagé par toutes les instances de cette classe.\n\n\nAttribut statique\nUn attribut statique est une variable commune à toutes les instances. Il n’existe qu’en une seule copie, peu importe le nombre d’objets créés.\n\nContrairement à un attribut classique, un attribut statique n’existe qu’en un seul exemplaire, partagé par tous les objets de la classe.\nAinsi, si sa valeur est modifiée — que ce soit depuis un objet ou directement depuis la classe — cette modification affecte tous les objets, car ils accèdent tous à la même variable partagée.\n\nDéclaration\nIl est déclaré avec le mot clé static\nclass Compteur {\npublic:\n    static int totalObjets;\n};\nInitialisation\nIl faut ensuite l’initialiser en dehors de la classe (obligatoire en C++98). Lors de l’initialisation, on ne répète pas le mot clé static :\nint Compteur::totalObjets = 0;\nAccès\nIl peut être lu ou modifié sans créer d’objet à condition d’être déclaré dans la partie publique de la classe. On y accède avec la syntaxe suivante :\nNomDeLaClasse::nomDeLAttributStatique\n \n// exemple :\nstd::cout &lt;&lt; Compteur::totalObjets &lt;&lt; std::endl;\n\nL’accès à un attribut statique via un objet suivi de l’opérateur . est autorisé, mais déconseillé :  on préfère toujours passer par NomDeLaClasse::attribut.\n\n\nMéthode statique\nUne méthode statique est une fonction associée à la classe, et non à un objet particulier.\n\nUne méthode statique ne peut pas accéder aux attributs non statiques (car elle ne reçoit aucun this).\n\nDéclaration\nLe prototype de fonction est déclaré dans la classe précédée du mot clé static :\nclass Util {\npublic:\n    static void direBonjour();\n};\nDéfinition\nLa fonction est ensuite définie comme d’habitude, sans le mot clé static :\nvoid Util::direBonjour() {\n    std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;\n}\nUne méthode statique peut également être définie directement à l’intérieur de la classe (si le corps est court). Elle est alors considérée comme inline :\nclass Util {\npublic:\n\tstatic void direBonjour() {std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;}\n};\nAccès\nSi la méthode est déclarée dans la partie publique de la classe, elle peut être appelée directement via le nom de la classe suivi de ::, sans créer d’objet :\nUtil::direBonjour(); // accessible uniquement si la méthode est publique\n\nSi la méthode est privée ou protégée, elle reste accessible sans objet, mais uniquement depuis l’intérieur de la classe (ou de ses classes dérivées pour protected).\n\n\nUsages courants\n\nSuivre un compteur global d’instances créées\nFournir une fonction utilitaire liée à la classe\nPartager des paramètres ou ressources communs\nCréer des “singletons” ou des objets uniques\n\n\nRécapitulatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉlémentStatique ?Accessible via objet ?Accessible via classe ?Attributouioui (mais déconseillé)ouiMéthodeouinonouiAttributnonouinonMéthodenonouinon\n\nRemarques\n\nUn membre statique est souvent accompagné d’une initialisation hors de la classe, sauf s’il est const de type primitif.\nL’accès à un membre statique via un objet est autorisé mais pas recommandé (préférer MaClasse::membre).\n\n\nNe pas confondre : membre statique vs variable ou fonction statique\nAttention: Le mot-clé static peut désigner des notions très différentes selon le contexte. Il est donc essentiel de ne pas confondre ces notions qui sont complètement différentes de la notion de membre statique, bien qu’elles utilisent le même mot-clé static :\n\nvariable statique\nfonction statique\n\n1. Variable statique locale (dans une fonction)\n\nUne variable static déclarée à l’intérieur d’une fonction conserve sa valeur entre les appels, mais reste invisible à l’extérieur.\n\nvoid compteur() {\n    static int appel = 0;  // persiste entre les appels\n    appel++;\n}\n2. Fonction statique libre (fichier .cpp)\n\nUne fonction déclarée static en dehors d’une classe, dans un fichier .cpp, a une liaison interne (internal linkage) :\nelle est limitée au fichier et ne peut pas être appelée d’un autre fichier.\n\nstatic void helper() {\n    // fonction visible uniquement dans ce fichier .cpp\n}\n\nVoir aussi\n→ classe, attribut, méthode, objet"},"membre":{"slug":"membre","filePath":"membre.md","title":"membre","links":["classe","attribut","méthode","C++","objet","type-interne","classe-imbriquée","contrôles-d'accès","privé","publique","membre"],"tags":[],"content":"\nNom anglais: member\n\n\nUn membre est un élément qui appartient à une classe ou à une structure (struct). En C++, un membre peut être un attribut, une méthode, ou même un type interne.\nComparaison C/C++ : En C, les membres d’une struct sont uniquement des variables. En C++, les membres peuvent être des données ou des fonctions.\n\nTypes de membres en C++\n\nattribut : un membre qui représente une variable de l’objet.\nméthode : un membre qui est une fonction liée à l’objet.\ntype interne : comme une classe imbriquée).\n\nExemple\nclass Voiture\n{\nprivate:\n    int vitesse;        // membre (attribut)\npublic:\n    void demarrer();    // membre (méthode)\n};\nDans Voiture, vitesse et demarrer() sont des membres.\nRésumé\nUn membre est tout ce qui est contenu dans une classe ou une struct.\nLes contrôles d’accès(privé ou publique) définissent qui peut voir ou utiliser les membres."},"mutateur":{"slug":"mutateur","filePath":"mutateur.md","title":"mutateur","links":["méthode","classe","attribut","privé"],"tags":[],"content":"\nNom anglais: setter / mutator\n\n\nUn mutateur (setter) est une méthode spéciale d’une classe qui permet de modifier la valeur d’un attribut privé de manière contrôlée.\nComparaison avec le C: En C, on modifie directement les membres d’une structure. En C++, on utilise des mutateurs pour encadrer et sécuriser la modification des données.\n\nPourquoi utiliser un mutateur\nLes attributs sont généralement protégés en privé. Un mutateur fournit un moyen encadré pour modifier ces valeurs, en permettant par exemple d’ajouter des vérifications avant l’affectation.\nDéfinir un mutateur\nUn mutateur est une méthode publique qui prend une valeur en paramètre et l’assigne à un attribut privé :\nclass Voiture\n{\nprivate:\n    int vitesse;\n \npublic:\n    void setVitesse(int nouvelleVitesse)\n    {\n        vitesse = nouvelleVitesse;\n    }\n};\nLe mutateur setVitesse permet de modifier la vitesse de l’objet.\nUtiliser un mutateur\nPour utiliser un mutateur :\nVoiture v;\nv.setVitesse(120);\nCela modifie la valeur de vitesse de l’objet v de manière sécurisée.\nExemple\nUn mutateur classique suit la convention de nommage setNomDeLAttribut :\n\nsetCouleur(string c)\nsetMarque(string m)\nsetVitesse(int v)\n\nChacun permet de modifier l’attribut correspondant."},"méthode-virtuelle":{"slug":"méthode-virtuelle","filePath":"méthode virtuelle.md","title":"méthode virtuelle","links":[],"tags":[],"content":""},"méthode":{"slug":"méthode","filePath":"méthode.md","title":"méthode","links":["fonction","membre","classe","objet","structure","C++","attribut","this","publique","privé","protégé","organisation-des-fichiers-d'une-classe","méthode","membre-statique","constructeur","liste-d'initialisation","surcharge","destructeur","encapsulation","accesseur","mutateur","compilateur","surcharge-de-fonction","classe-dérivée","polymorphisme","méthode-virtuelle","méthode-statique","méthode-const","programmation-orientée-objet","Accesseur"],"tags":[],"content":"\nNom anglais : method / member function\n\n\nUne méthode est une fonction membre d’une classe. Elle permet de définir un comportement que chaque objet issu de cette classe pourra exécuter.\nComparaison C/C++ : En C, les fonctions sont séparées des structures. En C++, une méthode est liée à une classe et peut accéder aux attributs de l’objet grâce au pointeur this.\n\n\nMéthodes et classes\nLes méthodes sont déclarées dans la classe et permettent aux objets d’effectuer des actions, de manipuler leurs attributs ou d’interagir avec d’autres objets.\nclass Voiture {\nprivate:\n    int _vitesse;\n \npublic:\n    void accelerer();       // déclaration de méthode\n    void freiner();         // autre méthode\n};\n\nDéclaration et définition d’une méthode\nUne méthode est généralement déclarée (via son prototype) à l’intérieur de la classe, dans la section publique, privée ou protégée selon le niveau d’accès souhaité.\nElle peut ensuite être définie (c’est-à-dire implémentée) de deux façons :\n\ndirectement dans la classe (définition inline), ce qui est possible mais souvent déconseillé pour les méthodes non triviales\nen dehors de la classe, généralement dans le fichier .cpp, en la précédant du nom de la classe suivi de ::\n\n// Définition de la méthode accelerer dans le fichier .cpp\nvoid Voiture::accelerer() {\n    _vitesse += 10;\n}\n\nCela permet de séparer clairement l’interface (dans le .hpp) et l’implémentation (dans le .cpp), ce qui est une bonne pratique (et une exigence à 42).\n\n→ Voir la fiche dédiée : organisation des fichiers d’une classe\n\nAppel d’une méthode\nOn appelle une méthode via un objet en utilisant l’opérateur .\nVoiture v;\nv.accelerer(); // appel de la méthode accelerer sur l’objet v\n\nMéthodes et accès aux attributs\nUne méthode peut accéder :\n\naux attributs privés ou protégés de sa propre classe\nà d’autres méthodes ou attributs via le pointeur implicite this\n\n\nMéthodes constantes\nUne méthode constante est une méthode qui ne modifie pas l’état de l’objet sur lequel elle est appelée. On la déclare en ajoutant le mot-clé const après la parenthèse de la signature.\nSi une méthode ne modifie pas l’état de l’objet, elle peut (et doit) être marquée const. Cela signifie que la méthode ne peut pas modifier les attributs de l’objet, ni appeler d’autres méthodes non const.\nLes méthodes constantes peuvent être appelées sur des objets const, ce qui est impossible pour une méthode non marquée const.\nint getVitesse() const; // garantit de ne pas modifier l&#039;objet *this\n\nMéthodes statiques\nUne méthode statique appartient à la classe elle-même, et non à un objet particulier.\nElle ne peut pas accéder aux attributs non statiques, car elle ne reçoit pas de pointeur this.\nclass Outils {\npublic:\n    static void aide(); // méthode statique\n};\n \nOutils::aide(); // appel sans objet\n→ Voir la fiche dédiée : membre statique\n\nConstructeurs\nUn constructeur est une méthode spéciale appelée automatiquement à la création d’un objet.\nIl initialise les attributs et peut utiliser une liste d’initialisation.\nVoiture::Voiture(int v) : _vitesse(v) {}\nIl peut exister plusieurs constructeurs, avec des paramètres différents (voir surcharge).\n→ Voir la fiche dédiée : constructeur\n\nDestructeurs\nUn destructeur est une méthode spéciale appelée automatiquement à la destruction de l’objet.\nIl permet de libérer des ressources (mémoire, fichiers…).\n~Voiture(); // syntaxe\n→ Voir la fiche dédiée : destructeur\n\nAccesseurs et mutateurs\nCe sont des méthodes déclarés en section publique (public), qui permettent d’accéder aux attributs privés ou protégés de manière contrôlée en respectant l’encapsulation.\n\nUn accesseur (getter) permet de lire la valeur d’un attribut.\nUn mutateur (setter) permet de modifier sa valeur.\n\nExemple :\nclass Personne {\nprivate:\n    std::string _nom;\n \npublic:\n    // Setter : modifie la valeur de _nom\n    void setNom(const std::string&amp; nom) {\n        _nom = nom;\n    }\n    // Getter : retourne la valeur de _nom\n    const std::string&amp; getNom() const {\n        return _nom;\n    }\n};\n→ Voir les fiches dédiées : accesseur, mutateur\n\nSurcharge de méthode\nLe C++ autorise plusieurs méthodes avec le même nom mais des signatures différentes (nombre ou type de paramètres). Le compilateur choisit automatiquement la plus adaptées en fonction des arguments passés lors de l’appel.\n// méthode sans argument :\nvoid afficher();        \n \n// surcharge: méthode supplémentaire de même nom, avec un paramètre de type std::string :\nvoid afficher(std::string nom);  \n→ Voir les fiches dédiées : surcharge et surcharge de fonction\n\nMéthodes virtuelles\nUne méthode virtuelle est une méthode qui peut être redéfinie dans une classe dérivée.\nElle permet le polymorphisme en C++.\nvirtual void parler();\n→ Voir la fiche dédiée : méthode virtuelle\n\nVoir aussi\n→ classe, objet, fonction, attribut, constructeur, destructeur, accesseur, mutateur, méthode statique, méthode virtuelle, méthode const, surcharge de fonction, polymorphisme\nSouhaites-tu que je te génère maintenant une fiche spécifique pour l’une des méthodes particulières listées ici ?\n\n\nNom anglais: method\n\n\n\nUne méthode est une fonction définie à l’intérieur d’une classe. Elle décrit une action qu’un objet peut effectuer ou une opération qu’il peut subir.\nComparaison avec le C: En C, on définit des fonctions indépendantes. En C++, les méthodes sont attachées à des objets et peuvent agir directement sur leurs attributs.\n\nRôle des méthodes\nLes méthodes permettent aux objets :\n\nd’interagir avec leurs propres attributs,\nde réaliser des comportements spécifiques,\nde répondre à des actions extérieures.\n\nLes méthodes font partie intégrante de ce qui rend la programmation orientée objet si puissante. Elles permettent de lier données et comportements dans un même ensemble cohérent.\nDéfinir une méthode\nUne méthode est déclarée à l’intérieur de la classe :\nclass Voiture\n{\npublic:\n    void demarrer(); // déclaration de la méthode\n};\nElle est ensuite définie (généralement en dehors de la classe) :\nvoid Voiture::demarrer()\n{\n    // Code pour démarrer la voiture\n}\nUtiliser une méthode\nOn appelle une méthode sur un objet avec l’opérateur point (.) :\nVoiture v;\nv.demarrer();\nCela exécute l’action associée pour cet objet précis.\nMéthodes particulières\nSelon leur rôle, on distingue plusieurs usages particuliers de méthodes :\n\naccesseur (getter) : méthode qui lit un attribut.\nmutateur (setter) : méthode qui modifie un attribut.\nMéthodes d’action : méthodes qui font agir l’objet sans nécessairement lire ou modifier un attribut (ex: démarrer(), freiner()).\n\n\nRemarque : Accesseur et mutateur ne sont pas des types différents de méthode ; ce sont des usages particuliers de la méthode.\n"},"nom-pleinement-qualifié":{"slug":"nom-pleinement-qualifié","filePath":"nom pleinement qualifié.md","title":"nom pleinement qualifié","links":["espace-de-noms"],"tags":[],"content":"\nNom anglais: fully qualified name\n\n\nUn nom pleinement qualifié (ou fully qualified name) est un nom qui inclut l’espace de noms  (on dit aussi de son contexte) dans lequel un élément est défini.\nIl permet de désigner un élément **de manière précise et sans ambiguïté, même s’il existe ailleurs un autre du même nom.\nComparaison C/C++: le concept de nom pleinement qualifié n’existe pas en C, car le langage ne dispose pas d’espace de nom\n\nExemple\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\n\ncout est défini dans l’ espace de noms (namespace) std\nSon nom pleinement qualifié est donc std::cout\n\nPourquoi l’utiliser\n\nPour éviter les conflits de noms\nPour être explicite sur la provenance d’un élément\nUtile quand plusieurs éléments du même nom existent dans des contextes différents\n\nAutre exemple\nmath::calcul();        // appelle calcul dans le namespace math\nphysique::calcul();    // appelle une autre fonction calcul\nRésumé\n\nUn nom pleinement qualifié est un nom précédé de son espace de noms (ou de son contexte), utilisé pour identifier clairement un élément parmi plusieurs portant le même nom.\n"},"objet":{"slug":"objet","filePath":"objet.md","title":"objet","links":["classe","attribut","méthode","structure","fonction","C++","compilateur","constructeur","constructeur-par-défaut","objet","pile","constructeur-paramétré","compilation","constructeur-par-copie","membre","C++98","string","publique"],"tags":[],"content":"\nNom anglais: object\n\n\nUn objet est une instance concrète d’une classe. C’est une entité qui regroupe des attributs (données) et des méthodes (fonctions) définis par sa classe.\nComparaison C/C++: Un objet est similaire à une variable de type structure (struct), mais avec des fonctions (les méthodes) associées en plus des données.\n\n\nObjets et classes\nUne classe est un plan, un modèle. Un objet est une réalisation concrète de ce plan. Chaque objet possède ses propres copies des attributs et peut utiliser les méthodes définies dans la classe.\n\nComparaison C/C++: On peut se représenter une classe un peu comme une structure en C. En C++, un objet est à la classe ce que la variable est à la structure en C. Par exemple, en C, on peut définir une structure Voiture, en faire un type avec typedef, puis déclarer une variable ma_voiture de ce type. De manière équivalente, en C++, on peut définir une classe Voiture, puis créer un objet maVoiture qui est une instance de cette classe.\n\n\nExemple\nAvec une classe Voiture, on peut créer plusieurs objets :\nVoiture voiture1;\nVoiture voiture2;\nChaque voiture (voiture1 et voiture2) est un objet distinct.\nPar exemple :\n\nvoiture1 pourrait être rouge, de marque Toyota, roulant à 120 km/h.\nvoiture2 pourrait être bleue, de marque Ford, roulant à 80 km/h.\n\nChaque objet possède ses propres valeurs pour ses attributs et peut effectuer ses propres actions via ses méthodes.\n\nObjets et mémoire\nChaque objet occupe une zone distincte en mémoire. Même s’ils sont créés à partir de la même classe, les objets sont indépendants les uns des autres.\nTu as tout à fait raison. Voici une version enrichie et rigoureusement structurée de la section “Créer un objet”, avec le titre ajusté en “Déclarer un objet”, et un nouveau paragraphe dédié aux constructeurs, conforme à ton style habituel :\n\nCréation d’un objet\nLorsqu’on déclare un objet, le compilateur fait appel à un constructeur de la classe concernée pour créer l’objet.\n→ Voir la fiche dédiée : constructeur\nCréation à partir du constructeur par défaut\nPour créer un objet à partir du constructeur par défaut, on utilise le nom de la classe comme type, suivi du nom de l’objet :\nVoiture voiture1;\nVoiture voiture2;\n// voiture1 et voiture2 sont deux objets de type Voiture, créés à partir du constructeur par défaut\n\nCela crée un objet automatique (stocké sur la pile) de type NomDeLaClasse. Le constructeur par défaut est appelé, ce qui veut dire que les attributs de l’objet seront initialisés avec des valeurs uniquement si ce constructeur par défaut initialise les attributs.\n\n→ Voir la fiche dédiée : constructeur par défaut\nCréation à partir d’un constructeur paramétré\nOn peut créer un objet à partir d’un constructeur spécifique en ajoutant des parenthèses () (à droite du nom de l’objet) dans lesquelles on passe les arguments. S’il existe  plusieurs constructeur paramétrés (c’est à dire des constructeurs qui attendent des paramètres en entrée), le compilateur choisira celui qui correspond aux types passés en argument. Evidemment, si aucun constructeur acceptant les types passés en argument n’existe, la compilation échouera.\n\nEn C++, le choix du constructeur dépend des paramètres fournis lors de la déclaration de l’objet.\n\n→ Voir la fiche dédiée : constructeur paramétré\nCréation à partir d’un constructeur par copie\nOn peut aussi créer un objet à partir d’un autre objet de même type. Le compilateur fait alors appel au constructeur par copie (si la classe ne possède bien de constructeur par copie, le compilateur en crée un automatiquement, mais avec certaines limitations).\n→ Voir la fiche dédiée : constructeur par copie\nExemples\nVoiture a;                   // constructeur par défaut\nVoiture b(&quot;Ford&quot;);           // constructeur avec paramètre nom de type string\nVoiture c(&quot;Ford&quot;, 23000).    // constructeur avec paramètres nom de type string et prix de type int\nVoiture d(a);                // constructeur par copie\nAttributs non initialisés\nLes attributs membres d’un objet ne sont pas initialisés automatiquement à sa création si le constructeur ne les initialise pas explicitement (en C++98 notamment), sauf cas particuliers. Les attributs non initialisés contiendront donc des valeurs indéterminées (mémoire non initialisée).\n\nEn revanche, si ces attributs sont eux-mêmes des objets d’une autre classe, alors leur propre constructeur par défaut sera automatiquement appelé. Ils seront donc initialisés selon le comportement défini dans ce constructeur par défaut.\n→ Par exemple, un attribut de type string (std::string) sera initialisé par défaut avec une  chaîne vide (&quot;&quot;).\n\n\nUtilisation d’un objet\nPour utiliser un objet, on se sert de l’opérateur point (.) pour accéder aux méthodes et aux attributs publiques d’un objet :\nnomDeLObjet.attribut = valeur;\nnomDeLObjet.methode();\n\nEvidemment, seuls les méthodes et attributs publiques sont accessibles de cette manière depuis l’extérieur de la classe.\n"},"ofstream":{"slug":"ofstream","filePath":"ofstream.md","title":"ofstream","links":["classe","bibliothèque-standard-C++","flux","C++","Méthode"],"tags":[],"content":"\nNom pleinement qualifié : std::ofstream\n\n\nstd::ofstream (output file stream) est une classe de la bibliothèque standard C++ qui permet d’écrire dans des fichiers texte ou binaires.\nC’est un flux en écriture, analogue à std::cout, mais connecté à un fichier.\nComparaison C / C++: En langage C, on utilise des fonctions comme fopen(), fprintf(), fputs() ou fclose() pour écrire dans des fichiers. Ces fonctions obligent à gérer manuellement les pointeurs, les erreurs, et les conversions de type, ce qui peut les rendre moins sûres. En C++, std::ofstream fournit une interface orientée objet, compatible avec std::string et &lt;&lt;, et garantit une fermeture automatique du fichier grâce au principe du RAII.\n\nInclude\nstd::ofstream appartient à la bibliothèque standard C++. Il faut inclure :\n#include &lt;fstream&gt;\nDéclaration et ouverture du fichier\nstd::ofstream fichier(&quot;sortie.txt&quot;); // ouverture directe\nOu bien :\nstd::ofstream fichier;\nfichier.open(&quot;sortie.txt&quot;);\n→ Par défaut, le fichier est écrasé.\nPour ajouter à la fin d’un fichier existant, utiliser le mode std::ios::app :\nstd::ofstream fichier(&quot;log.txt&quot;, std::ios::app);\nVérification d’ouverture\nif (!fichier) {\n    std::cerr &lt;&lt; &quot;Erreur : impossible d’ouvrir le fichier en écriture.&quot; &lt;&lt; std::endl;\n}\nÉcriture de contenu\nÉcrire texte ou variables :\nfichier &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, Âge : &quot; &lt;&lt; age &lt;&lt; std::endl;\nÉcrire caractère par caractère :\nfichier.put(&#039;A&#039;);\nÉcrire une ligne :\nfichier &lt;&lt; ligne &lt;&lt; &quot;\\n&quot;;\nMéthodes utiles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeRôleopen(&quot;nom&quot;)Ouvre le fichieris_open()Vérifie si le fichier est ouvertclose()Ferme le fichierput(c)Écrit un caractèrewrite(p, n)Écrit n caractères (utilisé pour binaire)flush()Force l’écriture immédiate sur le disquefail()Teste s’il y a eu une erreur\nExemple complet\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ofstream fichier(&quot;resultat.txt&quot;);\n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur : impossible de créer le fichier.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    std::string nom = &quot;Alice&quot;;\n    int age = 30;\n    fichier &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, Âge : &quot; &lt;&lt; age &lt;&lt; std::endl;\n \n    fichier.close(); // facultatif mais recommandé\n    return 0;\n}"},"opérateur":{"slug":"opérateur","filePath":"opérateur.md","title":"opérateur","links":["valeur","surcharge","C++","flux","classe","objet","opérateur"],"tags":[],"content":"\nNom anglais: operator\n\n\nUn opérateur est un symbole ou mot-clé qui permet d’effectuer une opération sur une ou plusieurs valeurs (appelées opérandes).\nLes opérateurs servent à calculer, comparer, affecter, ou manipuler des objets ou de la mémoire.\nComparaison C/C++: En C, on parle aussi d’opérateurs, mais la surcharge n’existe pas, contrairement au C++.\n\nExemples courants d’opérateurs symboliques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOpérateurSignificationExemple+Additiona + b-Soustractiona - b*Multiplicationa * b/Divisiona / b==Comparaison d’égalitéa == b=Affectationa = 5&lt;&lt;Insertion dans un fluxstd::cout &lt;&lt; x\nOpérateurs mots-clés (spéciaux)\nCertains opérateurs ne sont pas des symboles mais des mots-clés du langage :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMot-cléRôlenewAlloue dynamiquement de la mémoiredeleteLibère une mémoire allouée avec newsizeofDonne la taille d’un type ou objet (en octets)typeidDonne des infos sur un type (RTTI)\n\nCes opérateurs peuvent aussi être surchargés (operator new, operator delete, etc.).\n\nSurcharge d’opérateurs\nEn C++, on peut surcharger certains opérateurs pour les adapter à des classes personnalisées.\nExemples classiques :\n\n&lt;&lt; pour l’affichage d’objet\n== pour comparer deux objets\n= pour redéfinir l’opérateur d’affectation\n\nRésumé\n\nUn opérateur est un élément syntaxique (symbole ou mot-clé) permettant d’appliquer une opération sur des valeurs ou objets.\nEn C++, la surcharge permet de les adapter aux classes définies par l’utilisateur.\n"},"organisation-des-fichiers-d'une-classe":{"slug":"organisation-des-fichiers-d'une-classe","filePath":"organisation des fichiers d'une classe.md","title":"organisation des fichiers d'une classe","links":["C++","classe","attribut","méthode","publique","privé","protégé"],"tags":[],"content":"\nEn C++, par convention, chaque classe doit être répartie dans deux fichiers distincts :\n\nun fichier d’en-tête (.hpp) contenant la déclaration de la classe (attributs et prototypes des méthodes, sans leur code),\nun fichier d’implémentation (.cpp) contenant la définition des méthodes (c’est-à-dire leur corps).\n\nCette séparation favorise la clarté, la compilation efficace et la réutilisabilité.\n\nÀ 42, cette organisation est obligatoire, et doit inclure les quatre éléments de la forme canonique :  le constructeur par défaut, le constructeur par copie, l’opérateur d’affectation, et le destructeur.\n\nFichier d’en-tête (header)\nNom\nLe fichier .hpp de la classe doit par convention être nommé comme la classe. Exemple : maClassse.hpp.\nGardes d’inclusion:\nLe fichier doit débuter par les gardes d’inclusion qui empêchent le fichier d’être inclus plusieurs fois dans le même programme (ce qui causerait une erreur de redéfinition) : sous la forme\n#ifndef NOMDECLASSE_HPP\n#define NOMDECLASSE_HPP\n// ... contenu de la classe ...\n#endif\nOu bien plus simplement :\n#pragma once\nInclusions\nLe header doit ensuite inclure les include mais uniquement ce qui est strictement requis pour la déclaration (et non pour l’implémentation). Par exemple :\n#include &lt;string&gt; // si on a std::string comme attribut\nDéclaration de la classe\nOn déclare ensuite la classe avec ses parties publiques, privées, etc. Par exemple :\nclass MaClasse\n{\npublic:\n    MaClasse();\n    MaClasse(const MaClasse&amp; other);\n    MaClasse&amp; operator=(const MaClasse&amp; other);\n    ~MaClasse();\n \n    void faireQuelqueChose(); // méthode publique\n \nprivate:\n    int _x;                  // attribut privé\n    std::string _nom;\n};\nPas d’implémentation\nAucune fonction ne doit contenir de code dans le .hpp.\nJamais de `using namespace\nCela pollue l’espace global et peut causer des conflits dans tous les fichiers qui incluent ce .hpp.\n\nFichier d’implémentation (source ou implémentation)\nLe fichier source .cpp contient la définition des méthodes déclarées dans le .hpp. C’est ici que l’on écrit le corps de chaque fonction.\nNom\nLe fichier source doit porter le même nom que le.hpp, mais avec l’extension .cpp. Exemple : MaClasse.cpp`.\nInclusion\nLe fichier .cpp doit commencer par l’inclusion du fichier .hpp correspondant :\n#include &quot;MaClasse.hpp&quot;\nCela garantit que toutes les déclarations sont cohérentes avec celles exposées à l’extérieur.\nDéfinition des méthodes\nLes méthodes sont définies en précisant le nom de la classe suivi de l’opérateur :: :\nvoid MaClasse::faireQuelqueChose() {\n    // code de la méthode\n}\nAccès aux membres\nLe .cpp a un accès complet aux attributs privés et protégés (private et protected) de la classe.\nLiberté des includes\nDans ce fichier, on peut inclure (avec include) tous les fichiers nécessaires à l’implémentation, même s’ils ne sont pas présents dans le .hpp."},"paradigme-de-programmation":{"slug":"paradigme-de-programmation","filePath":"paradigme de programmation.md","title":"paradigme de programmation","links":["programmation-impérative","programmation-procédurale","C++","programmation-orientée-objet","objet","programmation-fonctionnelle","programmation-déclarative","programmation-orientée-donnée"],"tags":[],"content":"\nNom anglais: programming paradigm\n\n\nUn paradigme de programmation est une manière de penser et d’organiser la création de programmes. C’est une approche générale qui influence comment on structure le code et comment on résout les problèmes.\nComparaison C/C++: Le C est principalement de la programmation impérativeet de la programmation procédurale. Le C++ ajoute la programmation orientée objet (POO) et d’autres paradigmes.\n\nPrincipaux paradigmes\n\nLa programmation impérative: Décrit comment le programme doit faire les choses, étape par étape. (Ex : C, C++)\nLa programmation procédurale : Organise le code en fonctions et procédures. (Ex : C)\nLa programmation orientée objet : Organise le code en objets qui contiennent données et comportements. (Ex : C++, Java)\nLa programmation fonctionnelle : Construit le programme avec des fonctions pures sans effets de bord. (Ex : Haskell, certaines parties modernes de C++)\nLa programmation déclarative : Décrit ce que l’on veut obtenir, sans détailler comment. (Ex : SQL)\nLa programmation orientée donnée : Approche qui privilégie la structure et l’agencement des données avant tout\n\nExemple rapide\nEn programmation impérative :\nint x = 0;\nx = x + 1;\nOn décrit comment changer x.\nEn programmation déclarative :\nSELECT * FROM utilisateurs WHERE age &gt; 18;\nOn décrit ce que l’on veut, sans expliquer comment l’obtenir."},"paramètre":{"slug":"paramètre","filePath":"paramètre.md","title":"paramètre","links":["fonction","argument","C++","référence","Argument","objet","pointeur","classe","valeur-par-défaut"],"tags":[],"content":"\nNom anglais: parameter\n\n\nUn paramètre est une variable déclarée dans une fonction, qui reçoit une valeur lors de l’appel à cette fonction. Cette valeur transmise s’appelle un argument.\nLe paramètre est utilisé à l’intérieur de la fonction pour travailler avec la donnée reçue.\nComparaison C/C++ : En C comme en C++, les paramètres peuvent être passés par valeur ou par adresse (pointeur). En C++, on peut aussi utiliser les références.\n\n\nExemple\nvoid saluer(std::string nom) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nIci, nom est le paramètre de la fonction saluer. Il recevra une valeur (un argument) lors de l’appel de la fonction.\n\nParamètre vs argument\nCes deux notions sont proches, mais à ne pas confondre :\n\nParamètre : variable déclarée dans la définition de la fonction (ex : std::string nom)\nArgument : valeur fournie lors de l’appel (ex : &quot;Alice&quot;)\n\n→ Voir la fiche dédiée : argument\n\nTypes de paramètres\nUn paramètre peut être :\n\nde type fondamental (int, char, float, etc.)\nde type objet (std::string, std::vector, etc.)\nde type référence (std::string&amp;, const T&amp;)\nde type pointeur (int*, char*)\nun type personnalisé (défini par une classe)\n\nvoid afficher(int valeur);             // par valeur\nvoid afficher(const std::string&amp; s);   // par référence constante\nvoid afficher(int* ptr);               // par pointeur\n\nParamètre par défaut\nUn paramètre par défaut est un paramètre auquel on assigne une valeur implicite dans la déclaration de la fonction :\nvoid saluer(std::string nom = &quot;inconnu&quot;) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nAppels possibles :\nsaluer();           // affiche &quot;Bonjour, inconnu&quot;\nsaluer(&quot;Alice&quot;);    // affiche &quot;Bonjour, Alice&quot;\n→ Voir la fiche dédiée : valeur par défaut\n\nVoir aussi\n→ fonction, argument, référence\n→ valeur par défaut, pointeur, classe"},"pile-algorithmique-LIFO":{"slug":"pile-algorithmique-LIFO","filePath":"pile algorithmique LIFO.md","title":"pile algorithmique LIFO","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","conteneur-séquentiel","file-double","itérateur","STL","bibliothèque-standard-C++","nom-pleinement-qualifié","conteneur","vecteur"],"tags":[],"content":"\nNom anglais: stack\nNom pleinement qualifié: std::stack\n\n\nUne pile algorithmique LIFO (Last in, first out) stack est un conteneur adaptateur qui fait partie des conteneur standard de la STL en C++. Elle implémente le comportement d’une pile (LIFO – Last In, First Out), où le dernier élément ajouté est le premier retiré.\nElle repose sur un conteneur séquentiel sous-jacent (une file double deque par défaut) mais expose une interface restreinte : accès uniquement au sommet, sans itérateur ni parcours.\n\n\nInclude\nPour utiliser std::stack il faut l’inclusion suivante :\n#include &lt;stack&gt;\n\nEspace de nom\nLes  piles algorithmiques LIFO  stack font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::stack\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nstd::stack&lt;Type&gt; maPile;\n \n// exemple :\nstd::stack&lt;int&gt; pileEntiers;\nstd::stack&lt;std::string&gt; pileMots;\nSpécification du conteneur sous-jacent\nstd::stack&lt;int, std::vector&lt;int&gt; &gt; pileVec;  // avec vector\nstd::stack&lt;int, std::deque&lt;int&gt; &gt; pileDeque; // par défaut\n\nImplémentation interne\nUne stack&lt;T&gt; est un conteneur adaptateur encapsulant :\n\nun conteneur séquentiel (file double deque par défaut)\nune interface limitée à LIFO :\n\npush() → ajoute au sommet\npop() → retire le sommet\ntop() → accède au sommet\n\n\n\n\nElle ne fournit pas d’itérateur, pas de parcours, pas d’accès aléatoire.\n\n\nStack et mémoire\nLa stack repose sur le conteneur sous-jacent pour la gestion de mémoire :\n\npar défaut une file double deque, mais on peut utiliser un vecteur vector si besoin\nl’allocation se fait via les méthodes push() et pop()\nla mémoire suit l’ordre strict LIFO (Last in, first out), idéal pour simuler des appels imbriqués ou des structures temporaires\n\n\nQuand et pourquoi utiliser une pile algorithmique LIFO\nUne stack est idéale dès qu’il faut un stockage temporaire LIFO.\nElle est couramment utilisée pour :\n\nsimuler la pile d’exécution (ex : analyse récursive, parcours d’arbre)\ntraiter des expressions inversées (notation post-fixée)\nannuler des opérations dans une interface utilisateur (undo stack)\n\nElle offre une interface très simple et des performances optimales pour ce type d’usage.\n\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptiontop()Accède à l’élément au sommet de la pilesize()Retourne le nombre d’éléments stockésempty()Vérifie si la pile est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush(val)Empile un nouvel élément au sommetpop()Retire l’élément au sommet\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionoperator=Affecte une autre pileswap()Échange deux piles\n\nRemarques importantes\n\nLa stack ne permet aucun accès à ses éléments internes, à part le sommet\nElle ne fournit pas d’itérateur\nElle repose sur un conteneur séquentiel (modifiable par template)\nElle est conçue uniquement pour des scénarios LIFO purs\n"},"pile":{"slug":"pile","filePath":"pile.md","title":"pile","links":["variable","objet","tas","bloc","compilateur"],"tags":[],"content":"\nNom anglais : stack\n\n\nLa pile est une zone mémoire utilisée pour stocker les variables locales et les objets créés sans new (ceux créée avec new sont alloués sur le tas).\nElle suit le principe LIFO (Last In, First Out: premier entré premier sorti) et la mémoire est automatiquement libérée à la fin du bloc.\n\nCaractéristiques\n\nAllocation automatique\nTrès rapide\nGérée par le compilateur\nCapacité limitée\n\nExemple\nvoid f() {\n    int x = 42; // alloué sur la pile\n} // x est détruit ici"},"pointeur":{"slug":"pointeur","filePath":"pointeur.md","title":"pointeur","links":["allocation-dynamique-de-la-mémoire"],"tags":[],"content":"\nNom anglais : pointer\n\n\nUn pointeur est une variable spéciale qui stocke l’adresse d’une autre variable.\nIl permet de travailler indirectement sur cette variable en utilisant son adresse mémoire.\n\nSyntaxe de base\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉcritureSignificationint* ptr;Déclare un pointeur vers un intptr = &amp;x;Stocke l’adresse de x dans ptr*ptrDéréférence : accède à la valeur pointée\n\nLe symbole * est utilisé pour déclarer un pointeur, mais aussi pour accéder à la valeur pointée (on parle alors de déréférencement).\nLe symbole &amp; est utilisé pour obtenir l’adresse d’une variable.\n\nExemple complet\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 42;\n    int* ptr = &amp;x;  // pointeur vers x\n \n    std::cout &lt;&lt; &quot;Adresse de x : &quot; &lt;&lt; &amp;x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur de ptr : &quot; &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur pointée : &quot; &lt;&lt; *ptr &lt;&lt; std::endl;\n \n    *ptr = 100; // on modifie x via le pointeur\n \n    std::cout &lt;&lt; &quot;Nouvelle valeur de x : &quot; &lt;&lt; x &lt;&lt; std::endl;\n}\nSortie possible :\nAdresse de x : 0x7ffeefbff55c  \nValeur de ptr : 0x7ffeefbff55c  \nValeur pointée : 42  \nNouvelle valeur de x : 100  \n\nÀ retenir\n\nUn pointeur pointe vers une variable (via son adresse)\nOn peut modifier cette variable à travers le pointeur\nIl est possible d’avoir des pointeurs vers n’importe quel type (int, char, std::string, etc.)\n\nPrécautions\n\nNe jamais déréférencer un pointeur nul (nullptr) → crash\nToujours s’assurer que le pointeur pointe vers une adresse valide\nLors d’une allocation dynamique de la mémoire avec new, ne pas oublier de faire un delete\n\nRésumé\n\nUn pointeur permet de travailler sur une variable à travers son adresse.\nC’est un outil fondamental pour la programmation bas niveau, la gestion mémoire et le passage par pointeur.\n"},"polymorphisme":{"slug":"polymorphisme","filePath":"polymorphisme.md","title":"polymorphisme","links":["programmation-orientée-objet","objet","méthode","virtuel","classe","héritage","classe-de-base"],"tags":[],"content":"\nNom anglais: polymorphism\n\n\nLe polymorphisme est un principe de laprogrammation orientée objet qui permet d’utiliser plusieurs types d’objets différents à travers une même interface. En C++, le polymorphisme est principalement possible grâce aux méthodes virtuelles.\nComparaison avec le C: En C, il n’y a pas de polymorphisme natif. En C++, le polymorphisme permet à un même appel de méthode de se comporter différemment selon le type réel de l’objet.\n\nPourquoi utiliser le polymorphisme\nLe polymorphisme permet :\n\nd’écrire du code plus générique, capable de traiter des objets différents de manière uniforme,\nde remplacer un objet par un autre sans changer le code qui l’utilise,\nde simplifier la gestion d’une famille de classes liées par héritage.\n\nFonctionnement du polymorphisme\nPour que le polymorphisme fonctionne :\n\nla classe de base doit déclarer ses méthodes importantes comme virtuelles avec le mot-clé virtual,\non utilise des pointeurs ou références vers la classe de base pour manipuler les objets,\nà l’exécution, la bonne version de la méthode est appelée automatiquement, selon le type réel de l’objet.\n\nExemple\nclass Vehicule\n{\npublic:\n    virtual void demarrer()\n    {\n        std::cout &lt;&lt; &quot;Vehicule démarre&quot; &lt;&lt; std::endl;\n    }\n};\n \nclass Voiture : public Vehicule\n{\npublic:\n    void demarrer() override\n    {\n        std::cout &lt;&lt; &quot;Voiture démarre&quot; &lt;&lt; std::endl;\n    }\n};\n \nVehicule* v = new Voiture();\nv-&gt;demarrer(); // Affiche &quot;Voiture démarre&quot; grâce au polymorphisme\nMême si v est un pointeur vers Vehicule, la méthode Voiture::demarrer() est appelée.\nRésumé\nLe polymorphisme repose sur :\n\nl’héritage,\nles méthodes virtuelles,\nappel dynamique des méthodes.\n\nIl permet une grande flexibilité dans la conception des programmes orientés objet."},"privé":{"slug":"privé","filePath":"privé.md","title":"privé","links":["classe","attribut","méthode","objet","encapsulation","structure","C++","accesseur","mutateur","membre","fonction-friend","publique","protégé","ami"],"tags":[],"content":"\nNom anglais: private section\n\n\nLa partie privée d’une classe regroupe les attributs et méthodes inaccessibles depuis l’extérieur.\nElle sert à protéger les détails d’implémentation internes de l’objet, et à faire respecter le principe fondamental d’encapsulation.\nComparaison C/C++: On peut comparer avec les structures en C: En C, tous les membres d’une structure sont accessibles librement. En C++, on peut restreindre explicitement l’accès aux membres d’une classe avec le mot-clé private:.\n\n\nRôle de la partie privée\nLa section private est utilisée pour :\n\nprotéger l’état interne de l’objet (données sensibles, implémentations internes),\nforcer l’accès à ces données via des méthodes contrôlées, spécifiquement destinées à cet effet (accesseurs, mutateurs),\néviter les utilisations non prévues ou dangereuses.\n\nElle contribue à garantir la robustesse et la sécurité du code en interdisant les manipulations directes.\n\nDéclaration\nOn utilise le mot-clé private: dans une classe pour regrouper les membres inaccessibles depuis l’extérieur, sauf pour :\n\nles méthodes membres de la classe,\nles fonction friend autorisées explicitement.\n\nclass Voiture\n{\nprivate:\n    int _vitesse;\n    void verifierMoteur();\n};\nIci, _vitesse et verifierMoteur() sont invisibles depuis l’extérieur de la classe.\n\nC’est dans la partie privée que l’on place la majorité des attributs, pour respecter les bonnes pratiques de l’encapsulation.\n\n\nAccès\nLes membres privés ne peuvent pas être utilisés depuis l’extérieur de la classe, ni à l’aide d’un objet, ni sans objet :\nVoiture v;\nv._vitesse = 100;      // ❌ Erreur : _vitesse est privé\nv.verifierMoteur();    // ❌ Erreur : méthode privée\nVoiture::verifierMoteur();    // ❌ Erreur : méthode privée\nSeules les méthodes déclarées dans la classe elle-même ont le droit d’y accéder aux membres privés :\nclass Voiture {\npublic:\n    void demarrer() {\n        verifierMoteur();   // ✅ OK : méthode privée appelée en interne\n    }\n \nprivate:\n    void verifierMoteur();\n};\n\nVoir aussi\n→ Voir également : publique, protégé, encapsulation, ami"},"programmation-déclarative":{"slug":"programmation-déclarative","filePath":"programmation déclarative.md","title":"programmation déclarative","links":["paradigme-de-programmation"],"tags":[],"content":"\nNom anglais: declarative programming\n\n\nLa programmation déclarative est un paradigme de programmation qui consiste à décrire ce que l’on veut obtenir, sans préciser comment y parvenir. Le système décide de la manière d’atteindre le résultat.\nExemple : SQL est un langage déclaratif.\n\nCaractéristiques principales\n\nExprime des objectifs, pas des étapes.\nCache les détails de l’exécution.\nUtilisée pour les requêtes, les interfaces, et certaines optimisations automatiques.\n"},"programmation-fonctionnelle":{"slug":"programmation-fonctionnelle","filePath":"programmation fonctionnelle.md","title":"programmation fonctionnelle","links":["paradigme-de-programmation","C++"],"tags":[],"content":"\nNom anglais: functional programming\n\n\nLa programmation fonctionnelle est un paradigme de programmation qui considère le programme comme une suite de fonctions pures, sans effets de bord et sans modification d’état.\nExemple : Haskell est purement fonctionnel. C++moderne permet aussi un style fonctionnel avec std::function, lambda, etc.\n\nCaractéristiques principales\n\nPas de modification d’état (variables immuables).\nPas d’effets de bord (pas d’entrées/sorties cachées).\nFonctions comme objets de première classe.\n"},"programmation-impérative":{"slug":"programmation-impérative","filePath":"programmation impérative.md","title":"programmation impérative","links":["paradigme-de-programmation","C++"],"tags":[],"content":"\nNom anglais: imperative programming\n\n\nLa programmation impérative est un paradigme de programmation qui consiste à décrire précisément les étapes à suivre pour résoudre un problème. Le programme est une suite d’instructions qui modifient l’état du système.\nExemple : Le C et le C++ (partie classique) sont majoritairement impératifs.\n\nCaractéristiques principales\n\nDécrit comment faire les choses.\nUtilise des variables modifiables (état mutable).\nSuit une logique séquentielle (instructions, boucles, conditions).\n"},"programmation-orientée-donnée":{"slug":"programmation-orientée-donnée","filePath":"programmation orientée donnée.md","title":"programmation orientée donnée","links":["paradigme-de-programmation","structure","C++","programmation-orientée-objet","objet","classe","pointeur","cache","encapsulation","pile","tas"],"tags":[],"content":"\nNom anglais: data-oriented programming / data-oriented design\n\n\nLa programmation orientée donnée est un paradigme de programmation basé sur une approche qui privilégie la structure et l’agencement des données avant tout, en mettant l’accent sur leur accès rapide, leur localité en mémoire, et leur traitement séquentiel.\nCette approche est particulièrement utilisée dans les domaines où la performance est critique, comme les moteurs de jeux, la simulation, ou les systèmes embarqués.\nComparaison C/C++ : En C, la conception est naturellement orientée donnée (structures, tableaux). En C++, on peut mêler cette approche à la programmation orientée objet pour optimiser le code bas niveau.\n\n\nPrincipes\n\nOrganiser les données pour favoriser les parcours mémoire séquentiels\nMinimiser les objets complexes ou classes imbriquées\nÉviter les pointeurs inutiles et la fragmentation mémoire\nFavoriser les tableaux de structures simples (struct) plutôt que des structures contenant des objets\n\n\nExemple\nMoins performant (objet complexe) :\nstruct Entite {\n    float x;\n    float y;\n    float vx;\n    float vy;\n};\n \nstd::vector&lt;Entite&gt; entites;\nPlus performant (stockage parallèle) :\nstd::vector&lt;float&gt; posX, posY, velX, velY;\n\nLe second exemple permet un accès plus contigu en mémoire, ce qui favorise le cache CPU.\n\n\nQuand utiliser l’approche orientée donnée ?\n\nLorsque la performance prime sur la modélisation\nDans des contextes à très grand volume de données\nPour écrire du code proche de la machine, où l’agencement mémoire compte plus que la structure abstraite\n\n\nVoir aussi\n→ structure, classe, objet, encapsulation, pointeur, pile, tas\n→ paradigme de programmation, programmation orientée objet"},"programmation-orientée-objet":{"slug":"programmation-orientée-objet","filePath":"programmation orientée objet.md","title":"programmation orientée objet","links":["paradigme-de-programmation","objet","attribut","méthode","C++","encapsulation","héritage","classe","polymorphisme"],"tags":[],"content":"\nAbréviation: POO\nNom anglais: oriented-object programming\nAbréviation anglaise: OOP\n\n\nLa programmation orientée objet est un paradigme de programmation qui repose sur la modélisation du programme en objet.\nUn objet est une entité autonome qui combine des données (les variables contenues dans l’objet, appelées attributs) et des fonctions (appelées méthodes) pour manipuler ces données.\nChaque objet représente une réalité concrète ou abstraite du problème à résoudre.\nComparaison C/C++ : Le C++est conçu pour la POO dès ses débuts (c’était même l’une des raisons principales de sa création à partir du C).\n\nObjectifs principaux de la POO\n\nMieux organiser le code\nFavoriser la réutilisation grâce à l’encapsulation et l’héritage\nSimplifier la maintenance et l’évolution du logiciel\nModéliser fidèlement des concepts du monde réel\n\nConcepts fondamentaux de la POO\nPour appréhender la POO, il faut comprendre les concepts suivants:\n\nles classes (modèles ou un plans pour créer les objets)\nles objets (les instances concrètes d’une classe)\nl’encapsulation (pour protéger les données d’un objet en les rendant accessibles uniquement via des méthodes spécifiques)\nl’héritage (une classe peut hériter des attributs et des méthodes d’une autre classe)\nle polymorphisme (la capacité pour différents objets d’être utilisés à travers une interface commune)\n\n📜 Pourquoi utiliser la programmation orientée objet ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAvantageDétailOrganisation claireLe programme est découpé en petites unités logiques (objets).RéutilisationOn peut utiliser les mêmes classes dans plusieurs projets.ExtensibilitéAjouter de nouvelles fonctionnalités est plus facile.MaintenanceLe code est plus simple à corriger et à améliorer.\nExemple simple en C++\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nclass Voiture\n{\nprivate:\n    std::string couleur;\n \npublic:\n    Voiture(const std::string&amp; c) : couleur(c) {}\n \n    void afficher()\n    {\n        std::cout &lt;&lt; &quot;La voiture est de couleur &quot; &lt;&lt; couleur &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;\n    }\n};\n \nint main()\n{\n    Voiture v(&quot;rouge&quot;);\n    v.afficher();\n    return 0;\n}\nIci :\n\n\nVoiture est une classe.\n\n\nv est un objet.\n\n\ncouleur est un attribut.\n\n\nafficher() est une méthode.\n\n\n\n🧠 À retenir\n\n\nPOO (OOP en anglais) est un modèle basé sur la création d’objets qui combinent données et comportements.\n\n\nElle rend les programmes plus proches de notre manière naturelle de comprendre le monde.\n\n\nLes concepts-clés sont : classe, objet, encapsulation, héritage, polymorphisme.\n\n\n\nVeux-tu aussi que je te prépare en bonus une carte mentale (mindmap) très simple sur la POO que tu pourrais intégrer visuellement dans Obsidian ? 🎯\n(Ça aide énormément à mémoriser pour les projets C++ de 42 !)"},"programmation-procédurale":{"slug":"programmation-procédurale","filePath":"programmation procédurale.md","title":"programmation procédurale","links":["paradigme-de-programmation","programmation-impérative"],"tags":[],"content":"\nNom anglais: procedural programming\n\n\nLa programmation procédurale est un paradigme de programmation qui est une forme particulière de programmation impérative qui organise le code en fonctions et procédures pour améliorer la lisibilité et la réutilisation.\nExemple : Le C est un langage procédural typique.\n\nCaractéristiques principales\n\nBasée sur les fonctions.\nPermet de réutiliser et de structurer le code.\nUtilise l’état global modifié par différentes fonctions.\n"},"protégé":{"slug":"protégé","filePath":"protégé.md","title":"protégé","links":["classe","attribut","méthode","classe-dérivée","privé","publique","héritage","C++","classe-de-base","objet","membre","protégé"],"tags":[],"content":"\nNom anglais: protected\n\n\nLa partie protégée (protected) d’une classe contient des attributs et méthodes inaccessibles depuis l’extérieur, mais accessibles depuis les classe dérivées.\nC’est un compromis entre privé (private = totalement caché) et publique (public = totalement ouvert).\nComparaison C/C++ : En C, il n’existe pas de notion de protection par héritage. En C++, protected permet à une classe dérivée d’accéder à certains éléments de sa classe de base.\n\n\nRôle de la partie protégée\nLa section protected est utilisée pour :\n\npermettre à une classe dérivée d’accéder à des ressources internes de la classe de base (voir héritage),\ncacher ces ressources au reste du code extérieur,\nstructurer un héritage contrôlé sans tout exposer en publique.\n\n\nDéclaration\nOn utilise le mot-clé protected: dans une classe pour désigner une section accessible uniquement :\n\npar la classe elle-même,\npar ses classe dérivées,\nmais pas par l’extérieur.\n\nclass Vehicule\n{\nprotected:\n    int _vitesse;\n \n    void ajusterVitesse(int v);\n};\nIci, _vitesse et ajusterVitesse() sont accessibles dans les sous-classes, mais pas dans le main() ni par un objet.\n\nAccès\nUn membre déclaré protected n’est pas accessible depuis l’extérieur de la classe, ni même depuis un objet instancié.\nEn revanche, il est entièrement accessible depuis une classe dérivée, comme si c’était un membre privé de cette sous-classe.\nCela permet d’étendre la classe de base sans exposer tous ses détails internes au reste du programme.\nPar exemple :\nclass Voiture : public Vehicule {\npublic:\n    void booster() {\n        _vitesse += 50;          // ✅ OK : accessible dans la classe dérivée\n        ajusterVitesse(150);     // ✅ OK aussi\n    }\n};\n \nint main() {\n    Voiture v;\n    v._vitesse = 100;           // ❌ Erreur : membre protégé\n    v.ajusterVitesse(150);      // ❌ Erreur aussi\n}\n\nQuand utiliser protected ?\n\nLorsqu’on écrit une classe de base destinée à être étendue,\net qu’on veut offrir des outils internes aux sous-classes, sans exposer ces outils à tout le programme.\n\n\n⚠️ L’usage de protected doit rester exceptionnel et réfléchi.\nDans beaucoup de cas, il vaut mieux garder les attributs privés et exposer des méthodes protégées.\n\n\nVoir aussi\n→ Voir également : privé, publique, héritage, classe dérivée"},"prédicat":{"slug":"prédicat","filePath":"prédicat.md","title":"prédicat","links":["C++","fonction","foncteur","STL","C++11"],"tags":[],"content":"\nNom anglais: predicate\n\n\nEn C++, un prédicat est une fonction ou foncteur qui retourne une valeur booléenne (true ou false) lorsqu’elle est appliquée à un ou plusieurs arguments.\nLes prédicats sont souvent utilisés avec les fonctions de la STL, comme find_if, count_if, remove_if, sort, etc.\n\n\nPrototype général\nbool pred(const T&amp; value);               // prédicat unaire\nbool pred(const T1&amp; a, const T2&amp; b);     // prédicat binaire\n\nUtilisation\nUn prédicat permet de définir un critère personnalisé de sélection, de tri, de filtrage, etc.\nIl peut être :\n\nune fonction libre (bool is_even(int x) { return x % 2 == 0; })\nune fonction membre\nun foncteur (objet fonctionnel)\nune lambda (à partir de C++11)\n\n\nExemples\nbool is_negative(int n) { return n &lt; 0; }\n \nstd::vector&lt;int&gt; v = {-1, 2, -3, 4};\n \nauto it = std::find_if(v.begin(), v.end(), is_negative); // cherche le 1er élément &lt; 0\nAvec une lambda (C++11) :\nstd::count_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; }); // compte les pairs\n\nRemarques\n\nLe type bool est obligatoire pour que le prédicat soit valide.\nEn général, les prédicats sont légers et rapides, car ils sont souvent appelés de nombreuses fois dans une boucle algorithmique.\nLes fonctions comme sort, find_if, all_of, etc., attendent souvent un prédicat unaire ou binaire.\n"},"publique":{"slug":"publique","filePath":"publique.md","title":"publique","links":["classe","méthode","attribut","objet","C++","encapsulation","accesseur","mutateur","structure","privé","protégé"],"tags":[],"content":"\nNom anglais: public\n\n\nLa partie publique d’une classe regroupe les méthodes et éventuellement les attributs qui sont librement accessibles depuis l’extérieur de l’objet. C’est ce qui constitue l’interface visible de l’objet. On utilise le mot clé public: pour déclarer la section publique d’une classe.\nComparaison C/C++: On peut faire la parallèle avec une structure en C: Dans une structure en C, tous les membres sont automatiquement accessibles publiquement. En C++, la partie publique est définie explicitement avec public:.\n\n\nRôle de la partie publique\nLa partie publique sert à :\n\ndéfinir ce que l’utilisateur peut voir et utiliser,\nmasquer la complexité interne (grâce à l’encapsulation),\nproposer une interface claire et stable pour interagir avec l’objet.\n\n\nDéclaration\nOn utilise le mot-clé public: dans une classe pour ouvrir une section d’accès libre au sein de laquelle on va pouvoir déclarer les méthodes et attributs qui seront accessibles depuis l’extérieur de la classe.\n\nDéclarer des attributs en public est rarement conseillé, car cela viole le principe d’encapsulation. On préfère exposer leur valeur via des accesseurs (getter) ou des mutateurs (setter), qui sont des méthodes publiques implémentées pour cela.\n\nclass Voiture\n{\npublic:\n    void demarrer();\n    int getVitesse() const;\n};\nIci, demarrer() et getVitesse() sont des méthodes accessibles à l’extérieur.\n\nAccès\nTout ce qui est déclaré en partie publique est accessible via l’opérateur point (.), comme on le fait pour accéder à un membre d’une structure en C :\nobjet.methode();\nPar exemple :\nVoiture v;\nv.demarrer(); // méthode publique appelée comme on le ferait pour un champ de struct\nIci, on appelle directement demarrer() parce qu’elle est dans la partie publique.\n\nVoir aussi\n→ Voir également : privé, protégé, encapsulation"},"référence":{"slug":"référence","filePath":"référence.md","title":"référence","links":["pointeur","C++","objet","fonction"],"tags":[],"content":"\nNom anglais : reference\n\n\nUne référence permet de travailler sur une variable sans faire de copie, tout en gardant une syntaxe simple et naturelle.\nElle évite les erreurs fréquentes des pointeurs (comme les pointeurs nuls ou les erreurs de déréférencement) tout en offrant une accès direct à la mémoire.\nComparaison C/C++: Les références n’existent pas en C++.\n\nPourquoi utiliser une référence\nLes références sont idéales pour :\n\nPasser des variables à une fonction sans les copier (plus efficace en terme de ressources)\nModifier une variable depuis une autre fonction\nRetourner un objet depuis une fonction sans duplication\nSimplifier le code par rapport à l’utilisation des * et &amp; des pointeurs\n\nSyntaxe de base\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉcritureSignificationint&amp; ref = x;Crée une référence à la variable xref = 10;Affecte la valeur 10 à x via son alias&amp;refDonne l’adresse de x (car ref est x)\n→ Une référence doit être initialisée au moment de sa déclaration, et ne peut plus être changée ensuite.\nExemple complet\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 42;\n    int&amp; ref = x;  // ref est un alias de x\n \n    std::cout &lt;&lt; &quot;Adresse de x : &quot; &lt;&lt; &amp;x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Adresse de ref : &quot; &lt;&lt; &amp;ref &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur via ref : &quot; &lt;&lt; ref &lt;&lt; std::endl;\n \n    ref = 100; // modifie x via la référence\n \n    std::cout &lt;&lt; &quot;Nouvelle valeur de x : &quot; &lt;&lt; x &lt;&lt; std::endl;\n}\nSortie possible :\nAdresse de x : 0x7ffeefbff55c  \nAdresse de ref : 0x7ffeefbff55c  \nValeur via ref : 42  \nNouvelle valeur de x : 100  \n\nRéférences constantes\n\nUne référence constante (const &amp;) permet de référencer une variable sans pouvoir la modifier.\nC’est très utile pour passer des objets lourds à une fonction sans copie, tout en garantissant qu’ils ne seront pas modifiés.\n\nvoid afficher(const std::string&amp; texte) {\n    std::cout &lt;&lt; texte &lt;&lt; std::endl;\n}\n\nAucune copie\nImpossible de modifier texte dans la fonction\nTrès utilisé pour les objets comme std::string, std::vector, etc.\n\nDifférences avec les pointeurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaractéristiqueRéférencePointeurPeut être null❌ Non✅ OuiPeut être réassignée❌ Non✅ OuiAccès à la valeurdirect (ref)indirect (*ptr)Déclarationint&amp; r = x;int* p = &amp;x;Nécessite * pour accéder❌ Non✅ Oui (*ptr)\nÀ savoir\n\nUne référence n’est pas une copie : elle modifie directement la variable d’origine\nC’est la forme privilégiée pour :\n\nLe passage par référence en fonction\nLe retour d’objet sans copie\nUne écriture claire et sûre\n\n\nUne fois initialisée, une référence ne peut plus être liée à autre chose\n\nRésumé\n\nUne référence en C++ est un alias permanent d’une variable.\nElle permet de travailler directement sur une variable sans utiliser de pointeur.\nElle est plus naturelle, sûre et lisible que les pointeurs dans la majorité des cas.\n"},"scripts":{"slug":"scripts","filePath":"scripts.md","title":"scripts","links":[],"tags":[],"content":""},"stat":{"slug":"stat","filePath":"stat.md","title":"stat","links":["fonction","Unix","C++","macro"],"tags":[],"content":"\nBibliothèque : #include &lt;sys/stat.h&gt;\n\n\nLa fonction stat de la bibliothèque sys/stat.h permet d’obtenir des informations détaillées sur un fichier ou un répertoire sans avoir à l’ouvrir ni à le lire.\nElle remplit une structure struct stat contenant des métadonnées comme :  le type (fichier, dossier…), la taille, les permissions, la date de modification, etc.\nC’est un outil de bas niveau très utilisé en Unix / Linux pour analyser un fichier avant de l’utiliser.\nComparaison C/C++: sys/stat.h est une bibliothèque C POSIX, disponible sur la plupart des systèmes Unix/Linux, qui permet d’obtenir des métadonnées système sur des fichiers.  Elle est utilisable en C comme en C++, car le C++ est compatible avec les headers C.\n\nContenu de la bibliothèque sys/stat\nLe fichier d’en-tête #include &lt;sys/stat.h&gt; fait partie de l’API POSIX.\nIl contient :\n\nla structure stat\nla fonction stat()\ndes macros pour tester le type de fichier (S_ISDIR, S_ISREG, etc.)\n\nLa structure struct stat\nC’est une structure C (remplie par la fonction stat()) avec les métadonnées du fichier ou dossier (taille, permissions, date de création, etc).\nstruct stat {\n    mode_t st_mode;     // type de fichier + permissions\n    off_t st_size;      // taille en octets\n    time_t st_mtime;    // dernière modification\n    uid_t st_uid;       // propriétaire (utilisateur)\n    gid_t st_gid;       // groupe propriétaire\n    ...\n};\nLe champ st_mode\nCe champ contient :\n\nles permissions du fichier (lecture, écriture, exécution)\net le type du fichier (répertoire, fichier régulier, etc.)\n\nIl s’utilise avec des macros de test comme S_ISDIR.\nLa fonction stat()\nPrototype :\nint stat(const char *pathname, struct stat *buf);\n\npathname : chemin du fichier à analyser\nbuf : pointeur vers une struct stat à remplir\n\nRetour :\n\n0 si tout s’est bien passé\n-1 en cas d’erreur (fichier inexistant, permissions…)\n\nLa macro S_ISDIR\nS_ISDIR(s.st_mode)\n\nVérifie si le fichier pointé est un dossier\nRetourne un booléen (true ou false)\n\nAutres macros utiles\n\nS_ISREG() : fichier régulier\nS_ISLNK() : lien symbolique\nS_ISCHR() / S_ISBLK() : périphériques\n\nExemple minimal\n#include &lt;sys/stat.h&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    struct stat s;\n    if (stat(&quot;chemin&quot;, &amp;s) == 0) {\n        if (S_ISDIR(s.st_mode))\n            std::cout &lt;&lt; &quot;C&#039;est un dossier&quot; &lt;&lt; std::endl;\n        else if (S_ISREG(s.st_mode))\n            std::cout &lt;&lt; &quot;C&#039;est un fichier&quot; &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; &quot;Erreur : accès impossible&quot; &lt;&lt; std::endl;\n    }\n}"},"strftime":{"slug":"strftime","filePath":"strftime.md","title":"strftime","links":["bibliothèque-standard-C++"],"tags":[],"content":"\nNom pleinement qualifié : std::strftime\n\n\nLa fonction strftime de la bibliothèque standard C++ permet de formater une date (structure tm) en une chaîne lisible, selon un modèle personnalisé.\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);\n    std::tm* utc = std::gmtime(&amp;now);\n    \n    char buffer[80];\n    std::strftime(buffer, 80, &quot;%Y-%m-%d %H:%M:%S&quot;, utc);\n \n    std::cout &lt;&lt; &quot;UTC : &quot; &lt;&lt; buffer &lt;&lt; std::endl;\n}\n\nLe format %Y-%m-%d %H:%M:%S donne une date du type 2025-05-07 16:42:00.\n\nUsage concret\n\nCréer des chaînes lisibles pour logs, affichage, fichiers\nAdapter le format selon les besoins (%d/%m/%Y, %A, %I:%M %p, etc.)\n"},"string":{"slug":"string","filePath":"string.md","title":"string","links":["objet","bibliothèque-standard-C++","méthode"],"tags":[],"content":"\nNom pleinement qualifié: std::string\n\n\nstd::string est un objet de la bibliothèque standard C++ permettant de manipuler des chaînes de caractères dynamiques.\nIl est plus puissant, plus sécurisé et plus pratique que les tableaux de char en C (char[]).\nComparaison C/C++ : alors qu’en C on utilise des char* ou char[] terminés par \\0, std::string gère tout automatiquement (taille, mémoire, fin de chaîne…).\n\nInclude\nPour utiliser std::string il faut inclure :\n#include &lt;string&gt;\nCaractéristiques principales\n\nStocke une chaîne de caractères modifiable\nTaille dynamique (croît ou rétrécit automatiquement)\nOpérations de base faciles (+, +=, [], ==, etc.)\nFournit des méthodes puissantes pour la manipulation de texte (recherche, extraction, modification)\nCompatible avec const char* grâce à c_str()\n\nComparaison avec un char[] (en C)\n\nla taille d’une std::stringest dynamique et auto-gérée, alors que la taille d’un char[] est fixe ou doit être gérée manuellement\nla fin de chaîne d’une std::stringest gérée automatiquement, alors que pour un char[] un \\0 est requis\ndes fonctions intégrées (méthodes) sont accessibles avec une std::string\nla sécurité d’une std::string est forte, tandis que les risque de dépassement de mémoire (buffer overflow) sont importants avec un char[]\n\nSyntaxe de base\n#include &lt;string&gt;\n \nstd::string s1;                     // chaîne vide\nstd::string s2 = &quot;Bonjour&quot;;         // initialisation classique\nstd::string s3(&quot;Salut&quot;);            // autre façon\nstd::string s4 = s2 + &quot; à tous&quot;;    // concaténation\nPrincipales fonctions associées\nPour une std::string str :\nConstruction / modification\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.length()Renvoie la longueur (nombre de caractères)str.size()Identique à length()str.empty()Renvoie true si la chaîne est videstr.clear()Vide complètement la chaînestr += &quot;abc&quot;Ajoute &quot;abc&quot; à la finstr1 + str2Crée une nouvelle chaîne résultant de la concaténation de str1 et str2str.append(&quot;abc&quot;)Ajoute &quot;abc&quot; à la fin de la chainestr.insert(pos, s)Insère s à la position posstr.erase(pos, len)Supprime len caractères à partir de posstr.replace(p, l, s)Remplace une portion par une autre chaîne :p est la position de début dans la chaîne, l la longueur (nombre de caractères à remplacer) et s la nouvelle chaine qui remplace la portion spécifiée.\nAccès et lecture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr[i]Accès non vérifié à un caractèrestr.at(i)Accès vérifié (exception si hors-limite)str.front()Premier caractèrestr.back()Dernier caractèrestr.c_str()Retourne un const char* (compatible C)\nRecherche\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.find(&quot;abc&quot;)Position de &quot;abc&quot;, ou std::string::npos si non trouvéstr.rfind(&quot;abc&quot;)Idem, mais cherche à l’enversstr.find_first_of(&quot;ae&quot;)Premier des caractères donnésstr.find_last_of(&quot;ae&quot;)Dernier des caractères donnés\nExtraction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.substr(pos, len)Extrait une sous-chaînestr.copy(buf, len, pos)Copie dans un buffer C (char*)\nItération\nstd::string s = &quot;Test&quot;;\n \nfor (size_t i = 0; i &lt; s.size(); i++)\n\tstd::cout &lt;&lt; s[i] &lt;&lt; std::endl;\n \nfor (char c : s) // C++11+\n\tstd::cout &lt;&lt; c &lt;&lt; std::endl;\n⚠️ Attention\n\nL’opérateur [] ne vérifie pas les limites ➝ préférer at() si doute\nstd::string n’est pas un tableau C ➝ pas de strlen() ou strcpy()\nPour un char* utilisable en C : s.c_str() (lecture seule)\n\nBonnes pratiques\n\nUtiliser std::string plutôt que char* pour éviter les erreurs mémoire\nNe pas manipuler directement les buffers internes (data() ou &amp;s[0]) sans raison\nPréférer les méthodes (find, replace, etc.) aux fonctions C (strtok, strcpy, etc.)\n\nRésumé\n\nstd::string est un objet de la bibliothèque standard C++ conçu pour manipuler facilement et en sécurité des chaînes de caractères.\nIl remplace les char[] du C avec une interface intuitive, des fonctionnalités puissantes, et une gestion automatique de la mémoire.\n"},"structure-d'un-programme-en-C++":{"slug":"structure-d'un-programme-en-C++","filePath":"structure d'un programme en C++.md","title":"structure d'un programme en C++","links":["compilateur","directive-de-préprocesseur"],"tags":[],"content":"Qu’est-ce que la structure d’un programme en C++?\n\nLa structure d’un programme en C++, c’est l’organisation minimale nécessaire pour qu’un code soit compris par le compilateur et exécutable par l’ordinateur.\n\nUn programme C++ se construit toujours autour de ces 3 éléments principaux :\n\ndirective de préprocesseur\nmain (fonction principale)\ninstruction\n"},"structure":{"slug":"structure","filePath":"structure.md","title":"structure","links":["membre","bloc","C++","méthode","constructeur","héritage","classe","attribut","destructeur","membre-statique","surcharge-d'opérateur","liste-d'initialisation","objet","encapsulation","programmation-orientée-donnée","publique","privé"],"tags":[],"content":"\nNom anglais: struct / structure\n\n\nUne structure (struct) est un type défini par l’utilisateur permettant de regrouper plusieurs membres (ou champs) — généralement de types différents — dans un même bloc cohérent.\nComparaison C/C++ : En C, une structure est un agrégat de données sans comportement. En C++, une struct peut aussi contenir des méthodes, des constructeurs, de l’héritage, etc., comme une classe.\nLa seule différence entre struct et class en C++ est la visibilité par défaut : public pour struct, private pour class.\n\n\nDéfinir une structure\nUne strucure struct regroupe plusieurs champs, définis comme des attributs internes :\nstruct Point {\n    int x;\n    int y;\n};\n\nUne fois déclarée, on peut utiliser cette struct comme n’importe quel type :\n\nPoint p;\np.x = 3;\np.y = 4;\n\nParticularités des structures en C++\nContrairement au langage C, une struct en C++ peut contenir :\n\ndes méthodes\ndes constructeurs\ndes destructeurs\ndes membre statiques\nde l’héritage\ndes surcharge d’opérateurs\n\nstruct Point {\n    int x;\n    int y;\n \n    Point(int x_, int y_) : x(x_), y(y_) {}\n \n    void afficher() const {\n        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;\n    }\n};\n\nInitialisation\nEn C++, on peut initialiser une structure struct avec une liste d’initialisation :\nPoint a = {1, 2};  // initialisation directe\nPoint b(3, 4);     // appel du constructeur\n\nDifférences struct vs class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÉlémentstructureclasseVisibilité par défautpublicprivateHéritage par défautpublicprivateFonctionnalitésidentiquesidentiques\n\nEn C++, la distinction struct / class est une convention de style.\nOn utilise généralement struct pour des types simples, proches de la donnée brute, ou comme objets sans logique métier.\n\n\nExemple complet\n#include &lt;iostream&gt;\n \nstruct Rectangle {\n    int largeur;\n    int hauteur;\n \n    Rectangle(int l, int h) : largeur(l), hauteur(h) {}\n \n    int surface() const {\n        return largeur * hauteur;\n    }\n};\n \nint main() {\n    Rectangle r(4, 5);\n    std::cout &lt;&lt; r.surface() &lt;&lt; std::endl; // 20\n}\n\nQuand utiliser une struct ?\n\nPour des données simples, sans logique métier complexe\nPour des types de valeur (coordonnées, couples, paires…)\nPour représenter une agrégation de données sans encapsulation forte\nEn programmation orientée donnée ou dans des API publiques comme structures d’échange\n\n\nVoir aussi\n→ classe, attribut, méthode, constructeur\n→ publique, privé, objet, héritage, encapsulation"},"surcharge-d'opérateur":{"slug":"surcharge-d'opérateur","filePath":"surcharge d'opérateur.md","title":"surcharge d'opérateur","links":["opérateur","classe","objet","surcharge","this","attribut","privé","référence","flux","fonction"],"tags":[],"content":"\nNom anglais: operator overloading\n\n\nSurcharger un opérateur signifie définir son comportement personnalisé pour une classe donnée. Cela permet, par exemple, d’utiliser +, == ou &lt;&lt; avec des objets comme s’ils étaient des types natifs.\nLa surcharge se fait en écrivant une fonction spéciale appelée operatorXXX, où XXX est l’opérateur à surcharger.\nComparaison C/C++: En C, la surcharge n’existe pas.\n\nÉtapes pour surcharger un opérateur\n\nChoisir l’opérateur à surcharger (ex. +, &lt;&lt;, ==, etc.)\nDéfinir une fonction nommée operatorXXX\nPlacer cette fonction :\n\nà l’intérieur de la classe si elle agit sur this,\nà l’extérieur, avec le mot-clé friend si elle a besoin d’accéder à des attributs privés.\n\n\n\nExemple 1: surcharger operator+ pour une classe Point\nclass Point\n{\npublic:\n    int x, y;\n \n    Point(int a, int b) : x(a), y(b) {}\n \n    // Surcharge de +\n    Point operator+(const Point&amp; autre) const\n    {\n        return Point(x + autre.x, y + autre.y);\n    }\n};\nUtilisation :\nPoint p1(1, 2), p2(3, 4);\nPoint p3 = p1 + p2; // OK grâce à operator+\nExemple 2: surcharger operator&lt;&lt; pour affichage avec std::cout\nclass Voiture\n{\nprivate:\n    std::string marque;\n    int vitesse;\n \npublic:\n    Voiture(std::string m, int v) : marque(m), vitesse(v) {}\n \n    // Surcharge de &lt;&lt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Voiture&amp; v)\n    {\n        os &lt;&lt; v.marque &lt;&lt; &quot; - &quot; &lt;&lt; v.vitesse &lt;&lt; &quot; km/h&quot;;\n        return os;\n    }\n};\nUtilisation :\nVoiture v(&quot;Toyota&quot;, 120);\nstd::cout &lt;&lt; v;\nBonnes pratiques\n\nLa fonction operatorXXX doit être claire et cohérente avec le sens de l’opérateur\nLe retour peut être un objet (comme pour +) ou une référence à un flux (comme pour &lt;&lt;)\nRespecter la const-correctness (const après la méthode si elle ne modifie rien)\nNe surcharger que si ça a du sens pour  l’objet\n\nCe qu’on peut et ne peut pas surcharger\n✅ Opérateurs fréquents :\n\n+, -, *, /, %\n==, !=, &lt;, &lt;=, &gt;, &gt;=\n&lt;&lt;, &gt;&gt; (pour les flux)\n[], (), -&gt;\n\n❌ Opérateurs non surchargeables :\n\n. (accès membre)\n:: (portée)\n.* (pointeur vers membre)\nsizeof, typeid, alignof\n\nRésumé\n\nSurcharger un opérateur permet d’étendre le comportement naturel d’un symbole (+, &lt;&lt;, etc.) à des objets personnalisés.\nIl suffit d’écrire une fonction spéciale operatorXXX, qui peut être interne ou externe à la classe selon le contexte.\n"},"surcharge-de-fonction":{"slug":"surcharge-de-fonction","filePath":"surcharge de fonction.md","title":"surcharge de fonction","links":["surcharge","C++","fonction","compilateur","méthode","classe","constructeur","objet","constructeur-par-défaut","polymorphisme"],"tags":[],"content":"\nNom anglais: function overloading\n\n\nLa surcharge de fonction est un type de surcharge qui permet en C++ de définir plusieurs fonctions portant le même nom, mais avec des paramètres différents (type, nombre ou ordre).\nLe compilateur choisit automatiquement la bonne version à appeler selon les arguments fournis.\nComparaison C/C++ : en langage C, la surcharge n’existe pas — chaque fonction doit avoir un nom unique.\n\nPourquoi surcharger une fonction\n\nPour éviter de multiplier les noms (ex : afficherInt, afficherTexte…)\nPour simplifier l’interface du code\nPour gérer facilement des types ou cas différents\n\nComment surcharger une fonction\nIl suffit de déclarer plusieurs fonctions portant le même nom, mais :\n\navec un nombre différent d’arguments\nou avec des types différents\nou dans un ordre différent (si les types sont distincts)\n\nLes différentes formes de surcharge de fonction\nLa surcharge permet de définir plusieurs fonctions du même nom, qui diffèrent par leur signature. Voici les cas principaux :\nSurcharge par type d’argument\nOn peut définir plusieurs versions d’une fonction qui acceptent des types de paramètres différents.\nvoid afficher(int n);\nvoid afficher(std::string texte);\nvoid afficher(double d);\n \nafficher(42);         // → version int\nafficher(&quot;Bonjour&quot;);  // → version string\nafficher(3.14);       // → version double\nSurcharge par nombre d’arguments\nOn peut surcharger une fonction en lui donnant un nombre différent de paramètres.\nint additionner(int a, int b) {\n    return a + b;\n}\n \nint additionner(int a, int b, int c) {\n    return a + b + c;\n}\n \nadditionner(2, 3);       // → version à 2 arguments\nadditionner(1, 2, 3);    // → version à 3 arguments\nSurcharge par ordre des types\nDeux fonctions peuvent avoir les mêmes types d’arguments, mais dans un ordre différent.\nvoid afficher(std::string texte, int nombre);\nvoid afficher(int nombre, std::string texte);\nSurcharge avec types de retour différents\nLe type de retour peut différer, mais ne suffit pas à lui seul à distinguer deux fonctions.  La signature des paramètres doit aussi différer.\nint multiplier(int a, int b) {\n    return a * b;\n}\n \nfloat multiplier(float a, float b) {\n    return a * b;\n}\n \nint main() {\n    int x = multiplier(2, 3);       // → int\n    float y = multiplier(2.5f, 4);  // → float\n}\n\nCette surcharge par type de retour différent est autorisée, car les paramètres sont différents (int, float). Deux fonctions multiplier(int, int) retournant int et float provoquerait une erreur.\n\nSurcharge à l’intérieur d’une classe\nOn peut surcharger plusieurs méthodes dans une même classe.\nclass Afficheur {\npublic:\n    void afficher(int n);\n    void afficher(double d);\n};\n\nDans une classe, on surcharge très fréquemment les constructeurs, ce qui permet de créer des objets à partir de différents jeux de paramètres — ou sans paramètre du tout, dans le cas du constructeur par défaut.\n\nclass Voiture {\npublic:\n    Voiture();                               // constructeur par défaut\n    Voiture(std::string marque);             // constructeur avec 1 paramètre\n    Voiture(std::string marque, int annee);  // constructeur avec 2 paramètres\n};\n\nVoir aussi\n→ classe, objet\n→  constructeur, polymorphisme"},"surcharge":{"slug":"surcharge","filePath":"surcharge.md","title":"surcharge","links":["C++","fonction","opérateur","compilateur","programmation-orientée-objet","surcharge-de-fonction","surcharge-d'opérateur","objet","signature","polymorphisme","constructeur","classe"],"tags":[],"content":"\nNom anglais : overloading\n\n\nLa surcharge est un mécanisme du C++ qui permet de définir plusieurs fonctions ou opérateurs portant le même nom, mais avec des paramètres différents.\nLe compilateur choisit automatiquement la bonne version à appeler en fonction des arguments fournis.\nComparaison C/C++ : En C, la surcharge n’existe pas. En C++, elle fait partie des fonctionnalités essentielles du langage, permettant une écriture plus claire, plus souple, et qui respecte le paradigme de la programmation orientée objet.\n\n\nExemple simple de surcharge\n#include &lt;iostream&gt;\n \nint additionner(int a, int b) {\n    std::cout &lt;&lt; &quot;[int] &quot;;\n    return a + b;\n}\n \nfloat additionner(float a, float b) {\n    std::cout &lt;&lt; &quot;[float] &quot;;\n    return a + b;\n}\n \nint main() {\n    std::cout &lt;&lt; additionner(2, 3) &lt;&lt; std::endl;     // [int] 5\n    std::cout &lt;&lt; additionner(1.5f, 2.5f) &lt;&lt; std::endl; // [float] 4\n}\n\nTypes de surcharge\nIl existe deux types de surcharge :\n\nla surcharge de fonction\nla surcharge d’opérateur\n\nSurcharge de fonction\nLa surcharge de fonction permet de déclarer plusieurs fonctions ayant le même nom mais des signatures différentes (types ou nombre de paramètres).\nC’est le compilateur qui choisit automatiquement la bonne version selon les arguments.\n→ Voir la fiche dédiée : surcharge de fonction\nSurcharge d’opérateur\nLa surcharge d’opérateur permet de redéfinir le comportement d’un opérateur pour des objets d’une classe : opérateur +, ==, &lt;&lt;, etc.\nCela permet d’utiliser une syntaxe naturelle avec ses propres types.\n→ Voir la fiche dédiée : surcharge d’opérateur\n\nPourquoi utiliser la surcharge ?\nLa surcharge permet de :\n\nutiliser des noms cohérents pour des opérations similaires,\néviter l’inflation de noms comme additionnerInt, additionnerFloat, etc.\nrendre le code plus expressif et plus facile à maintenir.\n\n\nLimites de la surcharge\nCertains éléments ne peuvent pas être surchargés, ou présentent des restrictions :\n\nOn ne peut pas surcharger uniquement le type de retour\nOn ne peut pas créer de nouveaux opérateurs (**, %%, etc.)\nCertains opérateurs ne sont pas surchargeables (::, ., .*, sizeof, typeid, etc.)\n\n\nVoir aussi\n→ surcharge de fonction, surcharge d’opérateur\n→ fonction, opérateur, signature, polymorphisme\n→ programmation orientée objet, constructeur, classe, objet"},"surchargé":{"slug":"surchargé","filePath":"surchargé.md","title":"surchargé","links":["surcharge"],"tags":[],"content":"\nNom anglais: overloaded / overloading\n\n→ voir l’article surcharge"},"syntaxe":{"slug":"syntaxe","filePath":"syntaxe.md","title":"syntaxe","links":[],"tags":[],"content":""},"système-d’exploitation":{"slug":"système-d’exploitation","filePath":"système d’exploitation.md","title":"système d’exploitation","links":["terminal"],"tags":[],"content":"Qu’est-ce qu’un système d’exploitation?\n\nUn système d’exploitation (souvent abrégé en OS, pour Operating System) est un logiciel essentiel qui sert d’interface entre l’utilisateur et le matériel de l’ordinateur.\nIl gère l’exécution des programmes, l’organisation des fichiers, la mémoire, les périphériques, et contrôle les ressources du système.\n\nEn résumé\n\nIl fait fonctionner l’ordinateur.\nIl gère la mémoire, le processeur, les disques, les périphériques (clavier, souris, imprimante…).\nIl offre une interface pour lancer des applications (interface graphique ou terminal).\n\nExemples de systèmes d’exploitation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSystèmePlateformeWindowsPCmacOSMacLinux (Ubuntu, Fedora…)PC, serveursAndroidSmartphones/tablettesiOSiPhone/iPad\nÀ retenir\n\nSans système d’exploitation, un ordinateur ne peut pas fonctionner.\nIl coordonne tous les composants matériels et logiciels.\nIl offre aux utilisateurs un environnement stable et organisé pour travailler.\n"},"tampon-de-sortie":{"slug":"tampon-de-sortie","filePath":"tampon de sortie.md","title":"tampon de sortie","links":["flush"],"tags":[],"content":"\nNom anglais: output buffer\n\n\nLe tampon de sortie est une zone temporaire de mémoire utilisée pour stocker les données à afficher avant qu’elles ne soient réellement envoyées à la sortie (comme l’écran).\nCela permet d’optimiser les performances en regroupant les écritures.\n\nPourquoi utiliser un tampon ?\nLes écritures directes (comme à l’écran ou dans un fichier) sont lentes.\nLe tampon permet :\n\nde stocker temporairement ce qu’on veut afficher,\nd’envoyer le tout en une seule fois, plus efficacement,\nde réduire le nombre d’opérations coûteuses.\n\nQuand le tampon est-il vidé (flush) ?\nLe tampon est vidé (envoyé à la sortie) :\n\nautomatiquement, à la fin du programme,\nquand un saut de ligne est rencontré (selon le système),\nquand on appelle explicitement un flush, par exemple avec std::endl ou std::flush,\nparfois, lors d’une lecture utilisateur (std::cin).\n\nExemple\nstd::cout &lt;&lt; &quot;Bonjour&quot;; // rien ne s’affiche encore peut-être\nstd::cout &lt;&lt; std::endl; // flush → le texte est envoyé à l’écran\nRésumé\n\nLe tampon de sortie est un mécanisme d’optimisation qui retarde l’affichage pour le rendre plus efficace.\nOn peut le forcer à se vider (flush) avec std::endl ou std::flush.\n"},"tampon":{"slug":"tampon","filePath":"tampon.md","title":"tampon","links":[],"tags":[],"content":""},"tas":{"slug":"tas","filePath":"tas.md","title":"tas","links":["allocation-dynamique-de-la-mémoire","objet","bloc","pile"],"tags":[],"content":"\nNom anglais : heap\n\n\nLe tas est une zone mémoire utilisée pour l’allocation dynamique de la mémoire avec new ou malloc.\nElle permet de créer des objets qui survivent au-delà du bloc où ils ont été créés.\nComparaison C/C++: Le C utilise le mot-clé malloc pour allouer de la mémoire; le C++ utilise de préférence new\n\nCaractéristiques\n\nAllocation manuelle\nPlus lent que la pile\nContrôle total sur la durée de vie\nRisque de fuites mémoire si delete oublié (comme le free en C)\n\nExemple\nint* p = new int(42);  // alloué sur le tas\ndelete p;              // libération manuelle"},"terminal":{"slug":"terminal","filePath":"terminal.md","title":"terminal","links":["système-d’exploitation","interface-graphique","interpréteur-de-commande","interfaces-graphiques"],"tags":[],"content":"Qu’est-ce qu’un terminal?\n\nUn terminal est une interface en ligne de commande qui permet à l’utilisateur d’envoyer des instructions directement au système d’exploitation en tapant du texte.\nC’est un outil puissant pour lancer des programmes, naviguer dans les fichiers, installer des logiciels, et administrer un système.\n\nEn résumé\n\nLe terminal affiche du texte et attend des commandes que l’utilisateur tape.\nIl permet de contrôler l’ordinateur sans interface graphique.\nIl communique souvent avec un interpréteur de commande (comme bash, zsh, ou fish).\n\n📚 Exemples de terminaux\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTerminalPlateformeTerminal.appmacOSGNOME TerminalLinuxWindows Terminal / PowerShellWindows\nÀ retenir\n\nLe terminal est plus rapide que les interfaces graphiques pour beaucoup de tâches techniques.\nC’est l’outil principal des développeurs, administrateurs système, et utilisateurs avancés.\nOn y utilise des commandes comme ls, cd, mkdir, g++, etc.\n"},"this":{"slug":"this","filePath":"this.md","title":"this","links":["C++","méthode","classe","objet","attribut","fonction","paramètre"],"tags":[],"content":"\nNom anglais: this pointer\n\n\nEn C++, le mot-clé this est un pointeur implicite disponible dans chaque méthode non statique d’une classe. Il pointe vers l’objet courant sur lequel la méthode a été appelée.\nComparaison C/C++: this  n’existe pas en C.\n\n\nÀ quoi sert this\n\nAccéder explicitement à l’objet courant\nRésoudre des conflits de noms (ex : entre un attribut et un paramètre)\nRetourner l’objet courant depuis une méthode (return *this;)\nChaîner des appels de méthodes (objet.methode1().methode2();)\nPasser l’objet courant à une autre fonction (autreFonction(this);)\n\n\nExemple de base\nclass Personne {\nprivate:\n    std::string nom;\n \npublic:\n    void setNom(std::string nom) {\n        this-&gt;nom = nom;  // évite la confusion avec le paramètre\n    }\n \n    void afficherNom() {\n        std::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; this-&gt;nom &lt;&lt; std::endl;\n    }\n};\n\nIci, this-&gt;nom désigne l’attribut, tandis que nom seul désigne le paramètre.\n\n\nthis dans une méthode fluide\nclass Compteur {\nprivate:\n    int valeur;\n \npublic:\n    Compteur&amp; incrementer() {\n        valeur++;\n        return *this;  // permet le chaînage\n    }\n};\nUtilisation :\nCompteur c;\nc.incrementer().incrementer();  // Chaînage grâce à `return *this`\n\nType de this\n\nDans une méthode non const : ClassName* this\nDans une méthode const : const ClassName* this\n\n\nRésumé\n\nLe mot-clé this est un pointeur vers l’objet courant, utile pour manipuler explicitement l’instance en cours dans les méthodes.\nIl permet de clarifier le code, de chaîner les appels, et d’éviter les confusions de nom dans les méthodes d’une classe.\n"},"time":{"slug":"time","filePath":"time.md","title":"time","links":["bibliothèque-standard-C++","C","C++"],"tags":[],"content":"\nNom pleinement qualifié : std::time\n\n\nLa fonction time de la bibliothèque standard C++ permet d’obtenir le nombre de secondes écoulées depuis le 1er janvier 1970 (epoch UNIX).\nC’est la base pour travailler avec la date et l’heure en C ou C++.\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);  // ou std::time(NULL)\n    std::cout &lt;&lt; now &lt;&lt; std::endl;   // nombre de secondes depuis 1970\n}\n\n🔸 Retourne un std::time_t, généralement un long int.\n\nUsage concret\n\nObtenir l’heure actuelle brute\nPasser ce temps à gmtime ou localtime pour le décoder\nMesurer des durées simples\n"},"toupper":{"slug":"toupper","filePath":"toupper.md","title":"toupper","links":["Nom-pleinement-qualifié","fonction","bibliothèque-standard-C++"],"tags":[],"content":"\nNom pleinement qualifié: std::toupper\n\n\nstd::toupper est une fonction de labibliothèque standard C++ qui permet de convertir un caractère en majuscule, si c’est une lettre minuscule.\nElle fait partie de l’en-tête &lt;cctype&gt;.\n\nDéclaration\nint std::toupper(int c);\n\nPrend un caractère (en int) en paramètre\nRetourne la version majuscule si applicable, sinon le caractère inchangé\n\nUtilisation\n#include &lt;iostream&gt;\n#include &lt;cctype&gt;\n \nint main()\n{\n    char lettre = &#039;a&#039;;\n    char maj = std::toupper(lettre); // maj = &#039;A&#039;\n \n    std::cout &lt;&lt; maj &lt;&lt; std::endl;\n    return 0;\n}\nAttention\n\nstd::toupper prend et retourne un int, mais on peut le convertir en char si nécessaire\nNe pas lui passer de valeurs invalides (idéalement, utilise un unsigned char ou EOF)\n\nRésumé\n\nstd::toupper convertit un caractère minuscule en majuscule.\nElle est définie dans &lt;cctype&gt; et retourne un int, que l’on peut convertir en char.\n"},"type-interne":{"slug":"type-interne","filePath":"type interne.md","title":"type interne","links":["classe","C++.","membre","C++","programmation-orientée-objet","publique","privé"],"tags":[],"content":"\nNom anglais: nested type / internal type\n\n\nUn type interne est un type (comme une classe, une struct, ou un enum) défini à l’intérieur d’une classe en C++. Il est lui-même un membre de la classe.\nComparaison C/C++ : En C, on peut aussi définir des struct ou enum à l’intérieur d’autres structures, mais en C++ c’est plus systématique et utilisé dans la programmation orientée objet.\n\nPourquoi utiliser un type interne\nLes types internes permettent :\n\nde organiser le code logiquement,\nde limiter la portée d’un type au sein d’une classe,\nde structurer des relations fortes entre plusieurs types.\n\nIls sont souvent utilisés pour modéliser des concepts étroitement liés à une seule classe.\nExemple\nclass Voiture\n{\npublic:\n    enum class TypeMoteur { Essence, Diesel, Electrique }; // type interne\n \nprivate:\n    TypeMoteur moteur;\n};\nIci, TypeMoteur est un type interne à la classe Voiture.\nRésumé\nUn type interne est un membre qui définit un nouveau type au sein d’une classe.\nIl suit les mêmes règles publique ou privé selon où il est placé."},"valeur-par-défaut":{"slug":"valeur-par-défaut","filePath":"valeur par défaut.md","title":"valeur par défaut","links":["paramètre","fonction","argument","C++","classe","méthode","organisation-des-fichiers-d'une-classe","valeur-par-défaut","surcharge-de-fonction","surcharge","paramètres","compilateur"],"tags":[],"content":"\nNom anglais: default argument / default parameter\n\n\nUne valeur par défaut est une valeur assignée à un paramètre dans la déclaration d’une fonction.\nSi l’appel de la fonction n’indique pas d’argument pour ce paramètre, la valeur par défaut sera utilisée automatiquement.\nComparaison C/C++ : Le C ne permet pas de définir des valeurs par défaut. Cette fonctionnalité est propre à C++ et améliore la souplesse d’appel des fonctions.\n\n\nExemple simple\nvoid saluer(std::string nom = &quot;inconnu&quot;) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nAppels possibles :\nsaluer(&quot;Alice&quot;);  // affiche &quot;Bonjour, Alice&quot;\nsaluer();         // affiche &quot;Bonjour, inconnu&quot;\n\nRègles à connaître\n\nLa valeur par défaut doit être définie dans la déclaration de la fonction, généralement dans le fichier .hpp.\nSi plusieurs paramètres ont une valeur par défaut, ils doivent être placés à la fin (après tous les paramètres obligatoires).\n\n// Déclaration valide :\nvoid afficher(int a, int b = 0, int c = 1);\n \n// ❌ Erreur : les paramètres avec valeurs par défaut ne doivent pas précéder ceux qui n’en ont pas :\nvoid afficher(int a = 0, int b, int c = 1);\n\nUtilisation en classe\nDans une classe, les valeurs par défaut sont généralement définies dans la déclaration de la méthode dans le .hpp :\nclass Voiture {\npublic:\n    void deplacer(int vitesse = 50);\n};\n\nLa valeur par défaut n’est pas répétée dans la définition de la méthode dans le .cpp.\n\n→ Voir la fiche dédiée : organisation des fichiers d’une classe\n\nPièges à éviter\n\nNe pas mélanger valeur par défautet surcharge de fonction de manière ambiguë.\nEn cas de surcharge, seules les déclarations sans valeur par défaut doivent accompagner celles qui en ont.\n\n\nLorsqu’on utilise à la fois des fonctions surchargées et des paramètres avec des valeurs par défaut, cela peut créer des conflits ou des ambiguïtés pour le compilateur, qui ne saura pas quelle version appeler.\n\nvoid afficher(int a = 0);\n// éviter d’ajouter aussi : void afficher(); → ambigu avec afficher(int)\n\nVoir aussi\n→ fonction, paramètre, argument\n→ surcharge de fonction, classe, organisation des fichiers d’une classe"},"valeur":{"slug":"valeur","filePath":"valeur.md","title":"valeur","links":["C++","variable","fonction","littéral","paramètre","argument","référence","objet","valeur-par-défaut"],"tags":[],"content":"\nNom anglais: value\n\n\nEn C++, une valeur est une donnée concrète qu’on peut affecter à une variable, passer à une fonction, ou manipuler dans une expression. Elle représente le contenu réel en mémoire, comme 42, &quot;bonjour&quot;, 3.14, ou encore true.\nComparaison C/C++ : Le concept de valeur est identique dans les deux langages : une valeur est le contenu d’une variable ou d’un littéral.\n\n\nValeur vs littéral\nUn littéral est une valeur écrite en dur dans le code :\nint x = 42;       // 42 est un littéral → c’est une valeur\nbool actif = true; // true est une valeur\nTout littéral est une valeur, mais une valeur peut aussi venir d’une variable, d’un paramètre, d’un retour de fonction, etc.\n\nValeur, paramètre et argument\nCes notions sont souvent confondues. Voici un tableau pour clarifier :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTermeDéfinitionvaleurUne donnée concrète (42, &quot;ok&quot;, 3.14, etc.)paramètreUne variable déclarée dans une fonction pour recevoir une valeurargumentUne valeur fournie lors de l’appel de la fonction\nExemple\nvoid afficherMessage(std::string message) {\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n \nafficherMessage(&quot;Bonjour&quot;);\n\n&quot;Bonjour&quot; est une valeur\nmessage est un paramètre\n&quot;Bonjour&quot; est aussi l’argument passé à la fonction\n\n\nValeur vs référence\nPar défaut, les fonctions prennent leurs paramètres par valeur :\nvoid doubler(int n) {\n    n = n * 2; // copie → l’original ne change pas\n}\nMais en passant une référence, on manipule directement l’objet d’origine :\nvoid doublerRef(int&amp; n) {\n    n = n * 2; // modification directe de la variable\n}\n\nLes valeurs sont copiées, les références sont partagées.\n\n\nTypes de valeurs\nUne valeur peut être :\n\nun littéral (42, &quot;ok&quot;, true, 3.14)\nune variable évaluée (x, nom, a + b)\nune expression (f(4), t[3], tab.size()\n\n\nExemple récapitulatif\nint a = 5;             // 5 est une valeur\nint b = a + 3;         // a + 3 est une expression qui produit une valeur\nstd::string s = &quot;ok&quot;;  // &quot;ok&quot; est une valeur de type string\n\nVoir aussi\n→ variable, littéral\n→paramètre, argument\n→référence, fonction, valeur par défaut"},"variable":{"slug":"variable","filePath":"variable.md","title":"variable","links":[],"tags":[],"content":""},"vecteur":{"slug":"vecteur","filePath":"vecteur.md","title":"vecteur","links":["conteneur","STL","C++","méthode","bibliothèque-standard-C++","nom-pleinement-qualifié","cache","itérateur"],"tags":[],"content":"\nNom anglais: vector\nNom pleinement qualifié: std::vector\n\n\nUn vector est un conteneur dynamique fourni par la STL (Standard Template Library) en C++. Il permet de stocker une séquence de données dans une structure qui peut changer de taille automatiquement.\nIl fonctionne comme un tableau dynamique, dont la mémoire est allouée dynamiquement et peut être réallouée automatiquement en cas de besoin. Contrairement à un tableau C, un vector connaît sa propre taille et offre des méthodes puissantes pour insérer, supprimer, accéder et itérer sur les éléments.\nComparaison C/C++ : Un vector est une encapsulation évoluée d’un tableau C. Il offre :\n\nune taille connue (size())\nune capacité extensible (reserve())\ndes méthodes sûres (at())\nune mémoire auto-gérée\n\n\n\nInclude\nPour utiliser std::vector il faut l’inclusion suivante :\n#include &lt;vector&gt;\n\nEspace de nom\nLes vecteurs font partie de la STL de la bibliothèque standard C++. Il faut donc les utiliser via leur nom pleinement qualifié :\n→ std::vector\nou bien déclarer un :\n→ using namespace std\n\nSyntaxe\nDéclaration\nPour déclarer un vector il faut utiliser la syntaxe suivante :\nstd::vector&lt;type&gt; myVector;\n \n// exemple pour un vecteur d&#039;int :\nstd::vector&lt;int&gt; myIntVector;\n \n// exemple pour un vecteur de std::string :\nstd::vector&lt;std::string&gt; myStringVector;\n \n// exemple avec initialisation :\nstd::vector&lt;int&gt; v(10, 5); // 10 éléments valant 5\nInitialisation\nIl existe plusieurs façon d’initialiser un vecteur:\n→ En C++98\nstd::vector&lt;int&gt; v1;                // vecteur vide\nstd::vector&lt;int&gt; v2(10);            // 10 éléments initialisés à 0\nstd::vector&lt;int&gt; v3(10, 5);         // 10 éléments valant 5\nint arr[] = {1, 2, 3, 4};\nstd::vector&lt;int&gt; v4(arr, arr + 4);  // copie depuis un tableau C\n→ En C++11 et plus\nstd::vector&lt;int&gt; v5 = {1, 2, 3, 4};       // initialisation par liste\nstd::vector&lt;std::string&gt; v6{&quot;a&quot;, &quot;b&quot;};    // initialisation par accolades\nstd::vector&lt;int&gt; v7{10};                 // un seul élément valant 10 (⚠️ pas 10 éléments !)\nstd::vector&lt;int&gt; v8{10, 5};              // deux éléments : 10 et 5\n\n⚠️ Attention : std::vector&lt;int&gt; v(10, 5); crée 10 éléments de valeur 5\nTandis que std::vector&lt;int&gt; v{10, 5}; crée un vecteur avec les éléments 10 et 5\n\n\nImplémentation interne\nUn vector&lt;T&gt; encapsule :\n\nun tableau dynamique en mémoire contiguë (de type T*)\nune taille courante (size)\nune capacité (taille allouée réelle, ≥ taille utilisée)\nune logique d’agrandissement automatique (souvent ×2)\n\n\nEn C++98, vector est implémenté via un tableau C alloué avec new T[], et géré manuellement en interne.\n\n\nVecteur et mémoire\nLe std::vector alloue sa mémoire de façon contiguë, ce qui signifie que tous les éléments sont stockés dans un seul bloc linéaire de mémoire. Cela permet :\n\nun accès extrêmement rapide par index (O(1))\nune excellente localité mémoire, favorable au cache du processeur\nune compatibilité naturelle avec les pointeurs (&amp;vec[0])\n\nMais contrairement à un tableau statique, le vector gère dynamiquement sa capacité. Pour éviter de devoir réallouer de la mémoire à chaque push_back(), il maintient deux tailles distinctes :\n\nsize() : nombre réel d’éléments stockés\ncapacity() : espace alloué actuellement (≥ size())\n\nQuand on dépasse capacity(), le vector alloue un nouveau bloc, souvent de taille doublée, puis copie tous les éléments dedans.\nOn peut contrôler cela avec :\n\nreserve(n) pour allouer de l’espace à l’avance\nresize(n) pour ajuster la taille logique\nclear() pour supprimer tous les éléments (mais la capacité reste)\nshrink_to_fit() n’existe pas en C++98 (ajouté en C++11)\n\nCette stratégie d’allocation anticipée améliore fortement les performances, notamment dans les boucles avec push_back(), en réduisant le nombre de réallocations. Elle implique en contrepartie que certaines opérations (comme push_back() au-delà de la capacité) peuvent être coûteuses, car elles impliquent une reallocation complète.\n\nQuand et pourquoi utiliser un vecteur\nUn vecteur (std::vector) est le conteneur de choix lorsqu’il faut stocker une séquence de taille variable avec un accès rapide par index (O(1)). Il est idéal pour les cas où les éléments sont principalement ajoutés à la fin et où les parcours séquentiels sont fréquents. Grâce à sa mémoire contiguë, il offre d’excellentes performances en termes de localité mémoire (cache-friendly). On l’utilise dès qu’on veut une alternative souple à un tableau C statique, avec une gestion automatique de la taille et une compatibilité naturelle avec les algorithmes STL.\n\nSouhaites-tu maintenant celui pour deque, list ou un autre ?\nMéthodes principales\nAccès et propriétés\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionsize()Retourne le nombre d’éléments stockéscapacity()Retourne la capacité allouée (≥ size())empty()Vérifie si le vector est videoperator[]Accès direct sans vérificationat(index)Accès sécurisé (avec vérification d’index)front() / back()Accès au premier / dernier élémentmax_size()Nombre maximal théorique d’éléments (dépend de l’implémentation)\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionpush_back(val)Ajoute val à la fin (agrandit si besoin)pop_back()Supprime le dernier élémentinsert(pos, val)Insère val à la position pos (décale le reste)erase(pos)Supprime l’élément à la position posclear()Vide complètement le vecteur\nGestion mémoire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionreserve(n)Alloue de l’espace pour au moins n élémentsresize(n)Redimensionne la taille à n (ajoute ou retire)shrink_to_fit()❌ N’existe pas en C++98 (C++11 uniquement)\nItérateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionbegin() / end()Itérateurs sur le début / fin du conteneurrbegin() / rend()Itérateurs inversés\n\nLes itérateurs permettent un parcours standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodeDescriptionassign(n, val)Remplit le vecteur avec n copies de valoperator=Affecte un autre vecteur\n\nRemarques importantes\n\nstd::vector stocke ses données dans une zone mémoire contiguë : très bon pour le cache et les performances\nLes insertions au milieu ou au début sont lentes (O(n))\nLes itérateurs peuvent devenir invalides après un push_back() si la capacité est dépassée\n"},"virtuel":{"slug":"virtuel","filePath":"virtuel.md","title":"virtuel","links":["méthode","classe-de-base","surcharge","classe-dérivée","polymorphisme","C++","objet"],"tags":[],"content":"\nNom anglais: virtual\n\n\nLe mot-clé virtual sert à marquer une méthode dans une classe de base pour permettre sa surcharge correcte (override) dans une classe dérivée. Il active ce qu’on appelle le polymorphisme dynamique en C++.\nComparaison C/C++: En C, il n’y a pas de concept de méthode virtuelle. En C++, virtual est indispensable pour que l’appel d’une méthode sur un objet utilise la bonne version selon son type réel.\n\nPourquoi utiliser virtual\nLe mot-clé virtual :\n\npermet aux classe dérivées de redéfinir une méthode,\ngarantit que l’appel à la méthode utilisera la bonne version à l’exécution,\nrend possible le polymorphisme, où un même appel se comporte différemment selon l’objet.\n\nDéfinir une méthode virtuelle\nOn ajoute le mot-clé virtual devant la déclaration de la méthode dans la classe de base :\nclass Vehicule\n{\npublic:\n    virtual void demarrer();\n};\nEnsuite, dans la classe dérivée :\nclass Voiture : public Vehicule\n{\npublic:\n    void demarrer() override; // surcharge\n};\nLe mot-clé override (voir l’article sur la surcharge) dans la classe enfant n’est pas obligatoire mais fortement recommandé pour éviter les erreurs.\nExemple\nVehicule* v = new Voiture();\nv-&gt;demarrer();\nMême si v est un pointeur vers Vehicule, c’est la version Voiture::demarrer() qui sera appelée, grâce à virtual."}}